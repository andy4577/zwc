import { Color as J } from "../../../@kurkle/color/dist/color.esm.js";
/*!
 * Chart.js v4.1.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
function ut() {
}
const ft = (() => {
  let e = 0;
  return () => e++;
})();
function v(e) {
  return e === null || typeof e > "u";
}
function _(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function b(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function V(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function ht(e, t) {
  return V(e) ? e : t;
}
function P(e, t) {
  return typeof e > "u" ? t : e;
}
const dt = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, he = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function gt(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function mt(e, t, n, r) {
  let o, i, s;
  if (_(e))
    if (i = e.length, r)
      for (o = i - 1; o >= 0; o--)
        t.call(n, e[o], o);
    else
      for (o = 0; o < i; o++)
        t.call(n, e[o], o);
  else if (b(e))
    for (s = Object.keys(e), i = s.length, o = 0; o < i; o++)
      t.call(n, e[s[o]], s[o]);
}
function bt(e, t) {
  let n, r, o, i;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, r = e.length; n < r; ++n)
    if (o = e[n], i = t[n], o.datasetIndex !== i.datasetIndex || o.index !== i.index)
      return !1;
  return !0;
}
function j(e) {
  if (_(e))
    return e.map(j);
  if (b(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), r = n.length;
    let o = 0;
    for (; o < r; ++o)
      t[n[o]] = j(e[n[o]]);
    return t;
  }
  return e;
}
function ee(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function de(e, t, n, r) {
  if (!ee(e))
    return;
  const o = t[e], i = n[e];
  b(o) && b(i) ? A(o, i, r) : t[e] = j(i);
}
function A(e, t, n) {
  const r = _(t) ? t : [
    t
  ], o = r.length;
  if (!b(e))
    return e;
  n = n || {};
  const i = n.merger || de;
  let s;
  for (let a = 0; a < o; ++a) {
    if (s = r[a], !b(s))
      continue;
    const c = Object.keys(s);
    for (let l = 0, f = c.length; l < f; ++l)
      i(c[l], e, s, n);
  }
  return e;
}
function ge(e, t) {
  return A(e, t, {
    merger: me
  });
}
function me(e, t, n) {
  if (!ee(e))
    return;
  const r = t[e], o = n[e];
  b(r) && b(o) ? ge(r, o) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = j(o));
}
const q = {
  "": (e) => e,
  x: (e) => e.x,
  y: (e) => e.y
};
function be(e) {
  const t = e.split("."), n = [];
  let r = "";
  for (const o of t)
    r += o, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
  return n;
}
function pe(e) {
  const t = be(e);
  return (n) => {
    for (const r of t) {
      if (r === "")
        break;
      n = n && n[r];
    }
    return n;
  };
}
function te(e, t) {
  return (q[t] || (q[t] = pe(t)))(e);
}
function ne(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const S = (e) => typeof e < "u", W = (e) => typeof e == "function", pt = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function _t(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const p = Math.PI, M = 2 * p, B = Number.POSITIVE_INFINITY, _e = p / 180, y = p / 2, O = p / 4, Q = p * 2 / 3, z = Math.log10, yt = Math.sign;
function ye(e, t, n) {
  return Math.abs(e - t) < n;
}
function Mt(e) {
  const t = Math.round(e);
  e = ye(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(z(e))), r = e / n;
  return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function Ot(e) {
  const t = [], n = Math.sqrt(e);
  let r;
  for (r = 1; r < n; r++)
    e % r === 0 && (t.push(r), t.push(e / r));
  return n === (n | 0) && t.push(n), t.sort((o, i) => o - i).pop(), t;
}
function wt(e) {
  return !isNaN(parseFloat(e)) && isFinite(e);
}
function Pt(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function Tt(e, t, n) {
  let r, o, i;
  for (r = 0, o = e.length; r < o; r++)
    i = e[r][n], isNaN(i) || (t.min = Math.min(t.min, i), t.max = Math.max(t.max, i));
}
function St(e) {
  return e * (p / 180);
}
function Rt(e) {
  return e * (180 / p);
}
function kt(e) {
  if (!V(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function Ct(e, t) {
  const n = t.x - e.x, r = t.y - e.y, o = Math.sqrt(n * n + r * r);
  let i = Math.atan2(r, n);
  return i < -0.5 * p && (i += M), {
    angle: i,
    distance: o
  };
}
function It(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function w(e) {
  return (e % M + M) % M;
}
function vt(e, t, n, r) {
  const o = w(e), i = w(t), s = w(n), a = w(i - o), c = w(s - o), l = w(o - i), f = w(o - s);
  return o === i || o === s || r && i === s || a > c && l < f;
}
function Me(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function jt(e) {
  return Me(e, -32768, 32767);
}
function At(e, t, n, r = 1e-6) {
  return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r;
}
function re(e, t, n) {
  n = n || ((s) => e[s] < t);
  let r = e.length - 1, o = 0, i;
  for (; r - o > 1; )
    i = o + r >> 1, n(i) ? o = i : r = i;
  return {
    lo: o,
    hi: r
  };
}
const Wt = (e, t, n, r) => re(e, n, r ? (o) => {
  const i = e[o][t];
  return i < n || i === n && e[o + 1][t] === n;
} : (o) => e[o][t] < n), Bt = (e, t, n) => re(e, n, (r) => e[r][t] >= n);
function Dt(e, t, n) {
  let r = 0, o = e.length;
  for (; r < o && e[r] < t; )
    r++;
  for (; o > r && e[o - 1] > n; )
    o--;
  return r > 0 || o < e.length ? e.slice(r, o) : e;
}
const oe = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function Et(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), oe.forEach((n) => {
    const r = "_onData" + ne(n), o = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...i) {
        const s = o.apply(this, i);
        return e._chartjs.listeners.forEach((a) => {
          typeof a[r] == "function" && a[r](...i);
        }), s;
      }
    });
  });
}
function Lt(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const r = n.listeners, o = r.indexOf(t);
  o !== -1 && r.splice(o, 1), !(r.length > 0) && (oe.forEach((i) => {
    delete e[i];
  }), delete e._chartjs);
}
function Ft(e) {
  const t = /* @__PURE__ */ new Set();
  let n, r;
  for (n = 0, r = e.length; n < r; ++n)
    t.add(e[n]);
  return t.size === r ? e : Array.from(t);
}
const Oe = function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
}();
function Ht(e, t) {
  let n = [], r = !1;
  return function(...o) {
    n = o, r || (r = !0, Oe.call(window, () => {
      r = !1, e.apply(t, n);
    }));
  };
}
function Nt(e, t) {
  let n;
  return function(...r) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, r)) : e.apply(this, r), t;
  };
}
const zt = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", Kt = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, xt = (e, t, n, r) => e === (r ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t, C = (e) => e === 0 || e === 1, U = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * M / n)), G = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * M / n) + 1, F = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * y) + 1,
  easeOutSine: (e) => Math.sin(e * y),
  easeInOutSine: (e) => -0.5 * (Math.cos(p * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => C(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => C(e) ? e : U(e, 0.075, 0.3),
  easeOutElastic: (e) => C(e) ? e : G(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return C(e) ? e : e < 0.5 ? 0.5 * U(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * G(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - F.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? F.easeInBounce(e * 2) * 0.5 : F.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function ie(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function qt(e) {
  return ie(e) ? e : new J(e);
}
function H(e) {
  return ie(e) ? e : new J(e).saturate(0.5).darken(0.1).hexString();
}
const we = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Pe = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Te(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: Pe
    },
    numbers: {
      type: "number",
      properties: we
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function Se(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const Y = /* @__PURE__ */ new Map();
function Re(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let r = Y.get(n);
  return r || (r = new Intl.NumberFormat(e, t), Y.set(n, r)), r;
}
function ke(e, t, n) {
  return Re(t, n).format(e);
}
const se = {
  values(e) {
    return _(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const r = this.chart.options.locale;
    let o, i = e;
    if (n.length > 1) {
      const l = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (l < 1e-4 || l > 1e15) && (o = "scientific"), i = Ce(e, n);
    }
    const s = z(Math.abs(i)), a = Math.max(Math.min(-1 * Math.floor(s), 20), 0), c = {
      notation: o,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(c, this.options.ticks.format), ke(e, r, c);
  },
  logarithmic(e, t, n) {
    if (e === 0)
      return "0";
    const r = n[t].significand || e / Math.pow(10, Math.floor(z(e)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(r) || t > 0.8 * n.length ? se.numeric.call(this, e, t, n) : "";
  }
};
function Ce(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var Ie = {
  formatters: se
};
function ve(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ie.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const je = /* @__PURE__ */ Object.create(null), Ae = /* @__PURE__ */ Object.create(null);
function k(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let r = 0, o = n.length; r < o; ++r) {
    const i = n[r];
    e = e[i] || (e[i] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function N(e, t, n) {
  return typeof t == "string" ? A(k(e, t), n) : A(k(e, ""), t);
}
class We {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (r) => r.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (r, o) => H(o.backgroundColor), this.hoverBorderColor = (r, o) => H(o.borderColor), this.hoverColor = (r, o) => H(o.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return N(this, t, n);
  }
  get(t) {
    return k(this, t);
  }
  describe(t, n) {
    return N(Ae, t, n);
  }
  override(t, n) {
    return N(je, t, n);
  }
  route(t, n, r, o) {
    const i = k(this, t), s = k(this, r), a = "_" + n;
    Object.defineProperties(i, {
      [a]: {
        value: i[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const c = this[a], l = s[o];
          return b(c) ? Object.assign({}, l, c) : P(c, l);
        },
        set(c) {
          this[a] = c;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var Be = /* @__PURE__ */ new We({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Te,
  Se,
  ve
]);
function De(e) {
  return !e || v(e.size) || v(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function $(e, t, n, r, o) {
  let i = t[o];
  return i || (i = t[o] = e.measureText(o).width, n.push(o)), i > r && (r = i), r;
}
function Qt(e, t, n, r) {
  r = r || {};
  let o = r.data = r.data || {}, i = r.garbageCollect = r.garbageCollect || [];
  r.font !== t && (o = r.data = {}, i = r.garbageCollect = [], r.font = t), e.save(), e.font = t;
  let s = 0;
  const a = n.length;
  let c, l, f, d, g;
  for (c = 0; c < a; c++)
    if (d = n[c], d != null && _(d) !== !0)
      s = $(e, o, i, s, d);
    else if (_(d))
      for (l = 0, f = d.length; l < f; l++)
        g = d[l], g != null && !_(g) && (s = $(e, o, i, s, g));
  e.restore();
  const m = i.length / 2;
  if (m > n.length) {
    for (c = 0; c < m; c++)
      delete o[i[c]];
    i.splice(0, m);
  }
  return s;
}
function Ut(e, t, n) {
  const r = e.currentDevicePixelRatio, o = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - o) * r) / r + o;
}
function Gt(e, t) {
  t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore();
}
function Yt(e, t, n, r) {
  Ee(e, t, n, r, null);
}
function Ee(e, t, n, r, o) {
  let i, s, a, c, l, f, d, g;
  const m = t.pointStyle, R = t.rotation, h = t.radius;
  let u = (R || 0) * _e;
  if (m && typeof m == "object" && (i = m.toString(), i === "[object HTMLImageElement]" || i === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, r), e.rotate(u), e.drawImage(m, -m.width / 2, -m.height / 2, m.width, m.height), e.restore();
    return;
  }
  if (!(isNaN(h) || h <= 0)) {
    switch (e.beginPath(), m) {
      default:
        o ? e.ellipse(n, r, o / 2, h, 0, 0, M) : e.arc(n, r, h, 0, M), e.closePath();
        break;
      case "triangle":
        f = o ? o / 2 : h, e.moveTo(n + Math.sin(u) * f, r - Math.cos(u) * h), u += Q, e.lineTo(n + Math.sin(u) * f, r - Math.cos(u) * h), u += Q, e.lineTo(n + Math.sin(u) * f, r - Math.cos(u) * h), e.closePath();
        break;
      case "rectRounded":
        l = h * 0.516, c = h - l, s = Math.cos(u + O) * c, d = Math.cos(u + O) * (o ? o / 2 - l : c), a = Math.sin(u + O) * c, g = Math.sin(u + O) * (o ? o / 2 - l : c), e.arc(n - d, r - a, l, u - p, u - y), e.arc(n + g, r - s, l, u - y, u), e.arc(n + d, r + a, l, u, u + y), e.arc(n - g, r + s, l, u + y, u + p), e.closePath();
        break;
      case "rect":
        if (!R) {
          c = Math.SQRT1_2 * h, f = o ? o / 2 : c, e.rect(n - f, r - c, 2 * f, 2 * c);
          break;
        }
        u += O;
      case "rectRot":
        d = Math.cos(u) * (o ? o / 2 : h), s = Math.cos(u) * h, a = Math.sin(u) * h, g = Math.sin(u) * (o ? o / 2 : h), e.moveTo(n - d, r - a), e.lineTo(n + g, r - s), e.lineTo(n + d, r + a), e.lineTo(n - g, r + s), e.closePath();
        break;
      case "crossRot":
        u += O;
      case "cross":
        d = Math.cos(u) * (o ? o / 2 : h), s = Math.cos(u) * h, a = Math.sin(u) * h, g = Math.sin(u) * (o ? o / 2 : h), e.moveTo(n - d, r - a), e.lineTo(n + d, r + a), e.moveTo(n + g, r - s), e.lineTo(n - g, r + s);
        break;
      case "star":
        d = Math.cos(u) * (o ? o / 2 : h), s = Math.cos(u) * h, a = Math.sin(u) * h, g = Math.sin(u) * (o ? o / 2 : h), e.moveTo(n - d, r - a), e.lineTo(n + d, r + a), e.moveTo(n + g, r - s), e.lineTo(n - g, r + s), u += O, d = Math.cos(u) * (o ? o / 2 : h), s = Math.cos(u) * h, a = Math.sin(u) * h, g = Math.sin(u) * (o ? o / 2 : h), e.moveTo(n - d, r - a), e.lineTo(n + d, r + a), e.moveTo(n + g, r - s), e.lineTo(n - g, r + s);
        break;
      case "line":
        s = o ? o / 2 : Math.cos(u) * h, a = Math.sin(u) * h, e.moveTo(n - s, r - a), e.lineTo(n + s, r + a);
        break;
      case "dash":
        e.moveTo(n, r), e.lineTo(n + Math.cos(u) * (o ? o / 2 : h), r + Math.sin(u) * h);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function $t(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function Xt(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function Zt(e) {
  e.restore();
}
function Jt(e, t, n, r, o, i = {}) {
  const s = _(t) ? t : [
    t
  ], a = i.strokeWidth > 0 && i.strokeColor !== "";
  let c, l;
  for (e.save(), e.font = o.string, Le(e, i), c = 0; c < s.length; ++c)
    l = s[c], i.backdrop && He(e, i.backdrop), a && (i.strokeColor && (e.strokeStyle = i.strokeColor), v(i.strokeWidth) || (e.lineWidth = i.strokeWidth), e.strokeText(l, n, r, i.maxWidth)), e.fillText(l, n, r, i.maxWidth), Fe(e, n, r, l, i), r += o.lineHeight;
  e.restore();
}
function Le(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), v(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function Fe(e, t, n, r, o) {
  if (o.strikethrough || o.underline) {
    const i = e.measureText(r), s = t - i.actualBoundingBoxLeft, a = t + i.actualBoundingBoxRight, c = n - i.actualBoundingBoxAscent, l = n + i.actualBoundingBoxDescent, f = o.strikethrough ? (c + l) / 2 : l;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = o.decorationWidth || 2, e.moveTo(s, f), e.lineTo(a, f), e.stroke();
  }
}
function He(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function Vt(e, t) {
  const { x: n, y: r, w: o, h: i, radius: s } = t;
  e.arc(n + s.topLeft, r + s.topLeft, s.topLeft, -y, p, !0), e.lineTo(n, r + i - s.bottomLeft), e.arc(n + s.bottomLeft, r + i - s.bottomLeft, s.bottomLeft, p, y, !0), e.lineTo(n + o - s.bottomRight, r + i), e.arc(n + o - s.bottomRight, r + i - s.bottomRight, s.bottomRight, y, 0, !0), e.lineTo(n + o, r + s.topRight), e.arc(n + o - s.topRight, r + s.topRight, s.topRight, 0, -y, !0), e.lineTo(n + s.topLeft, r);
}
const Ne = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, ze = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function Ke(e, t) {
  const n = ("" + e).match(Ne);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const xe = (e) => +e || 0;
function ae(e, t) {
  const n = {}, r = b(t), o = r ? Object.keys(t) : t, i = b(e) ? r ? (s) => P(e[s], e[t[s]]) : (s) => e[s] : () => e;
  for (const s of o)
    n[s] = xe(i(s));
  return n;
}
function qe(e) {
  return ae(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function en(e) {
  return ae(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function tn(e) {
  const t = qe(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function nn(e, t) {
  e = e || {}, t = t || Be.font;
  let n = P(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let r = P(e.style, t.style);
  r && !("" + r).match(ze) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
  const o = {
    family: P(e.family, t.family),
    lineHeight: Ke(P(e.lineHeight, t.lineHeight), n),
    size: n,
    style: r,
    weight: P(e.weight, t.weight),
    string: ""
  };
  return o.string = De(o), o;
}
function rn(e, t, n, r) {
  let o = !0, i, s, a;
  for (i = 0, s = e.length; i < s; ++i)
    if (a = e[i], a !== void 0 && (t !== void 0 && typeof a == "function" && (a = a(t), o = !1), n !== void 0 && _(a) && (a = a[n % a.length], o = !1), a !== void 0))
      return r && !o && (r.cacheable = !1), a;
}
function on(e, t, n) {
  const { min: r, max: o } = e, i = he(t, (o - r) / 2), s = (a, c) => n && a === 0 ? 0 : a + c;
  return {
    min: s(r, -Math.abs(i)),
    max: s(o, i)
  };
}
function sn(e, t) {
  return Object.assign(Object.create(e), t);
}
function ce(e, t = [
  ""
], n = e, r, o = () => e[0]) {
  S(r) || (r = fe("_fallback", e));
  const i = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: n,
    _fallback: r,
    _getTarget: o,
    override: (s) => ce([
      s,
      ...e
    ], t, n, r)
  };
  return new Proxy(i, {
    deleteProperty(s, a) {
      return delete s[a], delete s._keys, delete e[0][a], !0;
    },
    get(s, a) {
      return le(s, a, () => Ve(a, t, e, s));
    },
    getOwnPropertyDescriptor(s, a) {
      return Reflect.getOwnPropertyDescriptor(s._scopes[0], a);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    has(s, a) {
      return Z(s).includes(a);
    },
    ownKeys(s) {
      return Z(s);
    },
    set(s, a, c) {
      const l = s._storage || (s._storage = o());
      return s[a] = l[a] = c, delete s._keys, !0;
    }
  });
}
function D(e, t, n, r) {
  const o = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Qe(e, r),
    setContext: (i) => D(e, i, n, r),
    override: (i) => D(e.override(i), t, n, r)
  };
  return new Proxy(o, {
    deleteProperty(i, s) {
      return delete i[s], delete e[s], !0;
    },
    get(i, s, a) {
      return le(i, s, () => Ge(i, s, a));
    },
    getOwnPropertyDescriptor(i, s) {
      return i._descriptors.allKeys ? Reflect.has(e, s) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, s);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    has(i, s) {
      return Reflect.has(e, s);
    },
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    set(i, s, a) {
      return e[s] = a, delete i[s], !0;
    }
  });
}
function Qe(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: o = t.allKeys } = e;
  return {
    allKeys: o,
    scriptable: n,
    indexable: r,
    isScriptable: W(n) ? n : () => n,
    isIndexable: W(r) ? r : () => r
  };
}
const Ue = (e, t) => e ? e + ne(t) : t, K = (e, t) => b(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function le(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t))
    return e[t];
  const r = n();
  return e[t] = r, r;
}
function Ge(e, t, n) {
  const { _proxy: r, _context: o, _subProxy: i, _descriptors: s } = e;
  let a = r[t];
  return W(a) && s.isScriptable(t) && (a = Ye(t, a, e, n)), _(a) && a.length && (a = $e(t, a, e, s.isIndexable)), K(t, a) && (a = D(a, o, i && i[t], s)), a;
}
function Ye(e, t, n, r) {
  const { _proxy: o, _context: i, _subProxy: s, _stack: a } = n;
  if (a.has(e))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e);
  return a.add(e), t = t(i, s || r), a.delete(e), K(e, t) && (t = x(o._scopes, o, e, t)), t;
}
function $e(e, t, n, r) {
  const { _proxy: o, _context: i, _subProxy: s, _descriptors: a } = n;
  if (S(i.index) && r(e))
    t = t[i.index % t.length];
  else if (b(t[0])) {
    const c = t, l = o._scopes.filter((f) => f !== c);
    t = [];
    for (const f of c) {
      const d = x(l, o, e, f);
      t.push(D(d, i, s && s[e], a));
    }
  }
  return t;
}
function ue(e, t, n) {
  return W(e) ? e(t, n) : e;
}
const Xe = (e, t) => e === !0 ? t : typeof e == "string" ? te(t, e) : void 0;
function Ze(e, t, n, r, o) {
  for (const i of t) {
    const s = Xe(n, i);
    if (s) {
      e.add(s);
      const a = ue(s._fallback, n, o);
      if (S(a) && a !== n && a !== r)
        return a;
    } else if (s === !1 && S(r) && n !== r)
      return null;
  }
  return !1;
}
function x(e, t, n, r) {
  const o = t._rootScopes, i = ue(t._fallback, n, r), s = [
    ...e,
    ...o
  ], a = /* @__PURE__ */ new Set();
  a.add(r);
  let c = X(a, s, n, i || n, r);
  return c === null || S(i) && i !== n && (c = X(a, s, i, c, r), c === null) ? !1 : ce(Array.from(a), [
    ""
  ], o, i, () => Je(t, n, r));
}
function X(e, t, n, r, o) {
  for (; n; )
    n = Ze(e, t, n, r, o);
  return n;
}
function Je(e, t, n) {
  const r = e._getTarget();
  t in r || (r[t] = {});
  const o = r[t];
  return _(o) && b(n) ? n : o || {};
}
function Ve(e, t, n, r) {
  let o;
  for (const i of t)
    if (o = fe(Ue(i, e), n), S(o))
      return K(e, o) ? x(n, r, e, o) : o;
}
function fe(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const r = n[e];
    if (S(r))
      return r;
  }
}
function Z(e) {
  let t = e._keys;
  return t || (t = e._keys = et(e._scopes)), t;
}
function et(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of Object.keys(n).filter((o) => !o.startsWith("_")))
      t.add(r);
  return Array.from(t);
}
function an(e, t, n, r) {
  const { iScale: o } = e, { key: i = "r" } = this._parsing, s = new Array(r);
  let a, c, l, f;
  for (a = 0, c = r; a < c; ++a)
    l = a + n, f = t[l], s[a] = {
      r: o.parse(te(f, i), l)
    };
  return s;
}
function cn() {
  return typeof window < "u" && typeof document < "u";
}
function tt(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function E(e, t, n) {
  let r;
  return typeof e == "string" ? (r = parseInt(e, 10), e.indexOf("%") !== -1 && (r = r / 100 * t.parentNode[n])) : r = e, r;
}
const L = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function nt(e, t) {
  return L(e).getPropertyValue(t);
}
const rt = [
  "top",
  "right",
  "bottom",
  "left"
];
function T(e, t, n) {
  const r = {};
  n = n ? "-" + n : "";
  for (let o = 0; o < 4; o++) {
    const i = rt[o];
    r[i] = parseFloat(e[t + "-" + i + n]) || 0;
  }
  return r.width = r.left + r.right, r.height = r.top + r.bottom, r;
}
const ot = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function it(e, t) {
  const n = e.touches, r = n && n.length ? n[0] : e, { offsetX: o, offsetY: i } = r;
  let s = !1, a, c;
  if (ot(o, i, e.target))
    a = o, c = i;
  else {
    const l = t.getBoundingClientRect();
    a = r.clientX - l.left, c = r.clientY - l.top, s = !0;
  }
  return {
    x: a,
    y: c,
    box: s
  };
}
function ln(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: r } = t, o = L(n), i = o.boxSizing === "border-box", s = T(o, "padding"), a = T(o, "border", "width"), { x: c, y: l, box: f } = it(e, n), d = s.left + (f && a.left), g = s.top + (f && a.top);
  let { width: m, height: R } = t;
  return i && (m -= s.width + a.width, R -= s.height + a.height), {
    x: Math.round((c - d) / m * n.width / r),
    y: Math.round((l - g) / R * n.height / r)
  };
}
function st(e, t, n) {
  let r, o;
  if (t === void 0 || n === void 0) {
    const i = tt(e);
    if (!i)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const s = i.getBoundingClientRect(), a = L(i), c = T(a, "border", "width"), l = T(a, "padding");
      t = s.width - l.width - c.width, n = s.height - l.height - c.height, r = E(a.maxWidth, i, "clientWidth"), o = E(a.maxHeight, i, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: r || B,
    maxHeight: o || B
  };
}
const I = (e) => Math.round(e * 10) / 10;
function un(e, t, n, r) {
  const o = L(e), i = T(o, "margin"), s = E(o.maxWidth, e, "clientWidth") || B, a = E(o.maxHeight, e, "clientHeight") || B, c = st(e, t, n);
  let { width: l, height: f } = c;
  if (o.boxSizing === "content-box") {
    const g = T(o, "border", "width"), m = T(o, "padding");
    l -= m.width + g.width, f -= m.height + g.height;
  }
  return l = Math.max(0, l - i.width), f = Math.max(0, r ? l / r : f - i.height), l = I(Math.min(l, s, c.maxWidth)), f = I(Math.min(f, a, c.maxHeight)), l && !f && (f = I(l / 2)), (t !== void 0 || n !== void 0) && r && c.height && f > c.height && (f = c.height, l = I(Math.floor(f * r))), {
    width: l,
    height: f
  };
}
function fn(e, t, n) {
  const r = t || 1, o = Math.floor(e.height * r), i = Math.floor(e.width * r);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const s = e.canvas;
  return s.style && (n || !s.style.height && !s.style.width) && (s.style.height = `${e.height}px`, s.style.width = `${e.width}px`), e.currentDevicePixelRatio !== r || s.height !== o || s.width !== i ? (e.currentDevicePixelRatio = r, s.height = o, s.width = i, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0) : !1;
}
const hn = function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    window.addEventListener("test", null, t), window.removeEventListener("test", null, t);
  } catch {
  }
  return e;
}();
function dn(e, t) {
  const n = nt(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/);
  return r ? +r[1] : void 0;
}
const at = function(e, t) {
  return {
    x(n) {
      return e + e + t - n;
    },
    setWidth(n) {
      t = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, r) {
      return n - r;
    },
    leftForLtr(n, r) {
      return n - r;
    }
  };
}, ct = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function gn(e, t, n) {
  return e ? at(t, n) : ct();
}
function mn(e, t) {
  let n, r;
  (t === "ltr" || t === "rtl") && (n = e.canvas.style, r = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", t, "important"), e.prevTextDirection = r);
}
function bn(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
export {
  Zt as $,
  Bt as A,
  Wt as B,
  $t as C,
  Ct as D,
  tn as E,
  mt as F,
  un as G,
  y as H,
  tt as I,
  dn as J,
  hn as K,
  Ht as L,
  cn as M,
  Ot as N,
  ht as O,
  p as P,
  gt as Q,
  on as R,
  Me as S,
  M as T,
  Rt as U,
  $ as V,
  jt as W,
  Ut as X,
  Xt as Y,
  Jt as Z,
  Ft as _,
  rn as a,
  nn as a0,
  zt as a1,
  Kt as a2,
  je as a3,
  A as a4,
  ne as a5,
  Ae as a6,
  W as a7,
  D as a8,
  ce as a9,
  mn as aA,
  xt as aB,
  bn as aC,
  Ee as aD,
  It as aE,
  ut as aF,
  Tt as aG,
  Mt as aH,
  Pt as aI,
  ye as aJ,
  kt as aK,
  Ie as aL,
  z as aM,
  Qt as aN,
  Dt as aO,
  re as aP,
  ie as aQ,
  H as aR,
  j as aS,
  de as aT,
  me as aU,
  be as aW,
  De as aX,
  nt as a_,
  Qe as aa,
  ge as ab,
  ft as ac,
  Nt as ad,
  fn as ae,
  Gt as af,
  pt as ag,
  bt as ah,
  _t as ai,
  At as aj,
  ae as ak,
  Yt as at,
  Vt as au,
  qe as av,
  en as aw,
  w as ay,
  gn as az,
  _ as b,
  Ke as b0,
  B as b2,
  _e as b3,
  O as b4,
  Q as b5,
  qt as c,
  Be as d,
  F as e,
  te as f,
  V as g,
  S as h,
  b as i,
  sn as j,
  v as k,
  Et as l,
  dt as m,
  he as n,
  ke as o,
  vt as p,
  Oe as r,
  yt as s,
  St as t,
  Lt as u,
  P as v,
  wt as x,
  an as y,
  ln as z
};
//# sourceMappingURL=helpers.segment.js.map

{"version":3,"file":"chart.js","sources":["../../../../../../node_modules/chart.js/dist/chart.js"],"sourcesContent":["/*!\n * Chart.js v4.1.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, i as isObject, d as defaults, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as defined, s as sign, j as createContext, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as getRelativePosition, A as _rlookupByKey, B as _lookupByKey, C as _isPointInArea, D as getAngleFromPoint, E as toPadding, F as each, G as getMaximumSize, I as _getParentNode, J as readUsedSize, K as supportsEventListenerOptions, L as throttled, M as _isDomSupported, N as _factorize, O as finiteOrDefault, Q as callback, R as _addGrace, S as _limitValue, U as toDegrees, V as _measureText, W as _int16Range, X as _alignPixel, Y as clipArea, Z as renderText, $ as unclipArea, a0 as toFont, a1 as _toLeftRightCenter, a2 as _alignStartEnd, a3 as overrides, a4 as merge, a5 as _capitalize, a6 as descriptors, a7 as isFunction, a8 as _attachContext, a9 as _createResolver, aa as _descriptors, ab as mergeIf, ac as uid, ad as debounce, ae as retinaScale, af as clearCanvas, ag as setsEqual, ah as _elementsEqual, ai as _isClickEvent, aj as _isBetween, ak as _readValueToProps, al as _updateBezierControlPoints, am as _computeSegments, an as _boundSegments, ao as _steppedInterpolation, ap as _bezierInterpolation, aq as _pointInLine, ar as _steppedLineTo, as as _bezierCurveTo, at as drawPoint, au as addRoundedRectPath, av as toTRBL, aw as toTRBLCorners, ax as _boundSegment, ay as _normalizeAngle, az as getRtlAdapter, aA as overrideTextDirection, aB as _textX, aC as restoreTextDirection, aD as drawPointLegend, aE as distanceBetweenPoints, aF as noop, aG as _setMinAndMaxByKey, aH as niceNum, aI as almostWhole, aJ as almostEquals, aK as _decimalPlaces, aL as Ticks, aM as log10, aN as _longestText, aO as _filterBetween, aP as _lookup } from './chunks/helpers.segment.js';\nexport { aL as Ticks, d as defaults } from './chunks/helpers.segment.js';\nimport '@kurkle/color';\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = color(from || transparent);\n        const c1 = c0.valid && color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = effects[cfg.easing] || effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data) {\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            x: key,\n            y: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (isObject(data)) {\n            this._data = convertObjectDataToArray(data);\n        } else if (_data !== data) {\n            if (_data) {\n                unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const skipNull = (meta)=>{\n            const parsed = meta.controller.getParsed(dataIndex);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(HALF_PI, startY, endY);\n        const minX = calcMin(PI, startX, endX);\n        const minY = calcMin(PI + HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing'\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = TAU;\n        let max = -TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (_angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height1 = chartArea.h * weight;\n            const width1 = stack.size || box.width;\n            if (defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);\n            }\n            stack.start = x;\n            stack.placed += height1;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = _getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    active = false;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return isNumber(this.x) && isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = _factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = valueOrDefault(majorStart, 0);\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = toFont(options.font, fallback);\n    const padding = toPadding(options.padding);\n    const lines = isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = _toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = _alignStartEnd(align, left, right);\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (isObject(position)) {\n            const positionAxisID1 = Object.keys(position)[0];\n            const value1 = position[positionAxisID1];\n            titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: finiteOrDefault(_userMin, _suggestedMin),\n            max: finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: isNumberFinite(_userMin),\n            maxDefined: isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = _addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = this.ticks.length;\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; ++i){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!isNullOrUndef(label) && !isArray(label)) {\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return _alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (isObject(position)) {\n                const positionAxisID1 = Object.keys(position)[0];\n                const value1 = position[positionAxisID1];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret1 = this._getYAxisLabelAlignment(tl);\n            textAlign = ret1.textAlign;\n            x = ret1.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID1 = Object.keys(position)[0];\n                const value1 = position[positionAxisID1];\n                x = this.chart.scales[positionAxisID1].getPixelForValue(value1);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = toFont(title.font);\n        const padding = toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\n            offset += padding.bottom;\n            if (isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in defaults[scope]) {\n            delete defaults[scope][id];\n            if (this.override) {\n                delete overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = merge(Object.create(null), [\n        parentScope ? defaults.get(parentScope) : {},\n        defaults.get(scope),\n        item.defaults\n    ]);\n    defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = _capitalize(method);\n        callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i1 = 0; i1 < local.length; i1++){\n        const plugin = local[i1];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, scaleOptions) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n    id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);\n    if (id) {\n        return id;\n    }\n    throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        mergeIf(scale, [\n            defaults.scales[scale.type],\n            defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            overrides[type] || {},\n            defaults.datasets[type] || {},\n            {\n                type\n            },\n            defaults,\n            descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = _attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = _createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.1.1\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (_isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nfunction getDatasetArea(meta) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: xScale.left,\n            right: xScale.right,\n            top: yScale.top,\n            bottom: yScale.bottom\n        };\n    }\n}\nclass Chart {\n    static defaults = defaults;\n    static instances = instances;\n    static overrides = overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1){\n            this._updateDataset(i1, isFunction(mode) ? mode({\n                datasetIndex: i1\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resize(width, height);\n            this._resizeBeforeDraw = null;\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = getDatasetArea(meta) || this.chartArea;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (useClip) {\n            clipArea(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return _isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = _isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return _readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = this.options.spacing / 2;\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n        const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierInterpolation;\n    }\n    return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = _boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { options: { elements  } , data: { datasets  }  } = chart.config;\n        if (!options.forceOverride && (containsColorsDefinitions(datasets) || elements && containsColorsDefinitions(elements))) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = _boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = _boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = _normalizeAngle(start);\n        end = _normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (_isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    if (target && line.points.length) {\n        clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    if (property === 'x' && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top , bottom  } = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x') {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox1 of hitboxes){\n                if (hitbox1.col !== col) {\n                    col = hitbox1.col;\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox1.top = top;\n                hitbox1.left += this.left + padding;\n                hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);\n                top += hitbox1.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            clipArea(ctx, this);\n            this._draw();\n            unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = defaults.color;\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = _alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\n        this._padding = toPadding(opts.padding);\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = _alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = _alignStartEnd(align, bottom, top);\n                rotation = PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = _alignStartEnd(align, top, bottom);\n                rotation = PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: _toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let x = 0;\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                x += pos.x;\n                y += pos.y;\n                ++count;\n            }\n        }\n        return {\n            x: x / count,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const titleFont = toFont(options.titleFont);\n    const footerFont = toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    each(body, (bodyItem)=>{\n        each(bodyItem.before, maxLineWidth);\n        each(bodyItem.lines, maxLineWidth);\n        each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: _limitValue(x, 0, chart.width - size.width),\n        y: _limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: noop,\n    beforeBody: noop,\n    beforeLabel: noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: noop,\n    afterBody: noop,\n    beforeFooter: noop,\n    footer: noop,\n    afterFooter: noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColors = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.fillStyle = labelColors.backgroundColor;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.setLineDash(labelColors.borderDash || []);\n            ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n            const borderRadius = toTRBLCorners(labelColors.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !isNullOrUndef(min);\n    const maxDefined = !isNullOrUndef(max);\n    const countDefined = !isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        ticks.push({\n            value: Math.round((niceMin + j * spacing) * factor) / factor\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = sign(min);\n            const maxSign = sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? min : 0;\n        this.max = isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = log10(start);\n        this._valueRange = log10(this.max) - log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = toPadding(tickOpts.backdropPadding);\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: _longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const extra = getTickBackdropHeight(opts) / 2;\n    const outerDistance = scale.drawingArea;\n    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n        const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n        const size = labelSizes[i];\n        const y = yForAngle(pointLabelPosition.y, size.h, angle);\n        const textAlign = getTextAlignForAngle(angle);\n        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n        items.push({\n            x: pointLabelPosition.x,\n            y,\n            textAlign,\n            left,\n            top: y,\n            right: left + size.w,\n            bottom: y + size.h\n        });\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        const plFont = toFont(optsAtIndex.font);\n        const { x , y , textAlign , left , top , right , bottom  } = scale._pointLabelItems[i];\n        const { backdropColor  } = optsAtIndex;\n        if (!isNullOrUndef(backdropColor)) {\n            const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\n            const padding = toPadding(optsAtIndex.backdropPadding);\n            ctx.fillStyle = backdropColor;\n            const backdropLeft = left - padding.left;\n            const backdropTop = top - padding.top;\n            const backdropWidth = right - left + padding.width;\n            const backdropHeight = bottom - top + padding.height;\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: backdropLeft,\n                    y: backdropTop,\n                    w: backdropWidth,\n                    h: backdropHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n            }\n        }\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = _lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = _filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = _limitValue(start, 0, limit);\n        end = _limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort((a, b)=>a - b).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return _arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, plugin_colors as Colors, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, elements, layouts, plugins, registerables, registry, scales };\n//# sourceMappingURL=chart.js.map\n"],"names":["Animator","chart","anims","date","type","callbacks","numSteps","fn","requestAnimFrame","remaining","items","i","draw","item","charts","event","cb","acc","cur","animator","transparent","interpolators","from","to","factor","c0","color","c1","Animation","cfg","target","prop","currentValue","resolve","effects","elapsed","remain","duration","loop","promises","res","rej","resolved","method","Animations","config","isObject","animationOptions","defaults","animatedProps","key","option","isArray","values","newOptions","options","resolveTargetOptions","animations","awaitAll","running","props","value","animation","properties","keys","anim","scaleClip","scale","allowedOverflow","opts","reverse","min","max","defaultClip","xScale","yScale","x","y","toClip","r","b","l","getSortedDatasetIndices","filterVisible","metasets","ilen","applyStack","stack","dsIndex","singleMode","datasetIndex","otherValue","isNumberFinite","sign","convertObjectDataToArray","data","adata","isStacked","meta","stacked","getStackKey","indexScale","valueScale","getUserBounds","minDefined","maxDefined","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","updateStacks","controller","parsed","iScale","iAxis","vAxis","index","itemStacks","visualValues","getFirstScaleId","axis","scales","createDatasetContext","parent","createContext","createDataContext","element","clearStacks","isDirectUpdateMode","mode","cloneIfNotShared","cached","shared","createStack","canStack","DatasetController","dataset","chooseId","xid","valueOrDefault","yid","rid","indexAxis","iid","vid","scaleID","unlistenArrayEvents","_data","listenArrayEvents","resetNewElements","stackChanged","oldStacked","scopeKeys","scopes","start","count","_stacked","sorted","prev","isNotInOrderComparedToPrev","labels","singleScale","xAxisKey","yAxisKey","resolveObjectKey","range","parsedValue","_parsed","otherScale","otherMin","otherMax","_skip","ctx","elements","area","active","drawActiveElementsOnTop","context","elementType","cache","cacheKey","sharing","defined","prefixes","names","transition","sharedOptions","firstOpts","previouslySharedOptions","includeOptions","arg1","arg2","numMeta","numData","end","move","arr","removed","args","newCount","__publicField","getAllScaleValues","visibleMetas","_arrayUnique","a","computeMinSampleSize","curr","updateMinAndPrev","computeFitCategoryTraits","ruler","stackCount","thickness","size","ratio","isNullOrUndef","computeFlexCategoryTraits","pixels","next","percent","parseFloatBar","entry","startValue","endValue","barStart","barEnd","parseValue","parseArrayOrPrimitive","isFloatBar","custom","barSign","actualBase","borderProps","top","bottom","setBorderSkipped","edge","parseEdge","swap","startEnd","orig","v1","v2","v","setInflateAmount","inflateAmount","BarController","iAxisKey","vAxisKey","obj","bars","reset","base","horizontal","vpixels","ipixels","last","dataIndex","skipNull","val","name","barThickness","baseValue","minBarLength","floating","length","head","startPixel","endPixel","halfGrid","maxBarThickness","center","stackIndex","rects","getRatioAndOffset","rotation","circumference","cutout","ratioX","ratioY","offsetX","offsetY","TAU","startAngle","endAngle","startX","startY","endX","endY","calcMax","angle","_angleBetween","calcMin","maxX","maxY","HALF_PI","minX","PI","minY","DoughnutController","getter","toRadians","chartArea","arcs","spacing","maxSize","toPercentage","chartWeight","maxWidth","maxHeight","maxRadius","outerRadius","toDimension","innerRadius","radiusLength","animationOpts","centerX","centerY","animateScale","arc","metaData","total","formatNumber","ringWeightOffset","pointStyle","label","style","e","legendItem","legend","PolarAreaController","_parseObjectDataRadialScale","minSize","datasetStartAngle","defaultAngle","abstract","DateAdapterBase","members","adapters","binarySearch","metaset","intersect","_sorted","lookupMethod","_rlookupByKey","_lookupByKey","el","evaluateInteractionItems","position","handler","lo","hi","j","getDistanceMetricForAxis","useX","useY","pt1","pt2","deltaX","deltaY","getIntersectItems","useFinalPosition","includeInvisible","_isPointInArea","getNearestRadialItems","evaluationFunc","getAngleFromPoint","getNearestCartesianItems","distanceMetric","minDistance","inRange","distance","getNearestItems","getAxisItems","rangeMethod","intersectsItem","Interaction","getRelativePosition","STATIC_POSITIONS","filterByPosition","array","filterDynamicPositionByAxis","sortByWeight","v0","wrapBoxes","boxes","layoutBoxes","box","pos","stackWeight","buildStacks","layouts","wrap","_stack","setLayoutDims","params","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","buildLayoutBoxes","left","right","centerHorizontal","centerVertical","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","handleMaxPadding","updatePos","change","getMargins","marginForPositions","positions","margin","fitBoxes","refitBoxes","refit","changed","same","other","setBoxDims","width","height","placeBoxes","userPadding","weight","height1","width1","layoutItem","minPadding","padding","toPadding","availableWidth","availableHeight","verticalBoxes","horizontalBoxes","each","visibleVerticalBoxCount","BasePlatform","canvas","aspectRatio","listener","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","initCanvas","renderHeight","renderWidth","displayWidth","readUsedSize","displayHeight","eventListenerOptions","supportsEventListenerOptions","addListener","node","removeListener","fromNativeEvent","nodeListContains","nodeList","createAttachObserver","observer","entries","trigger","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","resize","listenDevicePixelRatioChanges","unlistenDevicePixelRatioChanges","createResizeObserver","container","_getParentNode","throttled","w","releaseObserver","createProxyAndListen","proxy","DomPlatform","initial","proxies","getMaximumSize","_detectPlatform","_isDomSupported","Element","isNumber","final","ret","autoSkip","ticks","tickOpts","determinedMaxTicks","determineMaxTicks","ticksLimit","majorIndices","getMajorIndices","numMajorIndices","first","newTicks","skipMajors","calculateSpacing","avgMajorSpacing","skip","offset","tickLength","maxScale","maxChart","evenMajorSpacing","getEvenSpacing","factors","_factorize","result","majorStart","majorEnd","len","diff","reverseAlign","align","offsetFromEdge","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","epsilon","lineValue","garbageCollect","caches","gc","gcLen","getTickMarkLength","getTitleHeight","fallback","font","toFont","createScaleContext","createTickContext","tick","titleAlign","_toLeftRightCenter","titleArgs","titleX","titleY","_alignStartEnd","positionAxisID","positionAxisID1","value1","Scale","raw","_userMin","_userMax","_suggestedMin","_suggestedMax","finiteOrDefault","metas","callback","margins","beginAtZero","grace","sampleSize","_addGrace","samplingEnabled","reversePixels","numTicks","minRotation","maxRotation","labelRotation","tickWidth","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","_limitValue","toDegrees","titleOpts","gridOpts","display","isHorizontal","titleHeight","widest","highest","tickPadding","angleRadians","cos","sin","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetLeft","offsetRight","paddingLeft","paddingRight","paddingTop","paddingBottom","widths","heights","widestLabelSize","highestLabelSize","jlen","tickFont","fontString","lineHeight","nestedLabel","_measureText","valueAt","idx","pixel","decimal","_int16Range","_alignPixel","optionTicks","rot","h","grid","border","ticksLength","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","limit","step","optsAtIndex","optsAtIndexBorder","lineWidth","lineColor","borderDash","borderDashOffset","tickColor","tickBorderDash","tickBorderDashOffset","crossAlign","mirror","tickAndPadding","hTickAndPadding","textAlign","lineCount","textOffset","textBaseline","ret1","halfCount","strokeColor","strokeWidth","tickTextAlign","backdrop","labelPadding","backgroundColor","t","drawLine","p1","p2","lastLineWidth","clipArea","renderTextOptions","renderText","unclipArea","title","tz","gz","bz","axisID","fontSize","TypedRegistry","scope","override","proto","parentScope","isIChartComponent","id","registerDefaults","overrides","itemDefaults","merge","routeDefaults","routes","property","propertyParts","sourceName","sourceScope","parts","targetName","targetScope","Registry","typedRegistry","arg","reg","itemReg","registry","component","camelMethod","_capitalize","PluginService","hook","filter","descriptors","descriptor","plugin","all","plugins","allPlugins","createDescriptors","previousDescriptors","localIds","local","i1","getOpts","pluginOpts","getIndexAxis","datasetDefaults","getAxisFromDefaultScaleID","getDefaultScaleIDFromAxis","axisFromPosition","determineAxis","scaleOptions","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","defaultId","defaultScaleOptions","mergeIf","defaultID","initOptions","initData","initConfig","keyCache","keysCached","cachedKeys","generate","addIfFound","set","Config","datasetType","mainScope","resetCache","_scopeCache","keyLists","resolver","subPrefixes","getResolver","needContext","isFunction","subResolver","_attachContext","descriptorDefaults","resolverCache","_createResolver","p","hasFunction","isScriptable","isIndexable","_descriptors","scriptable","indexable","version","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","instances","getChart","c","moveNumericKeys","intKey","determineLastEvent","lastEvent","inChartArea","isClick","getDatasetArea","Chart","invalidatePlugins","userConfig","initialCanvas","existingChart","uid","debounce","maintainAspectRatio","_aspectRatio","retinaScale","clearCanvas","newSize","newRatio","scalesOptions","axisOptions","scaleOpts","updated","isRadial","scaleType","scaleClass","hasUpdated","datasets","newControllers","ControllerClass","datasetElementType","dataElementType","animsDisabled","_active","_lastEvent","existingEvents","newEvents","setsEqual","_hiddenIndices","changes","_dataChanges","datasetCount","makeSet","changeSet","noArea","ilen1","layers","clip","useClip","point","visible","listeners","platform","_add","_remove","detached","attached","enabled","prefix","activeElements","lastActive","_elementsEqual","pluginId","replay","hoverOptions","deactivated","activated","eventFilter","_isClickEvent","getBarBounds","bar","half","skipOrLimit","parseBorderWidth","maxW","maxH","o","toTRBL","parseBorderRadius","enableBorderRadius","toTRBLCorners","maxR","enableBorder","boundingRects","bounds","radius","skipX","skipY","_isBetween","hasRadius","addNormalRectPath","rect","inflateRect","amount","refRect","BarElement","borderColor","inner","outer","addRectPath","addRoundedRectPath","mouseX","mouseY","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","colorizeDefaultDataset","colorizeDoughnutDataset","colorizePolarAreaDataset","getColorizer","containsColorsDefinitions","k","plugin_colors","_args","colorizer","getBoxSize","labelOpts","boxHeight","boxWidth","itemsEqual","Legend","legendItems","labelFont","itemHeight","hitboxes","lineWidths","totalHeight","row","itemWidth","_itemHeight","columnSizes","heightLimit","totalWidth","currentColWidth","currentColHeight","col","calculateItemSize","rtl","rtlHelper","getRtlAdapter","hitbox","hitbox1","defaultColor","halfFontSize","cursor","drawLegendBox","drawOptions","drawPointLegend","yBoxTop","xBoxLeft","borderRadius","fillText","overrideTextDirection","textWidth","realX","_textX","fontLineHeight","calculateLegendItemHeight","restoreTextDirection","titleFont","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","hoveredItem","previous","sameItem","calculateItemWidth","calculateItemHeight","legendItemText","plugin_legend","ci","usePointStyle","useBorderRadius","borderWidth","Title","textSize","fontOpts","createTitle","plugin_title","titleBlock","map","plugin_subtitle","positioners","eventPosition","nearestElement","d","distanceBetweenPoints","tp","pushOrConcat","toPush","splitNewlines","str","createTooltipItem","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","bodyLineHeight","widthPadding","maxLineWidth","line","determineYAlign","doesNotFitWithAlign","xAlign","caret","determineXAlign","yAlign","chartWidth","determineAlignment","alignX","alignY","paddingAndSize","getBackgroundPoint","alignment","caretSize","caretPadding","cornerRadius","topLeft","topRight","bottomLeft","bottomRight","getAlignedX","getBeforeAfterBodyLines","createTooltipContext","tooltipItems","overrideCallbacks","defaultCallbacks","noop","labelCount","tooltipItem","invokeCallbackWithFallback","Tooltip","beforeTitle","afterTitle","lines","bodyItems","scoped","beforeFooter","afterFooter","labelColors","labelPointStyles","labelTextColors","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","x3","y3","pt","titleSpacing","labelPointStyle","colorX","rtlColorX","yOffSet","colorY","drawPoint","outerX","innerX","bodySpacing","bodyAlign","displayColors","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","opacity","hasTooltipContent","positionChanged","caretX","caretY","plugin_tooltip","addIfString","addedLabels","findOrAddLabel","_getLabelForValue","CategoryScale","added","generateTicks$1","generationOptions","dataRange","precision","maxTicks","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","minSpacing","niceNum","niceMin","niceMax","numSpaces","almostWhole","almostEquals","decimalPlaces","_decimalPlaces","relativeLabelSize","rad","LinearScaleBase","setMin","setMax","minSign","maxSign","maxTicksLimit","stepSize","numericGeneratorOptions","_setMinAndMaxByKey","LinearScale","Ticks","log10Floor","log10","changeExponent","m","isMajor","tickVal","steps","rangeExp","rangeStep","startExp","generateTicks","minExp","exp","significand","lastTick","LogarithmicScale","getTickBackdropHeight","measureLabelSize","_longestText","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","additionalAngle","pointPosition","plFont","_normalizeAngle","hLimits","vLimits","updateLimits","buildPointLabelItems","extra","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabels","pointLabels","backdropColor","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","circular","drawRadiusLine","gridLineOpts","createPointLabelContext","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","angleMultiplier","scalingFactor","scaledDistance","pointLabel","distanceFromCenter","angleLines","INTERVALS","UNITS","sorter","parse","input","adapter","parser","round","isoWeekday","determineUnitForAutoTicks","minUnit","capacity","interval","determineUnitForFormatting","determineMajorUnit","addTick","time","timestamps","_lookup","timestamp","setMajorTicks","majorUnit","major","ticksFromTimestamps","TimeScale","_applyBounds","timeOpts","_filterBetween","minor","weekday","hasWeekday","format","formatter","formats","minorFormat","majorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","displayFormats","exampleLabel","interpolate","table","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale"],"mappings":"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"}
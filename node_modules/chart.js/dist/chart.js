var bs = Object.defineProperty;
var _s = (o, t, e) => t in o ? bs(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var S = (o, t, e) => (_s(o, typeof t != "symbol" ? t + "" : t, e), e);
import { f as kt, k as z, s as nt, v as T, K as ys, d as F, a3 as wt, ac as vs, ad as ks, ae as Ve, af as He, Q as O, F as C, ag as We, a7 as de, Y as Oe, $ as Te, C as Yi, j as mt, h as Bt, ah as oe, ai as ws, au as Vt, E as N, aL as ze, g as H, t as q, aG as Xi, o as ue, aM as Rt, T as dt, ay as Re, H as Mt, a0 as I, Z as gt, u as Ne, i as E, l as Ms, b as X, M as Ki, x as ae, O as Y, R as Ss, S as Q, U as Fe, V as je, W as Ds, X as at, a6 as $e, a8 as Ue, a9 as Ps, aa as Cs, aj as yt, az as vt, a2 as V, aA as qi, aB as Ls, aC as Gi, a1 as Ee, aE as As, aF as tt, aw as ut, at as Ye, P as pt, r as Os, _ as Ji, z as ht, G as Ts, I as Zi, a5 as zs, av as Rs, aD as Fs, aH as Xe, aI as Es, aJ as ge, aN as Is, ab as ee, aO as Bs, B as Se, a as Yt, e as Ke, m as Vs, n as Hs, y as Ws, J as qe, N as Ns, a4 as js, aK as Ge, aP as $s, c as Je, A as Us, p as De, D as Ys, L as Qi } from "./chunks/helpers.segment.js";
import { aL as Da, d as Pa } from "./chunks/helpers.segment.js";
/*!
 * Chart.js v4.1.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
class Xs {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, e, i, s) {
    const n = e.listeners[s], a = e.duration;
    n.forEach((r) => r({
      chart: t,
      initial: e.initial,
      numSteps: a,
      currentStep: Math.min(i - e.start, a)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Os.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let e = 0;
    this._charts.forEach((i, s) => {
      if (!i.running || !i.items.length)
        return;
      const n = i.items;
      let a = n.length - 1, r = !1, l;
      for (; a >= 0; --a)
        l = n[a], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());
      r && (s.draw(), this._notify(s, i, t, "progress")), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length;
    }), this._lastDate = t, e === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const e = this._charts;
    let i = e.get(t);
    return i || (i = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, e.set(t, i)), i;
  }
  listen(t, e, i) {
    this._getAnims(t).listeners[e].push(i);
  }
  add(t, e) {
    !e || !e.length || this._getAnims(t).items.push(...e);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const e = this._charts.get(t);
    !e || (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((i, s) => Math.max(i, s._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const e = this._charts.get(t);
    return !(!e || !e.running || !e.items.length);
  }
  stop(t) {
    const e = this._charts.get(t);
    if (!e || !e.items.length)
      return;
    const i = e.items;
    let s = i.length - 1;
    for (; s >= 0; --s)
      i[s].cancel();
    e.items = [], this._notify(t, e, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var et = /* @__PURE__ */ new Xs();
const Ze = "transparent", Ks = {
  boolean(o, t, e) {
    return e > 0.5 ? t : o;
  },
  color(o, t, e) {
    const i = Je(o || Ze), s = i.valid && Je(t || Ze);
    return s && s.valid ? s.mix(i, e).hexString() : t;
  },
  number(o, t, e) {
    return o + (t - o) * e;
  }
};
class qs {
  constructor(t, e, i, s) {
    const n = e[i];
    s = Yt([
      t.to,
      s,
      n,
      t.from
    ]);
    const a = Yt([
      t.from,
      n,
      s
    ]);
    this._active = !0, this._fn = t.fn || Ks[t.type || typeof a], this._easing = Ke[t.easing] || Ke.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = a, this._to = s, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, e, i) {
    if (this._active) {
      this._notify(!1);
      const s = this._target[this._prop], n = i - this._start, a = this._duration - n;
      this._start = i, this._duration = Math.floor(Math.max(a, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Yt([
        t.to,
        e,
        s,
        t.from
      ]), this._from = Yt([
        t.from,
        s,
        e
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const e = t - this._start, i = this._duration, s = this._prop, n = this._from, a = this._loop, r = this._to;
    let l;
    if (this._active = n !== r && (a || e < i), !this._active) {
      this._target[s] = r, this._notify(!0);
      return;
    }
    if (e < 0) {
      this._target[s] = n;
      return;
    }
    l = e / i % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(n, r, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((e, i) => {
      t.push({
        res: e,
        rej: i
      });
    });
  }
  _notify(t) {
    const e = t ? "res" : "rej", i = this._promises || [];
    for (let s = 0; s < i.length; s++)
      i[s][e]();
  }
}
class ts {
  constructor(t, e) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);
  }
  configure(t) {
    if (!E(t))
      return;
    const e = Object.keys(F.animation), i = this._properties;
    Object.getOwnPropertyNames(t).forEach((s) => {
      const n = t[s];
      if (!E(n))
        return;
      const a = {};
      for (const r of e)
        a[r] = n[r];
      (X(n.properties) && n.properties || [
        s
      ]).forEach((r) => {
        (r === s || !i.has(r)) && i.set(r, a);
      });
    });
  }
  _animateOptions(t, e) {
    const i = e.options, s = Js(t, i);
    if (!s)
      return [];
    const n = this._createAnimations(s, i);
    return i.$shared && Gs(t.options.$animations, i).then(() => {
      t.options = i;
    }, () => {
    }), n;
  }
  _createAnimations(t, e) {
    const i = this._properties, s = [], n = t.$animations || (t.$animations = {}), a = Object.keys(e), r = Date.now();
    let l;
    for (l = a.length - 1; l >= 0; --l) {
      const h = a[l];
      if (h.charAt(0) === "$")
        continue;
      if (h === "options") {
        s.push(...this._animateOptions(t, e));
        continue;
      }
      const c = e[h];
      let d = n[h];
      const u = i.get(h);
      if (d)
        if (u && d.active()) {
          d.update(u, c, r);
          continue;
        } else
          d.cancel();
      if (!u || !u.duration) {
        t[h] = c;
        continue;
      }
      n[h] = d = new qs(u, t, h, c), s.push(d);
    }
    return s;
  }
  update(t, e) {
    if (this._properties.size === 0) {
      Object.assign(t, e);
      return;
    }
    const i = this._createAnimations(t, e);
    if (i.length)
      return et.add(this._chart, i), !0;
  }
}
function Gs(o, t) {
  const e = [], i = Object.keys(t);
  for (let s = 0; s < i.length; s++) {
    const n = o[i[s]];
    n && n.active() && e.push(n.wait());
  }
  return Promise.all(e);
}
function Js(o, t) {
  if (!t)
    return;
  let e = o.options;
  if (!e) {
    o.options = t;
    return;
  }
  return e.$shared && (o.options = e = Object.assign({}, e, {
    $shared: !1,
    $animations: {}
  })), e;
}
function Qe(o, t) {
  const e = o && o.options || {}, i = e.reverse, s = e.min === void 0 ? t : 0, n = e.max === void 0 ? t : 0;
  return {
    start: i ? n : s,
    end: i ? s : n
  };
}
function Zs(o, t, e) {
  if (e === !1)
    return !1;
  const i = Qe(o, e), s = Qe(t, e);
  return {
    top: s.end,
    right: i.end,
    bottom: s.start,
    left: i.start
  };
}
function Qs(o) {
  let t, e, i, s;
  return E(o) ? (t = o.top, e = o.right, i = o.bottom, s = o.left) : t = e = i = s = o, {
    top: t,
    right: e,
    bottom: i,
    left: s,
    disabled: o === !1
  };
}
function es(o, t) {
  const e = [], i = o._getSortedDatasetMetas(t);
  let s, n;
  for (s = 0, n = i.length; s < n; ++s)
    e.push(i[s].index);
  return e;
}
function ti(o, t, e, i = {}) {
  const s = o.keys, n = i.mode === "single";
  let a, r, l, h;
  if (t !== null) {
    for (a = 0, r = s.length; a < r; ++a) {
      if (l = +s[a], l === e) {
        if (i.all)
          continue;
        break;
      }
      h = o.values[l], H(h) && (n || t === 0 || nt(t) === nt(h)) && (t += h);
    }
    return t;
  }
}
function tn(o) {
  const t = Object.keys(o), e = new Array(t.length);
  let i, s, n;
  for (i = 0, s = t.length; i < s; ++i)
    n = t[i], e[i] = {
      x: n,
      y: o[n]
    };
  return e;
}
function ei(o, t) {
  const e = o && o.options.stacked;
  return e || e === void 0 && t.stack !== void 0;
}
function en(o, t, e) {
  return `${o.id}.${t.id}.${e.stack || e.type}`;
}
function sn(o) {
  const { min: t, max: e, minDefined: i, maxDefined: s } = o.getUserBounds();
  return {
    min: i ? t : Number.NEGATIVE_INFINITY,
    max: s ? e : Number.POSITIVE_INFINITY
  };
}
function nn(o, t, e) {
  const i = o[t] || (o[t] = {});
  return i[e] || (i[e] = {});
}
function ii(o, t, e, i) {
  for (const s of t.getMatchingVisibleMetas(i).reverse()) {
    const n = o[s.index];
    if (e && n > 0 || !e && n < 0)
      return s.index;
  }
  return null;
}
function si(o, t) {
  const { chart: e, _cachedMeta: i } = o, s = e._stacks || (e._stacks = {}), { iScale: n, vScale: a, index: r } = i, l = n.axis, h = a.axis, c = en(n, a, i), d = t.length;
  let u;
  for (let f = 0; f < d; ++f) {
    const g = t[f], { [l]: p, [h]: x } = g, m = g._stacks || (g._stacks = {});
    u = m[h] = nn(s, c, p), u[r] = x, u._top = ii(u, a, !0, i.type), u._bottom = ii(u, a, !1, i.type);
    const b = u._visualValues || (u._visualValues = {});
    b[r] = x;
  }
}
function pe(o, t) {
  const e = o.scales;
  return Object.keys(e).filter((i) => e[i].axis === t).shift();
}
function on(o, t) {
  return mt(o, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function an(o, t, e) {
  return mt(o, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: e,
    index: t,
    mode: "default",
    type: "data"
  });
}
function Lt(o, t) {
  const e = o.controller.index, i = o.vScale && o.vScale.axis;
  if (!!i) {
    t = t || o._parsed;
    for (const s of t) {
      const n = s._stacks;
      if (!n || n[i] === void 0 || n[i][e] === void 0)
        return;
      delete n[i][e], n[i]._visualValues !== void 0 && n[i]._visualValues[e] !== void 0 && delete n[i]._visualValues[e];
    }
  }
}
const me = (o) => o === "reset" || o === "none", ni = (o, t) => t ? o : Object.assign({}, o), rn = (o, t, e) => o && !t.hidden && t._stacked && {
  keys: es(e, !0),
  values: null
};
class ft {
  constructor(t, e) {
    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = ei(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && Lt(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (d, u, f, g) => d === "x" ? u : d === "r" ? g : f, n = e.xAxisID = T(i.xAxisID, pe(t, "x")), a = e.yAxisID = T(i.yAxisID, pe(t, "y")), r = e.rAxisID = T(i.rAxisID, pe(t, "r")), l = e.indexAxis, h = e.iAxisID = s(l, n, a, r), c = e.vAxisID = s(l, a, n, r);
    e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(a), e.rScale = this.getScaleForId(r), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const e = this._cachedMeta;
    return t === e.iScale ? e.vScale : e.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Ne(this._data, this), t._stacked && Lt(t);
  }
  _dataCheck() {
    const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;
    if (E(e))
      this._data = tn(e);
    else if (i !== e) {
      if (i) {
        Ne(i, this);
        const s = this._cachedMeta;
        Lt(s), s._parsed = [];
      }
      e && Object.isExtensible(e) && Ms(e, this), this._syncList = [], this._data = e;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const e = this._cachedMeta, i = this.getDataset();
    let s = !1;
    this._dataCheck();
    const n = e._stacked;
    e._stacked = ei(e.vScale, e), e.stack !== i.stack && (s = !0, Lt(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && si(this, e._parsed);
  }
  configure() {
    const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0);
    this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, e) {
    const { _cachedMeta: i, _data: s } = this, { iScale: n, _stacked: a } = i, r = n.axis;
    let l = t === 0 && e === s.length ? !0 : i._sorted, h = t > 0 && i._parsed[t - 1], c, d, u;
    if (this._parsing === !1)
      i._parsed = s, i._sorted = !0, u = s;
    else {
      X(s[t]) ? u = this.parseArrayData(i, s, t, e) : E(s[t]) ? u = this.parseObjectData(i, s, t, e) : u = this.parsePrimitiveData(i, s, t, e);
      const f = () => d[r] === null || h && d[r] < h[r];
      for (c = 0; c < e; ++c)
        i._parsed[c + t] = d = u[c], l && (f() && (l = !1), h = d);
      i._sorted = l;
    }
    a && si(this, u);
  }
  parsePrimitiveData(t, e, i, s) {
    const { iScale: n, vScale: a } = t, r = n.axis, l = a.axis, h = n.getLabels(), c = n === a, d = new Array(s);
    let u, f, g;
    for (u = 0, f = s; u < f; ++u)
      g = u + i, d[u] = {
        [r]: c || n.parse(h[g], g),
        [l]: a.parse(e[g], g)
      };
    return d;
  }
  parseArrayData(t, e, i, s) {
    const { xScale: n, yScale: a } = t, r = new Array(s);
    let l, h, c, d;
    for (l = 0, h = s; l < h; ++l)
      c = l + i, d = e[c], r[l] = {
        x: n.parse(d[0], c),
        y: a.parse(d[1], c)
      };
    return r;
  }
  parseObjectData(t, e, i, s) {
    const { xScale: n, yScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, h = new Array(s);
    let c, d, u, f;
    for (c = 0, d = s; c < d; ++c)
      u = c + i, f = e[u], h[c] = {
        x: n.parse(kt(f, r), u),
        y: a.parse(kt(f, l), u)
      };
    return h;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, e, i) {
    const s = this.chart, n = this._cachedMeta, a = e[t.axis], r = {
      keys: es(s, !0),
      values: e._stacks[t.axis]._visualValues
    };
    return ti(r, a, n.index, {
      mode: i
    });
  }
  updateRangeFromParsed(t, e, i, s) {
    const n = i[e.axis];
    let a = n === null ? NaN : n;
    const r = s && i._stacks[e.axis];
    s && r && (s.values = r, a = ti(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a);
  }
  getMinMax(t, e) {
    const i = this._cachedMeta, s = i._parsed, n = i._sorted && t === i.iScale, a = s.length, r = this._getOtherScale(t), l = rn(e, i, this.chart), h = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: d } = sn(r);
    let u, f;
    function g() {
      f = s[u];
      const p = f[r.axis];
      return !H(f[t.axis]) || c > p || d < p;
    }
    for (u = 0; u < a && !(!g() && (this.updateRangeFromParsed(h, t, f, l), n)); ++u)
      ;
    if (n) {
      for (u = a - 1; u >= 0; --u)
        if (!g()) {
          this.updateRangeFromParsed(h, t, f, l);
          break;
        }
    }
    return h;
  }
  getAllParsedValues(t) {
    const e = this._cachedMeta._parsed, i = [];
    let s, n, a;
    for (s = 0, n = e.length; s < n; ++s)
      a = e[s][t.axis], H(a) && i.push(a);
    return i;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, i = e.iScale, s = e.vScale, n = this.getParsed(t);
    return {
      label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
      value: s ? "" + s.getLabelForValue(n[s.axis]) : ""
    };
  }
  _update(t) {
    const e = this._cachedMeta;
    this.update(t || "default"), e._clip = Qs(T(this.options.clip, Zs(e.xScale, e.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], n = e.chartArea, a = [], r = this._drawStart || 0, l = this._drawCount || s.length - r, h = this.options.drawActiveElementsOnTop;
    let c;
    for (i.dataset && i.dataset.draw(t, n, r, l), c = r; c < r + l; ++c) {
      const d = s[c];
      d.hidden || (d.active && h ? a.push(d) : d.draw(t, n));
    }
    for (c = 0; c < a.length; ++c)
      a[c].draw(t, n);
  }
  getStyle(t, e) {
    const i = e ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);
  }
  getContext(t, e, i) {
    const s = this.getDataset();
    let n;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const a = this._cachedMeta.data[t];
      n = a.$context || (a.$context = an(this.getContext(), t, a)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;
    } else
      n = this.$context || (this.$context = on(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;
    return n.active = !!e, n.mode = i, n;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, e) {
    return this._resolveElementOptions(this.dataElementType.id, e, t);
  }
  _resolveElementOptions(t, e = "default", i) {
    const s = e === "active", n = this._cachedDataOpts, a = t + "-" + e, r = n[a], l = this.enableOptionSharing && Bt(i);
    if (r)
      return ni(r, l);
    const h = this.chart.config, c = h.datasetElementScopeKeys(this._type, t), d = s ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], u = h.getOptionScopes(this.getDataset(), c), f = Object.keys(F.elements[t]), g = () => this.getContext(i, s, e), p = h.resolveNamedOptions(u, f, g, d);
    return p.$shared && (p.$shared = l, n[a] = Object.freeze(ni(p, l))), p;
  }
  _resolveAnimations(t, e, i) {
    const s = this.chart, n = this._cachedDataOpts, a = `animation-${e}`, r = n[a];
    if (r)
      return r;
    let l;
    if (s.options.animation !== !1) {
      const c = this.chart.config, d = c.datasetAnimationScopeKeys(this._type, e), u = c.getOptionScopes(this.getDataset(), d);
      l = c.createResolver(u, this.getContext(t, i, e));
    }
    const h = new ts(s, l && l.animations);
    return l && l._cacheable && (n[a] = Object.freeze(h)), h;
  }
  getSharedOptions(t) {
    if (!!t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, e) {
    return !e || me(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, e) {
    const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, n = this.getSharedOptions(i), a = this.includeOptions(e, n) || n !== s;
    return this.updateSharedOptions(n, e, i), {
      sharedOptions: n,
      includeOptions: a
    };
  }
  updateElement(t, e, i, s) {
    me(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);
  }
  updateSharedOptions(t, e, i) {
    t && !me(e) && this._resolveAnimations(void 0, e).update(t, i);
  }
  _setStyle(t, e, i, s) {
    t.active = s;
    const n = this.getStyle(e, s);
    this._resolveAnimations(e, i, s).update(t, {
      options: !s && this.getSharedOptions(n) || n
    });
  }
  removeHoverStyle(t, e, i) {
    this._setStyle(t, i, "active", !1);
  }
  setHoverStyle(t, e, i) {
    this._setStyle(t, i, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const e = this._data, i = this._cachedMeta.data;
    for (const [r, l, h] of this._syncList)
      this[r](l, h);
    this._syncList = [];
    const s = i.length, n = e.length, a = Math.min(n, s);
    a && this.parse(0, a), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);
  }
  _insertElements(t, e, i = !0) {
    const s = this._cachedMeta, n = s.data, a = t + e;
    let r;
    const l = (h) => {
      for (h.length += e, r = h.length - 1; r >= a; r--)
        h[r] = h[r - e];
    };
    for (l(n), r = t; r < a; ++r)
      n[r] = new this.dataElementType();
    this._parsing && l(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, "reset");
  }
  updateElements(t, e, i, s) {
  }
  _removeElements(t, e) {
    const i = this._cachedMeta;
    if (this._parsing) {
      const s = i._parsed.splice(t, e);
      i._stacked && Lt(i, s);
    }
    i.data.splice(t, e);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [e, i, s] = t;
      this[e](i, s);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, e) {
    e && this._sync([
      "_removeElements",
      t,
      e
    ]);
    const i = arguments.length - 2;
    i && this._sync([
      "_insertElements",
      t,
      i
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
S(ft, "defaults", {}), S(ft, "datasetElementType", null), S(ft, "dataElementType", null);
function ln(o, t) {
  if (!o._cache.$bar) {
    const e = o.getMatchingVisibleMetas(t);
    let i = [];
    for (let s = 0, n = e.length; s < n; s++)
      i = i.concat(e[s].controller.getAllParsedValues(o));
    o._cache.$bar = Ji(i.sort((s, n) => s - n));
  }
  return o._cache.$bar;
}
function hn(o) {
  const t = o.iScale, e = ln(t, o.type);
  let i = t._length, s, n, a, r;
  const l = () => {
    a === 32767 || a === -32768 || (Bt(r) && (i = Math.min(i, Math.abs(a - r) || i)), r = a);
  };
  for (s = 0, n = e.length; s < n; ++s)
    a = t.getPixelForValue(e[s]), l();
  for (r = void 0, s = 0, n = t.ticks.length; s < n; ++s)
    a = t.getPixelForTick(s), l();
  return i;
}
function cn(o, t, e, i) {
  const s = e.barThickness;
  let n, a;
  return z(s) ? (n = t.min * e.categoryPercentage, a = e.barPercentage) : (n = s * i, a = 1), {
    chunk: n / i,
    ratio: a,
    start: t.pixels[o] - n / 2
  };
}
function dn(o, t, e, i) {
  const s = t.pixels, n = s[o];
  let a = o > 0 ? s[o - 1] : null, r = o < s.length - 1 ? s[o + 1] : null;
  const l = e.categoryPercentage;
  a === null && (a = n - (r === null ? t.end - t.start : r - n)), r === null && (r = n + n - a);
  const h = n - (n - Math.min(a, r)) / 2 * l;
  return {
    chunk: Math.abs(r - a) / 2 * l / i,
    ratio: e.barPercentage,
    start: h
  };
}
function un(o, t, e, i) {
  const s = e.parse(o[0], i), n = e.parse(o[1], i), a = Math.min(s, n), r = Math.max(s, n);
  let l = a, h = r;
  Math.abs(a) > Math.abs(r) && (l = r, h = a), t[e.axis] = h, t._custom = {
    barStart: l,
    barEnd: h,
    start: s,
    end: n,
    min: a,
    max: r
  };
}
function is(o, t, e, i) {
  return X(o) ? un(o, t, e, i) : t[e.axis] = e.parse(o, i), t;
}
function oi(o, t, e, i) {
  const s = o.iScale, n = o.vScale, a = s.getLabels(), r = s === n, l = [];
  let h, c, d, u;
  for (h = e, c = e + i; h < c; ++h)
    u = t[h], d = {}, d[s.axis] = r || s.parse(a[h], h), l.push(is(u, d, n, h));
  return l;
}
function xe(o) {
  return o && o.barStart !== void 0 && o.barEnd !== void 0;
}
function fn(o, t, e) {
  return o !== 0 ? nt(o) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);
}
function gn(o) {
  let t, e, i, s, n;
  return o.horizontal ? (t = o.base > o.x, e = "left", i = "right") : (t = o.base < o.y, e = "bottom", i = "top"), t ? (s = "end", n = "start") : (s = "start", n = "end"), {
    start: e,
    end: i,
    reverse: t,
    top: s,
    bottom: n
  };
}
function pn(o, t, e, i) {
  let s = t.borderSkipped;
  const n = {};
  if (!s) {
    o.borderSkipped = n;
    return;
  }
  if (s === !0) {
    o.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: a, end: r, reverse: l, top: h, bottom: c } = gn(o);
  s === "middle" && e && (o.enableBorderRadius = !0, (e._top || 0) === i ? s = h : (e._bottom || 0) === i ? s = c : (n[ai(c, a, r, l)] = !0, s = h)), n[ai(s, a, r, l)] = !0, o.borderSkipped = n;
}
function ai(o, t, e, i) {
  return i ? (o = mn(o, t, e), o = ri(o, e, t)) : o = ri(o, t, e), o;
}
function mn(o, t, e) {
  return o === t ? e : o === e ? t : o;
}
function ri(o, t, e) {
  return o === "start" ? t : o === "end" ? e : o;
}
function xn(o, { inflateAmount: t }, e) {
  o.inflateAmount = t === "auto" ? e === 1 ? 0.33 : 0 : t;
}
class be extends ft {
  parsePrimitiveData(t, e, i, s) {
    return oi(t, e, i, s);
  }
  parseArrayData(t, e, i, s) {
    return oi(t, e, i, s);
  }
  parseObjectData(t, e, i, s) {
    const { iScale: n, vScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, h = n.axis === "x" ? r : l, c = a.axis === "x" ? r : l, d = [];
    let u, f, g, p;
    for (u = i, f = i + s; u < f; ++u)
      p = e[u], g = {}, g[n.axis] = n.parse(kt(p, h), u), d.push(is(kt(p, c), g, a, u));
    return d;
  }
  updateRangeFromParsed(t, e, i, s) {
    super.updateRangeFromParsed(t, e, i, s);
    const n = i._custom;
    n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), a = n._custom, r = xe(a) ? "[" + a.start + ", " + a.end + "]" : "" + s.getLabelForValue(n[s.axis]);
    return {
      label: "" + i.getLabelForValue(n[i.axis]),
      value: r
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const e = this._cachedMeta;
    this.updateElements(e.data, 0, e.data.length, t);
  }
  updateElements(t, e, i, s) {
    const n = s === "reset", { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, s);
    for (let f = e; f < e + i; f++) {
      const g = this.getParsed(f), p = n || z(g[r.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), x = this._calculateBarIndexPixels(f, c), m = (g._stacks || {})[r.axis], b = {
        horizontal: h,
        base: p.base,
        enableBorderRadius: !m || xe(g._custom) || a === m._top || a === m._bottom,
        x: h ? p.head : x.center,
        y: h ? x.center : p.head,
        height: h ? x.size : Math.abs(p.size),
        width: h ? Math.abs(p.size) : x.size
      };
      u && (b.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : s));
      const _ = b.options || t[f].options;
      pn(b, _, m, a), xn(b, _, c.ratio), this.updateElement(t[f], f, b, s);
    }
  }
  _getStacks(t, e) {
    const { iScale: i } = this._cachedMeta, s = i.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), n = i.options.stacked, a = [], r = (l) => {
      const h = l.controller.getParsed(e), c = h && h[l.vScale.axis];
      if (z(c) || isNaN(c))
        return !0;
    };
    for (const l of s)
      if (!(e !== void 0 && r(l)) && ((n === !1 || a.indexOf(l.stack) === -1 || n === void 0 && l.stack === void 0) && a.push(l.stack), l.index === t))
        break;
    return a.length || a.push(void 0), a;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getStackIndex(t, e, i) {
    const s = this._getStacks(t, i), n = e !== void 0 ? s.indexOf(e) : -1;
    return n === -1 ? s.length - 1 : n;
  }
  _getRuler() {
    const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];
    let n, a;
    for (n = 0, a = e.data.length; n < a; ++n)
      s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
    const r = t.barThickness;
    return {
      min: r || hn(e),
      pixels: s,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: this._getStackCount(),
      scale: i,
      grouped: t.grouped,
      ratio: r ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: e, _stacked: i, index: s }, options: { base: n, minBarLength: a } } = this, r = n || 0, l = this.getParsed(t), h = l._custom, c = xe(h);
    let d = l[e.axis], u = 0, f = i ? this.applyStack(e, l, i) : d, g, p;
    f !== d && (u = f - d, f = d), c && (d = h.barStart, f = h.barEnd - h.barStart, d !== 0 && nt(d) !== nt(h.barEnd) && (u = 0), u += d);
    const x = !z(n) && !c ? n : u;
    let m = e.getPixelForValue(x);
    if (this.chart.getDataVisibility(t) ? g = e.getPixelForValue(u + f) : g = m, p = g - m, Math.abs(p) < a) {
      p = fn(p, e, r) * a, d === r && (m -= p / 2);
      const b = e.getPixelForDecimal(0), _ = e.getPixelForDecimal(1), v = Math.min(b, _), y = Math.max(b, _);
      m = Math.max(Math.min(m, y), v), g = m + p, i && !c && (l._stacks[e.axis]._visualValues[s] = e.getValueForPixel(g) - e.getValueForPixel(m));
    }
    if (m === e.getPixelForValue(r)) {
      const b = nt(p) * e.getLineWidthForValue(r) / 2;
      m += b, p -= b;
    }
    return {
      size: p,
      base: m,
      head: g,
      center: g + p / 2
    };
  }
  _calculateBarIndexPixels(t, e) {
    const i = e.scale, s = this.options, n = s.skipNull, a = T(s.maxBarThickness, 1 / 0);
    let r, l;
    if (e.grouped) {
      const h = n ? this._getStackCount(t) : e.stackCount, c = s.barThickness === "flex" ? dn(t, e, s, h) : cn(t, e, s, h), d = this._getStackIndex(this.index, this._cachedMeta.stack, n ? t : void 0);
      r = c.start + c.chunk * d + c.chunk / 2, l = Math.min(a, c.chunk * c.ratio);
    } else
      r = i.getPixelForValue(this.getParsed(t)[i.axis], t), l = Math.min(a, e.min * e.ratio);
    return {
      base: r - l / 2,
      head: r + l / 2,
      center: r,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;
    let n = 0;
    for (; n < s; ++n)
      this.getParsed(n)[e.axis] !== null && i[n].draw(this._ctx);
  }
}
S(be, "id", "bar"), S(be, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), S(be, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
function bn(o, t, e) {
  let i = 1, s = 1, n = 0, a = 0;
  if (t < dt) {
    const r = o, l = r + t, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (_, v, y) => De(_, r, l, !0) ? 1 : Math.max(v, v * e, y, y * e), g = (_, v, y) => De(_, r, l, !0) ? -1 : Math.min(v, v * e, y, y * e), p = f(0, h, d), x = f(Mt, c, u), m = g(pt, h, d), b = g(pt + Mt, c, u);
    i = (p - m) / 2, s = (x - b) / 2, n = -(p + m) / 2, a = -(x + b) / 2;
  }
  return {
    ratioX: i,
    ratioY: s,
    offsetX: n,
    offsetY: a
  };
}
class Ft extends ft {
  constructor(t, e) {
    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, e) {
    const i = this.getDataset().data, s = this._cachedMeta;
    if (this._parsing === !1)
      s._parsed = i;
    else {
      let n = (l) => +i[l];
      if (E(i[t])) {
        const { key: l = "value" } = this._parsing;
        n = (h) => +kt(i[h], l);
      }
      let a, r;
      for (a = t, r = t + e; a < r; ++a)
        s._parsed[a] = n(a);
    }
  }
  _getRotation() {
    return q(this.options.rotation - 90);
  }
  _getCircumference() {
    return q(this.options.circumference);
  }
  _getRotationExtents() {
    let t = dt, e = -dt;
    for (let i = 0; i < this.chart.data.datasets.length; ++i)
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), a = s._getCircumference();
        t = Math.min(t, n), e = Math.max(e, n + a);
      }
    return {
      rotation: t,
      circumference: e - t
    };
  }
  update(t) {
    const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, a = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, r = Math.max((Math.min(i.width, i.height) - a) / 2, 0), l = Math.min(Vs(this.options.cutout, r), 1), h = this._getRingWeight(this.index), { circumference: c, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = bn(d, c, l), x = (i.width - a) / u, m = (i.height - a) / f, b = Math.max(Math.min(x, m) / 2, 0), _ = Hs(this.options.radius, b), v = Math.max(_ * l, 0), y = (_ - v) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * _, this.offsetY = p * _, s.total = this.calculateTotal(), this.outerRadius = _ - y * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - y * h, 0), this.updateElements(n, 0, n.length, t);
  }
  _circumference(t, e) {
    const i = this.options, s = this._cachedMeta, n = this._getCircumference();
    return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || s._parsed[t] === null || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / dt);
  }
  updateElements(t, e, i, s) {
    const n = s === "reset", a = this.chart, r = a.chartArea, h = a.options.animation, c = (r.left + r.right) / 2, d = (r.top + r.bottom) / 2, u = n && h.animateScale, f = u ? 0 : this.innerRadius, g = u ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: x } = this._getSharedOptions(e, s);
    let m = this._getRotation(), b;
    for (b = 0; b < e; ++b)
      m += this._circumference(b, n);
    for (b = e; b < e + i; ++b) {
      const _ = this._circumference(b, n), v = t[b], y = {
        x: c + this.offsetX,
        y: d + this.offsetY,
        startAngle: m,
        endAngle: m + _,
        circumference: _,
        outerRadius: g,
        innerRadius: f
      };
      x && (y.options = p || this.resolveDataElementOptions(b, v.active ? "active" : s)), m += _, this.updateElement(v, b, y, s);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, e = t.data;
    let i = 0, s;
    for (s = 0; s < e.length; s++) {
      const n = t._parsed[s];
      n !== null && !isNaN(n) && this.chart.getDataVisibility(s) && !e[s].hidden && (i += Math.abs(n));
    }
    return i;
  }
  calculateCircumference(t) {
    const e = this._cachedMeta.total;
    return e > 0 && !isNaN(t) ? dt * (Math.abs(t) / e) : 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ue(e._parsed[t], i.options.locale);
    return {
      label: s[t] || "",
      value: n
    };
  }
  getMaxBorderWidth(t) {
    let e = 0;
    const i = this.chart;
    let s, n, a, r, l;
    if (!t) {
      for (s = 0, n = i.data.datasets.length; s < n; ++s)
        if (i.isDatasetVisible(s)) {
          a = i.getDatasetMeta(s), t = a.data, r = a.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (s = 0, n = t.length; s < n; ++s)
      l = r.resolveDataElementOptions(s), l.borderAlign !== "inner" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return e;
  }
  getMaxOffset(t) {
    let e = 0;
    for (let i = 0, s = t.length; i < s; ++i) {
      const n = this.resolveDataElementOptions(i);
      e = Math.max(e, n.offset || 0, n.hoverOffset || 0);
    }
    return e;
  }
  _getRingWeightOffset(t) {
    let e = 0;
    for (let i = 0; i < t; ++i)
      this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
    return e;
  }
  _getRingWeight(t) {
    return Math.max(T(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
S(Ft, "id", "doughnut"), S(Ft, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), S(Ft, "descriptors", {
  _scriptable: (t) => t !== "spacing",
  _indexable: (t) => t !== "spacing"
}), S(Ft, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(t) {
          const e = t.data;
          if (e.labels.length && e.datasets.length) {
            const { labels: { pointStyle: i, color: s } } = t.legend.options;
            return e.labels.map((n, a) => {
              const l = t.getDatasetMeta(0).controller.getStyle(a);
              return {
                text: n,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: s,
                lineWidth: l.borderWidth,
                pointStyle: i,
                hidden: !t.getDataVisibility(a),
                index: a
              };
            });
          }
          return [];
        }
      },
      onClick(t, e, i) {
        i.chart.toggleDataVisibility(e.index), i.chart.update();
      }
    }
  }
});
class ie extends ft {
  constructor(t, e) {
    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ue(e._parsed[t].r, i.options.locale);
    return {
      label: s[t] || "",
      value: n
    };
  }
  parseObjectData(t, e, i, s) {
    return Ws.bind(this)(t, e, i, s);
  }
  update(t) {
    const e = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(e, 0, e.length, t);
  }
  getMinMax() {
    const t = this._cachedMeta, e = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return t.data.forEach((i, s) => {
      const n = this.getParsed(s).r;
      !isNaN(n) && this.chart.getDataVisibility(s) && (n < e.min && (e.min = n), n > e.max && (e.max = n));
    }), e;
  }
  _updateRadius() {
    const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), n = Math.max(s / 2, 0), a = Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0), r = (n - a) / t.getVisibleDatasetCount();
    this.outerRadius = n - r * this.index, this.innerRadius = this.outerRadius - r;
  }
  updateElements(t, e, i, s) {
    const n = s === "reset", a = this.chart, l = a.options.animation, h = this._cachedMeta.rScale, c = h.xCenter, d = h.yCenter, u = h.getIndexAngle(0) - 0.5 * pt;
    let f = u, g;
    const p = 360 / this.countVisibleElements();
    for (g = 0; g < e; ++g)
      f += this._computeAngle(g, s, p);
    for (g = e; g < e + i; g++) {
      const x = t[g];
      let m = f, b = f + this._computeAngle(g, s, p), _ = a.getDataVisibility(g) ? h.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
      f = b, n && (l.animateScale && (_ = 0), l.animateRotate && (m = b = u));
      const v = {
        x: c,
        y: d,
        innerRadius: 0,
        outerRadius: _,
        startAngle: m,
        endAngle: b,
        options: this.resolveDataElementOptions(g, x.active ? "active" : s)
      };
      this.updateElement(x, g, v, s);
    }
  }
  countVisibleElements() {
    const t = this._cachedMeta;
    let e = 0;
    return t.data.forEach((i, s) => {
      !isNaN(this.getParsed(s).r) && this.chart.getDataVisibility(s) && e++;
    }), e;
  }
  _computeAngle(t, e, i) {
    return this.chart.getDataVisibility(t) ? q(this.resolveDataElementOptions(t, e).angle || i) : 0;
  }
}
S(ie, "id", "polarArea"), S(ie, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), S(ie, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(t) {
          const e = t.data;
          if (e.labels.length && e.datasets.length) {
            const { labels: { pointStyle: i, color: s } } = t.legend.options;
            return e.labels.map((n, a) => {
              const l = t.getDatasetMeta(0).controller.getStyle(a);
              return {
                text: n,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: s,
                lineWidth: l.borderWidth,
                pointStyle: i,
                hidden: !t.getDataVisibility(a),
                index: a
              };
            });
          }
          return [];
        }
      },
      onClick(t, e, i) {
        i.chart.toggleDataVisibility(e.index), i.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
function rt() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Ie {
  static override(t) {
    Object.assign(Ie.prototype, t);
  }
  constructor(t) {
    this.options = t || {};
  }
  init() {
  }
  formats() {
    return rt();
  }
  parse() {
    return rt();
  }
  format() {
    return rt();
  }
  add() {
    return rt();
  }
  diff() {
    return rt();
  }
  startOf() {
    return rt();
  }
  endOf() {
    return rt();
  }
}
var _n = {
  _date: Ie
};
function yn(o, t, e, i) {
  const { controller: s, data: n, _sorted: a } = o, r = s._cachedMeta.iScale;
  if (r && t === r.axis && t !== "r" && a && n.length) {
    const l = r._reversePixels ? Us : Se;
    if (i) {
      if (s._sharedOptions) {
        const h = n[0], c = typeof h.getRange == "function" && h.getRange(t);
        if (c) {
          const d = l(n, t, e - c), u = l(n, t, e + c);
          return {
            lo: d.lo,
            hi: u.hi
          };
        }
      }
    } else
      return l(n, t, e);
  }
  return {
    lo: 0,
    hi: n.length - 1
  };
}
function Nt(o, t, e, i, s) {
  const n = o.getSortedVisibleDatasetMetas(), a = e[t];
  for (let r = 0, l = n.length; r < l; ++r) {
    const { index: h, data: c } = n[r], { lo: d, hi: u } = yn(n[r], t, a, s);
    for (let f = d; f <= u; ++f) {
      const g = c[f];
      g.skip || i(g, h, f);
    }
  }
}
function vn(o) {
  const t = o.indexOf("x") !== -1, e = o.indexOf("y") !== -1;
  return function(i, s) {
    const n = t ? Math.abs(i.x - s.x) : 0, a = e ? Math.abs(i.y - s.y) : 0;
    return Math.sqrt(Math.pow(n, 2) + Math.pow(a, 2));
  };
}
function _e(o, t, e, i, s) {
  const n = [];
  return !s && !o.isPointInArea(t) || Nt(o, e, t, function(r, l, h) {
    !s && !Yi(r, o.chartArea, 0) || r.inRange(t.x, t.y, i) && n.push({
      element: r,
      datasetIndex: l,
      index: h
    });
  }, !0), n;
}
function kn(o, t, e, i) {
  let s = [];
  function n(a, r, l) {
    const { startAngle: h, endAngle: c } = a.getProps([
      "startAngle",
      "endAngle"
    ], i), { angle: d } = Ys(a, {
      x: t.x,
      y: t.y
    });
    De(d, h, c) && s.push({
      element: a,
      datasetIndex: r,
      index: l
    });
  }
  return Nt(o, e, t, n), s;
}
function wn(o, t, e, i, s, n) {
  let a = [];
  const r = vn(e);
  let l = Number.POSITIVE_INFINITY;
  function h(c, d, u) {
    const f = c.inRange(t.x, t.y, s);
    if (i && !f)
      return;
    const g = c.getCenterPoint(s);
    if (!(!!n || o.isPointInArea(g)) && !f)
      return;
    const x = r(t, g);
    x < l ? (a = [
      {
        element: c,
        datasetIndex: d,
        index: u
      }
    ], l = x) : x === l && a.push({
      element: c,
      datasetIndex: d,
      index: u
    });
  }
  return Nt(o, e, t, h), a;
}
function ye(o, t, e, i, s, n) {
  return !n && !o.isPointInArea(t) ? [] : e === "r" && !i ? kn(o, t, e, s) : wn(o, t, e, i, s, n);
}
function li(o, t, e, i, s) {
  const n = [], a = e === "x" ? "inXRange" : "inYRange";
  let r = !1;
  return Nt(o, e, t, (l, h, c) => {
    l[a](t[e], s) && (n.push({
      element: l,
      datasetIndex: h,
      index: c
    }), r = r || l.inRange(t.x, t.y, s));
  }), i && !r ? [] : n;
}
var Mn = {
  evaluateInteractionItems: Nt,
  modes: {
    index(o, t, e, i) {
      const s = ht(t, o), n = e.axis || "x", a = e.includeInvisible || !1, r = e.intersect ? _e(o, s, n, i, a) : ye(o, s, n, !1, i, a), l = [];
      return r.length ? (o.getSortedVisibleDatasetMetas().forEach((h) => {
        const c = r[0].index, d = h.data[c];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: h.index,
          index: c
        });
      }), l) : [];
    },
    dataset(o, t, e, i) {
      const s = ht(t, o), n = e.axis || "xy", a = e.includeInvisible || !1;
      let r = e.intersect ? _e(o, s, n, i, a) : ye(o, s, n, !1, i, a);
      if (r.length > 0) {
        const l = r[0].datasetIndex, h = o.getDatasetMeta(l).data;
        r = [];
        for (let c = 0; c < h.length; ++c)
          r.push({
            element: h[c],
            datasetIndex: l,
            index: c
          });
      }
      return r;
    },
    point(o, t, e, i) {
      const s = ht(t, o), n = e.axis || "xy", a = e.includeInvisible || !1;
      return _e(o, s, n, i, a);
    },
    nearest(o, t, e, i) {
      const s = ht(t, o), n = e.axis || "xy", a = e.includeInvisible || !1;
      return ye(o, s, n, e.intersect, i, a);
    },
    x(o, t, e, i) {
      const s = ht(t, o);
      return li(o, s, "x", e.intersect, i);
    },
    y(o, t, e, i) {
      const s = ht(t, o);
      return li(o, s, "y", e.intersect, i);
    }
  }
};
const ss = [
  "left",
  "top",
  "right",
  "bottom"
];
function At(o, t) {
  return o.filter((e) => e.pos === t);
}
function hi(o, t) {
  return o.filter((e) => ss.indexOf(e.pos) === -1 && e.box.axis === t);
}
function Ot(o, t) {
  return o.sort((e, i) => {
    const s = t ? i : e, n = t ? e : i;
    return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;
  });
}
function Sn(o) {
  const t = [];
  let e, i, s, n, a, r;
  for (e = 0, i = (o || []).length; e < i; ++e)
    s = o[e], { position: n, options: { stack: a, stackWeight: r = 1 } } = s, t.push({
      index: e,
      box: s,
      pos: n,
      horizontal: s.isHorizontal(),
      weight: s.weight,
      stack: a && n + a,
      stackWeight: r
    });
  return t;
}
function Dn(o) {
  const t = {};
  for (const e of o) {
    const { stack: i, pos: s, stackWeight: n } = e;
    if (!i || !ss.includes(s))
      continue;
    const a = t[i] || (t[i] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    a.count++, a.weight += n;
  }
  return t;
}
function Pn(o, t) {
  const e = Dn(o), { vBoxMaxWidth: i, hBoxMaxHeight: s } = t;
  let n, a, r;
  for (n = 0, a = o.length; n < a; ++n) {
    r = o[n];
    const { fullSize: l } = r.box, h = e[r.stack], c = h && r.stackWeight / h.weight;
    r.horizontal ? (r.width = c ? c * i : l && t.availableWidth, r.height = s) : (r.width = i, r.height = c ? c * s : l && t.availableHeight);
  }
  return e;
}
function Cn(o) {
  const t = Sn(o), e = Ot(t.filter((h) => h.box.fullSize), !0), i = Ot(At(t, "left"), !0), s = Ot(At(t, "right")), n = Ot(At(t, "top"), !0), a = Ot(At(t, "bottom")), r = hi(t, "x"), l = hi(t, "y");
  return {
    fullSize: e,
    leftAndTop: i.concat(n),
    rightAndBottom: s.concat(l).concat(a).concat(r),
    chartArea: At(t, "chartArea"),
    vertical: i.concat(s).concat(l),
    horizontal: n.concat(a).concat(r)
  };
}
function ci(o, t, e, i) {
  return Math.max(o[e], t[e]) + Math.max(o[i], t[i]);
}
function ns(o, t) {
  o.top = Math.max(o.top, t.top), o.left = Math.max(o.left, t.left), o.bottom = Math.max(o.bottom, t.bottom), o.right = Math.max(o.right, t.right);
}
function Ln(o, t, e, i) {
  const { pos: s, box: n } = e, a = o.maxPadding;
  if (!E(s)) {
    e.size && (o[s] -= e.size);
    const d = i[e.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, e.horizontal ? n.height : n.width), e.size = d.size / d.count, o[s] += e.size;
  }
  n.getPadding && ns(a, n.getPadding());
  const r = Math.max(0, t.outerWidth - ci(a, o, "left", "right")), l = Math.max(0, t.outerHeight - ci(a, o, "top", "bottom")), h = r !== o.w, c = l !== o.h;
  return o.w = r, o.h = l, e.horizontal ? {
    same: h,
    other: c
  } : {
    same: c,
    other: h
  };
}
function An(o) {
  const t = o.maxPadding;
  function e(i) {
    const s = Math.max(t[i] - o[i], 0);
    return o[i] += s, s;
  }
  o.y += e("top"), o.x += e("left"), e("right"), e("bottom");
}
function On(o, t) {
  const e = t.maxPadding;
  function i(s) {
    const n = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return s.forEach((a) => {
      n[a] = Math.max(t[a], e[a]);
    }), n;
  }
  return i(o ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Et(o, t, e, i) {
  const s = [];
  let n, a, r, l, h, c;
  for (n = 0, a = o.length, h = 0; n < a; ++n) {
    r = o[n], l = r.box, l.update(r.width || t.w, r.height || t.h, On(r.horizontal, t));
    const { same: d, other: u } = Ln(t, e, r, i);
    h |= d && s.length, c = c || u, l.fullSize || s.push(r);
  }
  return h && Et(s, t, e, i) || c;
}
function Xt(o, t, e, i, s) {
  o.top = e, o.left = t, o.right = t + i, o.bottom = e + s, o.width = i, o.height = s;
}
function di(o, t, e, i) {
  const s = e.padding;
  let { x: n, y: a } = t;
  for (const r of o) {
    const l = r.box, h = i[r.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, c = r.stackWeight / h.weight || 1;
    if (r.horizontal) {
      const d = t.w * c, u = h.size || l.height;
      Bt(h.start) && (a = h.start), l.fullSize ? Xt(l, s.left, a, e.outerWidth - s.right - s.left, u) : Xt(l, t.left + h.placed, a, d, u), h.start = a, h.placed += d, a = l.bottom;
    } else {
      const d = t.h * c, u = h.size || l.width;
      Bt(h.start) && (n = h.start), l.fullSize ? Xt(l, n, s.top, u, e.outerHeight - s.bottom - s.top) : Xt(l, n, t.top + h.placed, u, d), h.start = n, h.placed += d, n = l.right;
    }
  }
  t.x = n, t.y = a;
}
var W = {
  addBox(o, t) {
    o.boxes || (o.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(e) {
            t.draw(e);
          }
        }
      ];
    }, o.boxes.push(t);
  },
  removeBox(o, t) {
    const e = o.boxes ? o.boxes.indexOf(t) : -1;
    e !== -1 && o.boxes.splice(e, 1);
  },
  configure(o, t, e) {
    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;
  },
  update(o, t, e, i) {
    if (!o)
      return;
    const s = N(o.options.layout.padding), n = Math.max(t - s.width, 0), a = Math.max(e - s.height, 0), r = Cn(o.boxes), l = r.vertical, h = r.horizontal;
    C(o.boxes, (p) => {
      typeof p.beforeLayout == "function" && p.beforeLayout();
    });
    const c = l.reduce((p, x) => x.box.options && x.box.options.display === !1 ? p : p + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: e,
      padding: s,
      availableWidth: n,
      availableHeight: a,
      vBoxMaxWidth: n / 2 / c,
      hBoxMaxHeight: a / 2
    }), u = Object.assign({}, s);
    ns(u, N(i));
    const f = Object.assign({
      maxPadding: u,
      w: n,
      h: a,
      x: s.left,
      y: s.top
    }, s), g = Pn(l.concat(h), d);
    Et(r.fullSize, f, d, g), Et(l, f, d, g), Et(h, f, d, g) && Et(l, f, d, g), An(f), di(r.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, di(r.rightAndBottom, f, d, g), o.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, C(r.chartArea, (p) => {
      const x = p.box;
      Object.assign(x, o.chartArea), x.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class os {
  acquireContext(t, e) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, e, i) {
  }
  removeEventListener(t, e, i) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, e, i, s) {
    return e = Math.max(0, e || t.width), i = i || t.height, {
      width: e,
      height: Math.max(0, s ? Math.floor(e / s) : i)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Tn extends os {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const se = "$chartjs", zn = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, ui = (o) => o === null || o === "";
function Rn(o, t) {
  const e = o.style, i = o.getAttribute("height"), s = o.getAttribute("width");
  if (o[se] = {
    initial: {
      height: i,
      width: s,
      style: {
        display: e.display,
        height: e.height,
        width: e.width
      }
    }
  }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", ui(s)) {
    const n = qe(o, "width");
    n !== void 0 && (o.width = n);
  }
  if (ui(i))
    if (o.style.height === "")
      o.height = o.width / (t || 2);
    else {
      const n = qe(o, "height");
      n !== void 0 && (o.height = n);
    }
  return o;
}
const as = ys ? {
  passive: !0
} : !1;
function Fn(o, t, e) {
  o.addEventListener(t, e, as);
}
function En(o, t, e) {
  o.canvas.removeEventListener(t, e, as);
}
function In(o, t) {
  const e = zn[o.type] || o.type, { x: i, y: s } = ht(o, t);
  return {
    type: e,
    chart: t,
    native: o,
    x: i !== void 0 ? i : null,
    y: s !== void 0 ? s : null
  };
}
function re(o, t) {
  for (const e of o)
    if (e === t || e.contains(t))
      return !0;
}
function Bn(o, t, e) {
  const i = o.canvas, s = new MutationObserver((n) => {
    let a = !1;
    for (const r of n)
      a = a || re(r.addedNodes, i), a = a && !re(r.removedNodes, i);
    a && e();
  });
  return s.observe(document, {
    childList: !0,
    subtree: !0
  }), s;
}
function Vn(o, t, e) {
  const i = o.canvas, s = new MutationObserver((n) => {
    let a = !1;
    for (const r of n)
      a = a || re(r.removedNodes, i), a = a && !re(r.addedNodes, i);
    a && e();
  });
  return s.observe(document, {
    childList: !0,
    subtree: !0
  }), s;
}
const Ht = /* @__PURE__ */ new Map();
let fi = 0;
function rs() {
  const o = window.devicePixelRatio;
  o !== fi && (fi = o, Ht.forEach((t, e) => {
    e.currentDevicePixelRatio !== o && t();
  }));
}
function Hn(o, t) {
  Ht.size || window.addEventListener("resize", rs), Ht.set(o, t);
}
function Wn(o) {
  Ht.delete(o), Ht.size || window.removeEventListener("resize", rs);
}
function Nn(o, t, e) {
  const i = o.canvas, s = i && Zi(i);
  if (!s)
    return;
  const n = Qi((r, l) => {
    const h = s.clientWidth;
    e(r, l), h < s.clientWidth && e();
  }, window), a = new ResizeObserver((r) => {
    const l = r[0], h = l.contentRect.width, c = l.contentRect.height;
    h === 0 && c === 0 || n(h, c);
  });
  return a.observe(s), Hn(o, n), a;
}
function ve(o, t, e) {
  e && e.disconnect(), t === "resize" && Wn(o);
}
function jn(o, t, e) {
  const i = o.canvas, s = Qi((n) => {
    o.ctx !== null && e(In(n, o));
  }, o);
  return Fn(i, t, s), s;
}
class $n extends os {
  acquireContext(t, e) {
    const i = t && t.getContext && t.getContext("2d");
    return i && i.canvas === t ? (Rn(t, e), i) : null;
  }
  releaseContext(t) {
    const e = t.canvas;
    if (!e[se])
      return !1;
    const i = e[se].initial;
    [
      "height",
      "width"
    ].forEach((n) => {
      const a = i[n];
      z(a) ? e.removeAttribute(n) : e.setAttribute(n, a);
    });
    const s = i.style || {};
    return Object.keys(s).forEach((n) => {
      e.style[n] = s[n];
    }), e.width = e.width, delete e[se], !0;
  }
  addEventListener(t, e, i) {
    this.removeEventListener(t, e);
    const s = t.$proxies || (t.$proxies = {}), a = {
      attach: Bn,
      detach: Vn,
      resize: Nn
    }[e] || jn;
    s[e] = a(t, e, i);
  }
  removeEventListener(t, e) {
    const i = t.$proxies || (t.$proxies = {}), s = i[e];
    if (!s)
      return;
    ({
      attach: ve,
      detach: ve,
      resize: ve
    }[e] || En)(t, e, s), i[e] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, e, i, s) {
    return Ts(t, e, i, s);
  }
  isAttached(t) {
    const e = Zi(t);
    return !!(e && e.isConnected);
  }
}
function Un(o) {
  return !Ki() || typeof OffscreenCanvas < "u" && o instanceof OffscreenCanvas ? Tn : $n;
}
class ot {
  constructor() {
    S(this, "active", !1);
  }
  tooltipPosition(t) {
    const { x: e, y: i } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: e,
      y: i
    };
  }
  hasValue() {
    return ae(this.x) && ae(this.y);
  }
  getProps(t, e) {
    const i = this.$animations;
    if (!e || !i)
      return this;
    const s = {};
    return t.forEach((n) => {
      s[n] = i[n] && i[n].active() ? i[n]._to : this[n];
    }), s;
  }
}
S(ot, "defaults", {}), S(ot, "defaultRoutes");
function Yn(o, t) {
  const e = o.options.ticks, i = Xn(o), s = Math.min(e.maxTicksLimit || i, i), n = e.major.enabled ? qn(t) : [], a = n.length, r = n[0], l = n[a - 1], h = [];
  if (a > s)
    return Gn(t, h, n, a / s), h;
  const c = Kn(n, t, s);
  if (a > 0) {
    let d, u;
    const f = a > 1 ? Math.round((l - r) / (a - 1)) : null;
    for (Kt(t, h, c, z(f) ? 0 : r - f, r), d = 0, u = a - 1; d < u; d++)
      Kt(t, h, c, n[d], n[d + 1]);
    return Kt(t, h, c, l, z(f) ? t.length : l + f), h;
  }
  return Kt(t, h, c), h;
}
function Xn(o) {
  const t = o.options.offset, e = o._tickSize(), i = o._length / e + (t ? 0 : 1), s = o._maxLength / e;
  return Math.floor(Math.min(i, s));
}
function Kn(o, t, e) {
  const i = Jn(o), s = t.length / e;
  if (!i)
    return Math.max(s, 1);
  const n = Ns(i);
  for (let a = 0, r = n.length - 1; a < r; a++) {
    const l = n[a];
    if (l > s)
      return l;
  }
  return Math.max(s, 1);
}
function qn(o) {
  const t = [];
  let e, i;
  for (e = 0, i = o.length; e < i; e++)
    o[e].major && t.push(e);
  return t;
}
function Gn(o, t, e, i) {
  let s = 0, n = e[0], a;
  for (i = Math.ceil(i), a = 0; a < o.length; a++)
    a === n && (t.push(o[a]), s++, n = e[s * i]);
}
function Kt(o, t, e, i, s) {
  const n = T(i, 0), a = Math.min(T(s, o.length), o.length);
  let r = 0, l, h, c;
  for (e = Math.ceil(e), s && (l = s - i, e = l / Math.floor(l / e)), c = n; c < 0; )
    r++, c = Math.round(n + r * e);
  for (h = Math.max(n, 0); h < a; h++)
    h === c && (t.push(o[h]), r++, c = Math.round(n + r * e));
}
function Jn(o) {
  const t = o.length;
  let e, i;
  if (t < 2)
    return !1;
  for (i = o[0], e = 1; e < t; ++e)
    if (o[e] - o[e - 1] !== i)
      return !1;
  return i;
}
const Zn = (o) => o === "left" ? "right" : o === "right" ? "left" : o, gi = (o, t, e) => t === "top" || t === "left" ? o[t] + e : o[t] - e;
function pi(o, t) {
  const e = [], i = o.length / t, s = o.length;
  let n = 0;
  for (; n < s; n += i)
    e.push(o[Math.floor(n)]);
  return e;
}
function Qn(o, t, e) {
  const i = o.ticks.length, s = Math.min(t, i - 1), n = o._startPixel, a = o._endPixel, r = 1e-6;
  let l = o.getPixelForTick(s), h;
  if (!(e && (i === 1 ? h = Math.max(l - n, a - l) : t === 0 ? h = (o.getPixelForTick(1) - l) / 2 : h = (l - o.getPixelForTick(s - 1)) / 2, l += s < t ? h : -h, l < n - r || l > a + r)))
    return l;
}
function to(o, t) {
  C(o, (e) => {
    const i = e.gc, s = i.length / 2;
    let n;
    if (s > t) {
      for (n = 0; n < s; ++n)
        delete e.data[i[n]];
      i.splice(0, s);
    }
  });
}
function Tt(o) {
  return o.drawTicks ? o.tickLength : 0;
}
function mi(o, t) {
  if (!o.display)
    return 0;
  const e = I(o.font, t), i = N(o.padding);
  return (X(o.text) ? o.text.length : 1) * e.lineHeight + i.height;
}
function eo(o, t) {
  return mt(o, {
    scale: t,
    type: "scale"
  });
}
function io(o, t, e) {
  return mt(o, {
    tick: e,
    index: t,
    type: "tick"
  });
}
function so(o, t, e) {
  let i = Ee(o);
  return (e && t !== "right" || !e && t === "right") && (i = Zn(i)), i;
}
function no(o, t, e, i) {
  const { top: s, left: n, bottom: a, right: r, chart: l } = o, { chartArea: h, scales: c } = l;
  let d = 0, u, f, g;
  const p = a - s, x = r - n;
  if (o.isHorizontal()) {
    if (f = V(i, n, r), E(e)) {
      const m = Object.keys(e)[0], b = e[m];
      g = c[m].getPixelForValue(b) + p - t;
    } else
      e === "center" ? g = (h.bottom + h.top) / 2 + p - t : g = gi(o, e, t);
    u = r - n;
  } else {
    if (E(e)) {
      const m = Object.keys(e)[0], b = e[m];
      f = c[m].getPixelForValue(b) - x + t;
    } else
      e === "center" ? f = (h.left + h.right) / 2 - x + t : f = gi(o, e, t);
    g = V(i, a, s), d = e === "left" ? -Mt : Mt;
  }
  return {
    titleX: f,
    titleY: g,
    maxWidth: u,
    rotation: d
  };
}
class xt extends ot {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, e) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;
    return t = Y(t, Number.POSITIVE_INFINITY), e = Y(e, Number.NEGATIVE_INFINITY), i = Y(i, Number.POSITIVE_INFINITY), s = Y(s, Number.NEGATIVE_INFINITY), {
      min: Y(t, i),
      max: Y(e, s),
      minDefined: H(t),
      maxDefined: H(e)
    };
  }
  getMinMax(t) {
    let { min: e, max: i, minDefined: s, maxDefined: n } = this.getUserBounds(), a;
    if (s && n)
      return {
        min: e,
        max: i
      };
    const r = this.getMatchingVisibleMetas();
    for (let l = 0, h = r.length; l < h; ++l)
      a = r[l].controller.getMinMax(this, t), s || (e = Math.min(e, a.min)), n || (i = Math.max(i, a.max));
    return e = n && e > i ? i : e, i = s && e > i ? e : i, {
      min: Y(e, Y(i, e)),
      max: Y(i, Y(e, i))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    O(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, e, i) {
    const { beginAtZero: s, grace: n, ticks: a } = this.options, r = a.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Ss(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = r < this.ticks.length;
    this._convertTicksToLabels(l ? pi(this.ticks, r) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = Yn(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, e, i;
    this.isHorizontal() ? (e = this.left, i = this.right) : (e = this.top, i = this.bottom, t = !t), this._startPixel = e, this._endPixel = i, this._reversePixels = t, this._length = i - e, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    O(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    O(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    O(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), O(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    O(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const e = this.options.ticks;
    let i, s, n;
    for (i = 0, s = t.length; i < s; i++)
      n = t[i], n.label = O(e.callback, [
        n.value,
        i,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    O(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    O(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, e = t.ticks, i = this.ticks.length, s = e.minRotation || 0, n = e.maxRotation;
    let a = s, r, l, h;
    if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) {
      this.labelRotation = s;
      return;
    }
    const c = this._getLabelSizes(), d = c.widest.width, u = c.highest.height, f = Q(this.chart.width - d, 0, this.maxWidth);
    r = t.offset ? this.maxWidth / i : f / (i - 1), d + 6 > r && (r = f / (i - (t.offset ? 0.5 : 1)), l = this.maxHeight - Tt(t.grid) - e.padding - mi(t.title, this.chart.options.font), h = Math.sqrt(d * d + u * u), a = Fe(Math.min(Math.asin(Q((c.highest.height + 6) / r, -1, 1)), Math.asin(Q(l / h, -1, 1)) - Math.asin(Q(u / h, -1, 1)))), a = Math.max(s, Math.min(n, a))), this.labelRotation = a;
  }
  afterCalculateLabelRotation() {
    O(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    O(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: e, options: { ticks: i, title: s, grid: n } } = this, a = this._isVisible(), r = this.isHorizontal();
    if (a) {
      const l = mi(s, e.options.font);
      if (r ? (t.width = this.maxWidth, t.height = Tt(n) + l) : (t.height = this.maxHeight, t.width = Tt(n) + l), i.display && this.ticks.length) {
        const { first: h, last: c, widest: d, highest: u } = this._getLabelSizes(), f = i.padding * 2, g = q(this.labelRotation), p = Math.cos(g), x = Math.sin(g);
        if (r) {
          const m = i.mirror ? 0 : x * d.width + p * u.height;
          t.height = Math.min(this.maxHeight, t.height + m + f);
        } else {
          const m = i.mirror ? 0 : p * d.width + x * u.height;
          t.width = Math.min(this.maxWidth, t.width + m + f);
        }
        this._calculatePadding(h, c, x, p);
      }
    }
    this._handleMargins(), r ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, e, i, s) {
    const { ticks: { align: n, padding: a }, position: r } = this.options, l = this.labelRotation !== 0, h = r !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let u = 0, f = 0;
      l ? h ? (u = s * t.width, f = i * e.height) : (u = i * t.height, f = s * e.width) : n === "start" ? f = e.width : n === "end" ? u = t.width : n !== "inner" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - c + a) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - d + a) * this.width / (this.width - d), 0);
    } else {
      let c = e.height / 2, d = t.height / 2;
      n === "start" ? (c = 0, d = t.height) : n === "end" && (c = e.height, d = 0), this.paddingTop = c + a, this.paddingBottom = d + a;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    O(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: e } = this.options;
    return e === "top" || e === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let e, i;
    for (e = 0, i = t.length; e < i; e++)
      z(t[e].label) && (t.splice(e, 1), i--, e--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const e = this.options.ticks.sampleSize;
      let i = this.ticks;
      e < i.length && (i = pi(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length);
    }
    return t;
  }
  _computeLabelSizes(t, e) {
    const { ctx: i, _longestTextCache: s } = this, n = [], a = [];
    let r = 0, l = 0, h, c, d, u, f, g, p, x, m, b, _;
    for (h = 0; h < e; ++h) {
      if (u = t[h].label, f = this._resolveTickFontOptions(h), i.font = g = f.string, p = s[g] = s[g] || {
        data: {},
        gc: []
      }, x = f.lineHeight, m = b = 0, !z(u) && !X(u))
        m = je(i, p.data, p.gc, m, u), b = x;
      else if (X(u))
        for (c = 0, d = u.length; c < d; ++c)
          _ = u[c], !z(_) && !X(_) && (m = je(i, p.data, p.gc, m, _), b += x);
      n.push(m), a.push(b), r = Math.max(m, r), l = Math.max(b, l);
    }
    to(s, e);
    const v = n.indexOf(r), y = a.indexOf(l), k = (w) => ({
      width: n[w] || 0,
      height: a[w] || 0
    });
    return {
      first: k(0),
      last: k(e - 1),
      widest: k(v),
      highest: k(y),
      widths: n,
      heights: a
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, e) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const e = this._startPixel + t * this._length;
    return Ds(this._alignToPixels ? at(this.chart, e, 0) : e);
  }
  getDecimalForPixel(t) {
    const e = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - e : e;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: e } = this;
    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
  }
  getContext(t) {
    const e = this.ticks || [];
    if (t >= 0 && t < e.length) {
      const i = e[t];
      return i.$context || (i.$context = io(this.getContext(), t, i));
    }
    return this.$context || (this.$context = eo(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, e = q(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), n = this._getLabelSizes(), a = t.autoSkipPadding || 0, r = n ? n.widest.width + a : 0, l = n ? n.highest.height + a : 0;
    return this.isHorizontal() ? l * i > r * s ? r / i : l / s : l * s < r * i ? l / i : r / s;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const e = this.axis, i = this.chart, s = this.options, { grid: n, position: a, border: r } = s, l = n.offset, h = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), u = Tt(n), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, x = p / 2, m = function(B) {
      return at(i, B, p);
    };
    let b, _, v, y, k, w, M, P, L, D, A, j;
    if (a === "top")
      b = m(this.bottom), w = this.bottom - u, P = b - x, D = m(t.top) + x, j = t.bottom;
    else if (a === "bottom")
      b = m(this.top), D = t.top, j = m(t.bottom) - x, w = b + x, P = this.top + u;
    else if (a === "left")
      b = m(this.right), k = this.right - u, M = b - x, L = m(t.left) + x, A = t.right;
    else if (a === "right")
      b = m(this.left), L = t.left, A = m(t.right) - x, k = b + x, M = this.left + u;
    else if (e === "x") {
      if (a === "center")
        b = m((t.top + t.bottom) / 2 + 0.5);
      else if (E(a)) {
        const B = Object.keys(a)[0], K = a[B];
        b = m(this.chart.scales[B].getPixelForValue(K));
      }
      D = t.top, j = t.bottom, w = b + x, P = w + u;
    } else if (e === "y") {
      if (a === "center")
        b = m((t.left + t.right) / 2);
      else if (E(a)) {
        const B = Object.keys(a)[0], K = a[B];
        b = m(this.chart.scales[B].getPixelForValue(K));
      }
      k = b - x, M = k - u, L = t.left, A = t.right;
    }
    const G = T(s.ticks.maxTicksLimit, d), R = Math.max(1, Math.ceil(d / G));
    for (_ = 0; _ < d; _ += R) {
      const B = this.getContext(_), K = n.setContext(B), jt = r.setContext(B), $t = K.lineWidth, bt = K.color, Ut = jt.dash || [], _t = jt.dashOffset, St = K.tickWidth, Dt = K.tickColor, Pt = K.tickBorderDash || [], Ct = K.tickBorderDashOffset;
      v = Qn(this, _, l), v !== void 0 && (y = at(i, v, $t), h ? k = M = L = A = y : w = P = D = j = y, f.push({
        tx1: k,
        ty1: w,
        tx2: M,
        ty2: P,
        x1: L,
        y1: D,
        x2: A,
        y2: j,
        width: $t,
        color: bt,
        borderDash: Ut,
        borderDashOffset: _t,
        tickWidth: St,
        tickColor: Dt,
        tickBorderDash: Pt,
        tickBorderDashOffset: Ct
      }));
    }
    return this._ticksLength = d, this._borderValue = b, f;
  }
  _computeLabelItems(t) {
    const e = this.axis, i = this.options, { position: s, ticks: n } = i, a = this.isHorizontal(), r = this.ticks, { align: l, crossAlign: h, padding: c, mirror: d } = n, u = Tt(i.grid), f = u + c, g = d ? -c : f, p = -q(this.labelRotation), x = [];
    let m, b, _, v, y, k, w, M, P, L, D, A, j = "middle";
    if (s === "top")
      k = this.bottom - g, w = this._getXAxisLabelAlignment();
    else if (s === "bottom")
      k = this.top + g, w = this._getXAxisLabelAlignment();
    else if (s === "left") {
      const R = this._getYAxisLabelAlignment(u);
      w = R.textAlign, y = R.x;
    } else if (s === "right") {
      const R = this._getYAxisLabelAlignment(u);
      w = R.textAlign, y = R.x;
    } else if (e === "x") {
      if (s === "center")
        k = (t.top + t.bottom) / 2 + f;
      else if (E(s)) {
        const R = Object.keys(s)[0], B = s[R];
        k = this.chart.scales[R].getPixelForValue(B) + f;
      }
      w = this._getXAxisLabelAlignment();
    } else if (e === "y") {
      if (s === "center")
        y = (t.left + t.right) / 2 - f;
      else if (E(s)) {
        const R = Object.keys(s)[0], B = s[R];
        y = this.chart.scales[R].getPixelForValue(B);
      }
      w = this._getYAxisLabelAlignment(u).textAlign;
    }
    e === "y" && (l === "start" ? j = "top" : l === "end" && (j = "bottom"));
    const G = this._getLabelSizes();
    for (m = 0, b = r.length; m < b; ++m) {
      _ = r[m], v = _.label;
      const R = n.setContext(this.getContext(m));
      M = this.getPixelForTick(m) + n.labelOffset, P = this._resolveTickFontOptions(m), L = P.lineHeight, D = X(v) ? v.length : 1;
      const B = D / 2, K = R.color, jt = R.textStrokeColor, $t = R.textStrokeWidth;
      let bt = w;
      a ? (y = M, w === "inner" && (m === b - 1 ? bt = this.options.reverse ? "left" : "right" : m === 0 ? bt = this.options.reverse ? "right" : "left" : bt = "center"), s === "top" ? h === "near" || p !== 0 ? A = -D * L + L / 2 : h === "center" ? A = -G.highest.height / 2 - B * L + L : A = -G.highest.height + L / 2 : h === "near" || p !== 0 ? A = L / 2 : h === "center" ? A = G.highest.height / 2 - B * L : A = G.highest.height - D * L, d && (A *= -1), p !== 0 && !R.showLabelBackdrop && (y += L / 2 * Math.sin(p))) : (k = M, A = (1 - D) * L / 2);
      let Ut;
      if (R.showLabelBackdrop) {
        const _t = N(R.backdropPadding), St = G.heights[m], Dt = G.widths[m];
        let Pt = A - _t.top, Ct = 0 - _t.left;
        switch (j) {
          case "middle":
            Pt -= St / 2;
            break;
          case "bottom":
            Pt -= St;
            break;
        }
        switch (w) {
          case "center":
            Ct -= Dt / 2;
            break;
          case "right":
            Ct -= Dt;
            break;
        }
        Ut = {
          left: Ct,
          top: Pt,
          width: Dt + _t.width,
          height: St + _t.height,
          color: R.backdropColor
        };
      }
      x.push({
        label: v,
        font: P,
        textOffset: A,
        options: {
          rotation: p,
          color: K,
          strokeColor: jt,
          strokeWidth: $t,
          textAlign: bt,
          textBaseline: j,
          translation: [
            y,
            k
          ],
          backdrop: Ut
        }
      });
    }
    return x;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: e } = this.options;
    if (-q(this.labelRotation))
      return t === "top" ? "left" : "right";
    let s = "center";
    return e.align === "start" ? s = "left" : e.align === "end" ? s = "right" : e.align === "inner" && (s = "inner"), s;
  }
  _getYAxisLabelAlignment(t) {
    const { position: e, ticks: { crossAlign: i, mirror: s, padding: n } } = this.options, a = this._getLabelSizes(), r = t + n, l = a.widest.width;
    let h, c;
    return e === "left" ? s ? (c = this.right + n, i === "near" ? h = "left" : i === "center" ? (h = "center", c += l / 2) : (h = "right", c += l)) : (c = this.right - r, i === "near" ? h = "right" : i === "center" ? (h = "center", c -= l / 2) : (h = "left", c = this.left)) : e === "right" ? s ? (c = this.left + n, i === "near" ? h = "right" : i === "center" ? (h = "center", c -= l / 2) : (h = "left", c -= l)) : (c = this.left + r, i === "near" ? h = "left" : i === "center" ? (h = "center", c += l / 2) : (h = "right", c = this.right)) : h = "right", {
      textAlign: h,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, e = this.options.position;
    if (e === "left" || e === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (e === "top" || e === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: n, height: a } = this;
    e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, a), t.restore());
  }
  getLineWidthForValue(t) {
    const e = this.options.grid;
    if (!this._isVisible() || !e.display)
      return 0;
    const s = this.ticks.findIndex((n) => n.value === t);
    return s >= 0 ? e.setContext(this.getContext(s)).lineWidth : 0;
  }
  drawGrid(t) {
    const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let n, a;
    const r = (l, h, c) => {
      !c.width || !c.color || (i.save(), i.lineWidth = c.width, i.strokeStyle = c.color, i.setLineDash(c.borderDash || []), i.lineDashOffset = c.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(h.x, h.y), i.stroke(), i.restore());
    };
    if (e.display)
      for (n = 0, a = s.length; n < a; ++n) {
        const l = s[n];
        e.drawOnChartArea && r({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), e.drawTicks && r({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: e, options: { border: i, grid: s } } = this, n = i.setContext(this.getContext()), a = i.display ? n.width : 0;
    if (!a)
      return;
    const r = s.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let h, c, d, u;
    this.isHorizontal() ? (h = at(t, this.left, a) - a / 2, c = at(t, this.right, r) + r / 2, d = u = l) : (d = at(t, this.top, a) - a / 2, u = at(t, this.bottom, r) + r / 2, h = c = l), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(h, d), e.lineTo(c, u), e.stroke(), e.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const i = this.ctx, s = this._computeLabelArea();
    s && Oe(i, s);
    const n = this.getLabelItems(t);
    for (const a of n) {
      const r = a.options, l = a.font, h = a.label, c = a.textOffset;
      gt(i, h, 0, c, l, r);
    }
    s && Te(i);
  }
  drawTitle() {
    const { ctx: t, options: { position: e, title: i, reverse: s } } = this;
    if (!i.display)
      return;
    const n = I(i.font), a = N(i.padding), r = i.align;
    let l = n.lineHeight / 2;
    e === "bottom" || e === "center" || E(e) ? (l += a.bottom, X(i.text) && (l += n.lineHeight * (i.text.length - 1))) : l += a.top;
    const { titleX: h, titleY: c, maxWidth: d, rotation: u } = no(this, l, e, r);
    gt(t, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: d,
      rotation: u,
      textAlign: so(r, e, s),
      textBaseline: "middle",
      translation: [
        h,
        c
      ]
    });
  }
  draw(t) {
    !this._isVisible() || (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, e = t.ticks && t.ticks.z || 0, i = T(t.grid && t.grid.z, -1), s = T(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== xt.prototype.draw ? [
      {
        z: e,
        draw: (n) => {
          this.draw(n);
        }
      }
    ] : [
      {
        z: i,
        draw: (n) => {
          this.drawBackground(), this.drawGrid(n), this.drawTitle();
        }
      },
      {
        z: s,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: e,
        draw: (n) => {
          this.drawLabels(n);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", s = [];
    let n, a;
    for (n = 0, a = e.length; n < a; ++n) {
      const r = e[n];
      r[i] === this.id && (!t || r.type === t) && s.push(r);
    }
    return s;
  }
  _resolveTickFontOptions(t) {
    const e = this.options.ticks.setContext(this.getContext(t));
    return I(e.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class qt {
  constructor(t, e, i) {
    this.type = t, this.scope = e, this.override = i, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const e = Object.getPrototypeOf(t);
    let i;
    ro(e) && (i = this.register(e));
    const s = this.items, n = t.id, a = this.scope + "." + n;
    if (!n)
      throw new Error("class does not have id: " + t);
    return n in s || (s[n] = t, oo(t, a, i), this.override && F.override(t.id, t.overrides)), a;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const e = this.items, i = t.id, s = this.scope;
    i in e && delete e[i], s && i in F[s] && (delete F[s][i], this.override && delete wt[i]);
  }
}
function oo(o, t, e) {
  const i = js(/* @__PURE__ */ Object.create(null), [
    e ? F.get(e) : {},
    F.get(t),
    o.defaults
  ]);
  F.set(t, i), o.defaultRoutes && ao(t, o.defaultRoutes), o.descriptors && F.describe(t, o.descriptors);
}
function ao(o, t) {
  Object.keys(t).forEach((e) => {
    const i = e.split("."), s = i.pop(), n = [
      o
    ].concat(i).join("."), a = t[e].split("."), r = a.pop(), l = a.join(".");
    F.route(n, s, l, r);
  });
}
function ro(o) {
  return "id" in o && "defaults" in o;
}
class lo {
  constructor() {
    this.controllers = new qt(ft, "datasets", !0), this.elements = new qt(ot, "elements"), this.plugins = new qt(Object, "plugins"), this.scales = new qt(xt, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, e, i) {
    [
      ...e
    ].forEach((s) => {
      const n = i || this._getRegistryForType(s);
      i || n.isForType(s) || n === this.plugins && s.id ? this._exec(t, n, s) : C(s, (a) => {
        const r = i || this._getRegistryForType(a);
        this._exec(t, r, a);
      });
    });
  }
  _exec(t, e, i) {
    const s = zs(t);
    O(i["before" + s], [], i), e[t](i), O(i["after" + s], [], i);
  }
  _getRegistryForType(t) {
    for (let e = 0; e < this._typedRegistries.length; e++) {
      const i = this._typedRegistries[e];
      if (i.isForType(t))
        return i;
    }
    return this.plugins;
  }
  _get(t, e, i) {
    const s = e.get(t);
    if (s === void 0)
      throw new Error('"' + t + '" is not a registered ' + i + ".");
    return s;
  }
}
var Z = /* @__PURE__ */ new lo();
class ho {
  constructor() {
    this._init = [];
  }
  notify(t, e, i, s) {
    e === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), a = this._notify(n, t, e, i);
    return e === "afterDestroy" && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), a;
  }
  _notify(t, e, i, s) {
    s = s || {};
    for (const n of t) {
      const a = n.plugin, r = a[i], l = [
        e,
        s,
        n.options
      ];
      if (O(r, l, a) === !1 && s.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    z(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const e = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), e;
  }
  _createDescriptors(t, e) {
    const i = t && t.config, s = T(i.options && i.options.plugins, {}), n = co(i);
    return s === !1 && !e ? [] : fo(t, n, s, e);
  }
  _notifyStateChanges(t) {
    const e = this._oldCache || [], i = this._cache, s = (n, a) => n.filter((r) => !a.some((l) => r.plugin.id === l.plugin.id));
    this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start");
  }
}
function co(o) {
  const t = {}, e = [], i = Object.keys(Z.plugins.items);
  for (let n = 0; n < i.length; n++)
    e.push(Z.getPlugin(i[n]));
  const s = o.plugins || [];
  for (let n = 0; n < s.length; n++) {
    const a = s[n];
    e.indexOf(a) === -1 && (e.push(a), t[a.id] = !0);
  }
  return {
    plugins: e,
    localIds: t
  };
}
function uo(o, t) {
  return !t && o === !1 ? null : o === !0 ? {} : o;
}
function fo(o, { plugins: t, localIds: e }, i, s) {
  const n = [], a = o.getContext();
  for (const r of t) {
    const l = r.id, h = uo(i[l], s);
    h !== null && n.push({
      plugin: r,
      options: go(o.config, {
        plugin: r,
        local: e[l]
      }, h, a)
    });
  }
  return n;
}
function go(o, { plugin: t, local: e }, i, s) {
  const n = o.pluginScopeKeys(t), a = o.getOptionScopes(i, n);
  return e && t.defaults && a.push(t.defaults), o.createResolver(a, s, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Pe(o, t) {
  const e = F.datasets[o] || {};
  return ((t.datasets || {})[o] || {}).indexAxis || t.indexAxis || e.indexAxis || "x";
}
function po(o, t) {
  let e = o;
  return o === "_index_" ? e = t : o === "_value_" && (e = t === "x" ? "y" : "x"), e;
}
function mo(o, t) {
  return o === t ? "_index_" : "_value_";
}
function xo(o) {
  if (o === "top" || o === "bottom")
    return "x";
  if (o === "left" || o === "right")
    return "y";
}
function le(o, t) {
  if (o === "x" || o === "y" || o === "r" || (o = t.axis || xo(t.position) || o.length > 1 && le(o[0].toLowerCase(), t), o))
    return o;
  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}
function bo(o, t) {
  const e = wt[o.type] || {
    scales: {}
  }, i = t.scales || {}, s = Pe(o.type, t), n = /* @__PURE__ */ Object.create(null);
  return Object.keys(i).forEach((a) => {
    const r = i[a];
    if (!E(r))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (r._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const l = le(a, r), h = mo(l, s), c = e.scales || {};
    n[a] = ee(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      r,
      c[l],
      c[h]
    ]);
  }), o.data.datasets.forEach((a) => {
    const r = a.type || o.type, l = a.indexAxis || Pe(r, t), c = (wt[r] || {}).scales || {};
    Object.keys(c).forEach((d) => {
      const u = po(d, l), f = a[u + "AxisID"] || u;
      n[f] = n[f] || /* @__PURE__ */ Object.create(null), ee(n[f], [
        {
          axis: u
        },
        i[f],
        c[d]
      ]);
    });
  }), Object.keys(n).forEach((a) => {
    const r = n[a];
    ee(r, [
      F.scales[r.type],
      F.scale
    ]);
  }), n;
}
function ls(o) {
  const t = o.options || (o.options = {});
  t.plugins = T(t.plugins, {}), t.scales = bo(o, t);
}
function hs(o) {
  return o = o || {}, o.datasets = o.datasets || [], o.labels = o.labels || [], o;
}
function _o(o) {
  return o = o || {}, o.data = hs(o.data), ls(o), o;
}
const xi = /* @__PURE__ */ new Map(), cs = /* @__PURE__ */ new Set();
function Gt(o, t) {
  let e = xi.get(o);
  return e || (e = t(), xi.set(o, e), cs.add(e)), e;
}
const zt = (o, t, e) => {
  const i = kt(t, e);
  i !== void 0 && o.add(i);
};
class yo {
  constructor(t) {
    this._config = _o(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = hs(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), ls(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return Gt(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, e) {
    return Gt(`${t}.transition.${e}`, () => [
      [
        `datasets.${t}.transitions.${e}`,
        `transitions.${e}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, e) {
    return Gt(`${t}-${e}`, () => [
      [
        `datasets.${t}.elements.${e}`,
        `datasets.${t}`,
        `elements.${e}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const e = t.id, i = this.type;
    return Gt(`${i}-plugin-${e}`, () => [
      [
        `plugins.${e}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, e) {
    const i = this._scopeCache;
    let s = i.get(t);
    return (!s || e) && (s = /* @__PURE__ */ new Map(), i.set(t, s)), s;
  }
  getOptionScopes(t, e, i) {
    const { options: s, type: n } = this, a = this._cachedScopes(t, i), r = a.get(e);
    if (r)
      return r;
    const l = /* @__PURE__ */ new Set();
    e.forEach((c) => {
      t && (l.add(t), c.forEach((d) => zt(l, t, d))), c.forEach((d) => zt(l, s, d)), c.forEach((d) => zt(l, wt[n] || {}, d)), c.forEach((d) => zt(l, F, d)), c.forEach((d) => zt(l, $e, d));
    });
    const h = Array.from(l);
    return h.length === 0 && h.push(/* @__PURE__ */ Object.create(null)), cs.has(e) && a.set(e, h), h;
  }
  chartOptionScopes() {
    const { options: t, type: e } = this;
    return [
      t,
      wt[e] || {},
      F.datasets[e] || {},
      {
        type: e
      },
      F,
      $e
    ];
  }
  resolveNamedOptions(t, e, i, s = [
    ""
  ]) {
    const n = {
      $shared: !0
    }, { resolver: a, subPrefixes: r } = bi(this._resolverCache, t, s);
    let l = a;
    if (ko(a, e)) {
      n.$shared = !1, i = de(i) ? i() : i;
      const h = this.createResolver(t, i, r);
      l = Ue(a, i, h);
    }
    for (const h of e)
      n[h] = l[h];
    return n;
  }
  createResolver(t, e, i = [
    ""
  ], s) {
    const { resolver: n } = bi(this._resolverCache, t, i);
    return E(e) ? Ue(n, e, void 0, s) : n;
  }
}
function bi(o, t, e) {
  let i = o.get(t);
  i || (i = /* @__PURE__ */ new Map(), o.set(t, i));
  const s = e.join();
  let n = i.get(s);
  return n || (n = {
    resolver: Ps(t, e),
    subPrefixes: e.filter((r) => !r.toLowerCase().includes("hover"))
  }, i.set(s, n)), n;
}
const vo = (o) => E(o) && Object.getOwnPropertyNames(o).reduce((t, e) => t || de(o[e]), !1);
function ko(o, t) {
  const { isScriptable: e, isIndexable: i } = Cs(o);
  for (const s of t) {
    const n = e(s), a = i(s), r = (a || n) && o[s];
    if (n && (de(r) || vo(r)) || a && X(r))
      return !0;
  }
  return !1;
}
var wo = "4.1.1";
const Mo = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function _i(o, t) {
  return o === "top" || o === "bottom" || Mo.indexOf(o) === -1 && t === "x";
}
function yi(o, t) {
  return function(e, i) {
    return e[o] === i[o] ? e[t] - i[t] : e[o] - i[o];
  };
}
function vi(o) {
  const t = o.chart, e = t.options.animation;
  t.notifyPlugins("afterRender"), O(e && e.onComplete, [
    o
  ], t);
}
function So(o) {
  const t = o.chart, e = t.options.animation;
  O(e && e.onProgress, [
    o
  ], t);
}
function ds(o) {
  return Ki() && typeof o == "string" ? o = document.getElementById(o) : o && o.length && (o = o[0]), o && o.canvas && (o = o.canvas), o;
}
const ne = {}, ki = (o) => {
  const t = ds(o);
  return Object.values(ne).filter((e) => e.canvas === t).pop();
};
function Do(o, t, e) {
  const i = Object.keys(o);
  for (const s of i) {
    const n = +s;
    if (n >= t) {
      const a = o[s];
      delete o[s], (e > 0 || n > t) && (o[n + e] = a);
    }
  }
}
function Po(o, t, e, i) {
  return !e || o.type === "mouseout" ? null : i ? t : o;
}
function Co(o) {
  const { xScale: t, yScale: e } = o;
  if (t && e)
    return {
      left: t.left,
      right: t.right,
      top: e.top,
      bottom: e.bottom
    };
}
class ct {
  static register(...t) {
    Z.add(...t), wi();
  }
  static unregister(...t) {
    Z.remove(...t), wi();
  }
  constructor(t, e) {
    const i = this.config = new yo(e), s = ds(t), n = ki(s);
    if (n)
      throw new Error("Canvas is already in use. Chart with ID '" + n.id + "' must be destroyed before the canvas with ID '" + n.canvas.id + "' can be reused.");
    const a = i.createResolver(i.chartOptionScopes(), this.getContext());
    this.platform = new (i.platform || Un(s))(), this.platform.updateConfig(i);
    const r = this.platform.acquireContext(s, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width;
    if (this.id = vs(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new ho(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = ks((d) => this.update(d), a.resizeDelay || 0), this._dataChanges = [], ne[this.id] = this, !r || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    et.listen(this, "complete", vi), et.listen(this, "progress", So), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: s, _aspectRatio: n } = this;
    return z(t) ? e && n ? n : s ? i / s : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Z;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Ve(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return He(this.canvas, this.ctx), this;
  }
  stop() {
    return et.stop(this), this;
  }
  resize(t, e) {
    et.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: e
    } : this._resize(t, e);
  }
  _resize(t, e) {
    const i = this.options, s = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, a = this.platform.getMaximumSize(s, t, e, n), r = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, Ve(this, r, !0) && (this.notifyPlugins("resize", {
      size: a
    }), O(i.onResize, [
      this,
      a
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const e = this.options.scales || {};
    C(e, (i, s) => {
      i.id = s;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((a, r) => (a[r] = !1, a), {});
    let n = [];
    e && (n = n.concat(Object.keys(e).map((a) => {
      const r = e[a], l = le(a, r), h = l === "r", c = l === "x";
      return {
        options: r,
        dposition: h ? "chartArea" : c ? "bottom" : "left",
        dtype: h ? "radialLinear" : c ? "category" : "linear"
      };
    }))), C(n, (a) => {
      const r = a.options, l = r.id, h = le(l, r), c = T(r.type, a.dtype);
      (r.position === void 0 || _i(r.position, h) !== _i(a.dposition)) && (r.position = a.dposition), s[l] = !0;
      let d = null;
      if (l in i && i[l].type === c)
        d = i[l];
      else {
        const u = Z.getScale(c);
        d = new u({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), i[d.id] = d;
      }
      d.init(r, t);
    }), C(s, (a, r) => {
      a || delete i[r];
    }), C(i, (a) => {
      W.configure(this, a, a.options), W.addBox(this, a);
    });
  }
  _updateMetasets() {
    const t = this._metasets, e = this.data.datasets.length, i = t.length;
    if (t.sort((s, n) => s.index - n.index), i > e) {
      for (let s = e; s < i; ++s)
        this._destroyDatasetMeta(s);
      t.splice(e, i - e);
    }
    this._sortedMetasets = t.slice(0).sort(yi("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: e } } = this;
    t.length > e.length && delete this._stacks, t.forEach((i, s) => {
      e.filter((n) => n === i._dataset).length === 0 && this._destroyDatasetMeta(s);
    });
  }
  buildOrUpdateControllers() {
    const t = [], e = this.data.datasets;
    let i, s;
    for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {
      const n = e[i];
      let a = this.getDatasetMeta(i);
      const r = n.type || this.config.type;
      if (a.type && a.type !== r && (this._destroyDatasetMeta(i), a = this.getDatasetMeta(i)), a.type = r, a.indexAxis = n.indexAxis || Pe(r, this.options), a.order = n.order || 0, a.index = i, a.label = "" + n.label, a.visible = this.isDatasetVisible(i), a.controller)
        a.controller.updateIndex(i), a.controller.linkScales();
      else {
        const l = Z.getController(r), { datasetElementType: h, dataElementType: c } = F.datasets[r];
        Object.assign(l, {
          dataElementType: Z.getElement(c),
          datasetElementType: h && Z.getElement(h)
        }), a.controller = new l(this, i), t.push(a.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    C(this.data.datasets, (t, e) => {
      this.getDatasetMeta(e).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const e = this.config;
    e.update();
    const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const n = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let a = 0;
    for (let h = 0, c = this.data.datasets.length; h < c; h++) {
      const { controller: d } = this.getDatasetMeta(h), u = !s && n.indexOf(d) === -1;
      d.buildOrUpdateElements(u), a = Math.max(+d.getMaxOverflow(), a);
    }
    a = this._minPadding = i.layout.autoPadding ? a : 0, this._updateLayout(a), s || C(n, (h) => {
      h.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(yi("z", "_idx"));
    const { _active: r, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : r.length && this._updateHoverStyles(r, r, !0), this.render();
  }
  _updateScales() {
    C(this.scales, (t) => {
      W.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);
    (!We(e, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];
    for (const { method: i, start: s, count: n } of e) {
      const a = i === "_removeElements" ? -n : n;
      Do(t, s, a);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const e = this.data.datasets.length, i = (n) => new Set(t.filter((a) => a[0] === n).map((a, r) => r + "," + a.splice(1).join(","))), s = i(0);
    for (let n = 1; n < e; n++)
      if (!We(s, i(n)))
        return;
    return Array.from(s).map((n) => n.split(",")).map((n) => ({
      method: n[1],
      start: +n[2],
      count: +n[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    W.update(this, this.width, this.height, t);
    const e = this.chartArea, i = e.width <= 0 || e.height <= 0;
    this._layers = [], C(this.boxes, (s) => {
      i && s.position === "chartArea" || (s.configure && s.configure(), this._layers.push(...s._layers()));
    }, this), this._layers.forEach((s, n) => {
      s._idx = n;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let e = 0, i = this.data.datasets.length; e < i; ++e)
        this.getDatasetMeta(e).controller.configure();
      for (let e = 0, i = this.data.datasets.length; e < i; ++e)
        this._updateDataset(e, de(t) ? t({
          datasetIndex: e
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, e) {
    const i = this.getDatasetMeta(t), s = {
      meta: i,
      index: t,
      mode: e,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", s) !== !1 && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (et.has(this) ? this.attached && !et.running(this) && et.start(this) : (this.draw(), vi({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: i, height: s } = this._resizeBeforeDraw;
      this._resize(i, s), this._resizeBeforeDraw = null;
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this._layers;
    for (t = 0; t < e.length && e[t].z <= 0; ++t)
      e[t].draw(this.chartArea);
    for (this._drawDatasets(); t < e.length; ++t)
      e[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const e = this._sortedMetasets, i = [];
    let s, n;
    for (s = 0, n = e.length; s < n; ++s) {
      const a = e[s];
      (!t || a.visible) && i.push(a);
    }
    return i;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let e = t.length - 1; e >= 0; --e)
      this._drawDataset(t[e]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const e = this.ctx, i = t._clip, s = !i.disabled, n = Co(t) || this.chartArea, a = {
      meta: t,
      index: t.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", a) !== !1 && (s && Oe(e, {
      left: i.left === !1 ? 0 : n.left - i.left,
      right: i.right === !1 ? this.width : n.right + i.right,
      top: i.top === !1 ? 0 : n.top - i.top,
      bottom: i.bottom === !1 ? this.height : n.bottom + i.bottom
    }), t.controller.draw(), s && Te(e), a.cancelable = !1, this.notifyPlugins("afterDatasetDraw", a));
  }
  isPointInArea(t) {
    return Yi(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, e, i, s) {
    const n = Mn.modes[e];
    return typeof n == "function" ? n(this, t, i, s) : [];
  }
  getDatasetMeta(t) {
    const e = this.data.datasets[t], i = this._metasets;
    let s = i.filter((n) => n && n._dataset === e).pop();
    return s || (s = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: e && e.order || 0,
      index: t,
      _dataset: e,
      _parsed: [],
      _sorted: !1
    }, i.push(s)), s;
  }
  getContext() {
    return this.$context || (this.$context = mt(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const e = this.data.datasets[t];
    if (!e)
      return !1;
    const i = this.getDatasetMeta(t);
    return typeof i.hidden == "boolean" ? !i.hidden : !e.hidden;
  }
  setDatasetVisibility(t, e) {
    const i = this.getDatasetMeta(t);
    i.hidden = !e;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, e, i) {
    const s = i ? "show" : "hide", n = this.getDatasetMeta(t), a = n.controller._resolveAnimations(void 0, s);
    Bt(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), a.update(n, {
      visible: i
    }), this.update((r) => r.datasetIndex === t ? s : void 0));
  }
  hide(t, e) {
    this._updateVisibility(t, e, !1);
  }
  show(t, e) {
    this._updateVisibility(t, e, !0);
  }
  _destroyDatasetMeta(t) {
    const e = this._metasets[t];
    e && e.controller && e.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, e;
    for (this.stop(), et.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: e } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), He(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete ne[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, e = this.platform, i = (n, a) => {
      e.addEventListener(this, n, a), t[n] = a;
    }, s = (n, a, r) => {
      n.offsetX = a, n.offsetY = r, this._eventHandler(n);
    };
    C(this.options.events, (n) => i(n, s));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, e = this.platform, i = (l, h) => {
      e.addEventListener(this, l, h), t[l] = h;
    }, s = (l, h) => {
      t[l] && (e.removeEventListener(this, l, h), delete t[l]);
    }, n = (l, h) => {
      this.canvas && this.resize(l, h);
    };
    let a;
    const r = () => {
      s("attach", r), this.attached = !0, this.resize(), i("resize", n), i("detach", a);
    };
    a = () => {
      this.attached = !1, s("resize", n), this._stop(), this._resize(0, 0), i("attach", r);
    }, e.isAttached(this.canvas) ? r() : a();
  }
  unbindEvents() {
    C(this._listeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._listeners = {}, C(this._responsiveListeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, e, i) {
    const s = i ? "set" : "remove";
    let n, a, r, l;
    for (e === "dataset" && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), r = 0, l = t.length; r < l; ++r) {
      a = t[r];
      const h = a && this.getDatasetMeta(a.datasetIndex).controller;
      h && h[s + "HoverStyle"](a.element, a.datasetIndex, a.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const e = this._active || [], i = t.map(({ datasetIndex: n, index: a }) => {
      const r = this.getDatasetMeta(n);
      if (!r)
        throw new Error("No dataset found at index " + n);
      return {
        datasetIndex: n,
        element: r.data[a],
        index: a
      };
    });
    !oe(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));
  }
  notifyPlugins(t, e, i) {
    return this._plugins.notify(this, t, e, i);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((e) => e.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, e, i) {
    const s = this.options.hover, n = (l, h) => l.filter((c) => !h.some((d) => c.datasetIndex === d.datasetIndex && c.index === d.index)), a = n(e, t), r = i ? t : n(t, e);
    a.length && this.updateHoverStyle(a, s.mode, !1), r.length && s.mode && this.updateHoverStyle(r, s.mode, !0);
  }
  _eventHandler(t, e) {
    const i = {
      event: t,
      replay: e,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, s = (a) => (a.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", i, s) === !1)
      return;
    const n = this._handleEvent(t, e, i.inChartArea);
    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (n || i.changed) && this.render(), this;
  }
  _handleEvent(t, e, i) {
    const { _active: s = [], options: n } = this, a = e, r = this._getActiveElements(t, s, i, a), l = ws(t), h = Po(t, this._lastEvent, i, l);
    i && (this._lastEvent = null, O(n.onHover, [
      t,
      r,
      this
    ], this), l && O(n.onClick, [
      t,
      r,
      this
    ], this));
    const c = !oe(r, s);
    return (c || e) && (this._active = r, this._updateHoverStyles(r, s, e)), this._lastEvent = h, c;
  }
  _getActiveElements(t, e, i, s) {
    if (t.type === "mouseout")
      return [];
    if (!i)
      return e;
    const n = this.options.hover;
    return this.getElementsAtEventForMode(t, n.mode, n, s);
  }
}
S(ct, "defaults", F), S(ct, "instances", ne), S(ct, "overrides", wt), S(ct, "registry", Z), S(ct, "version", wo), S(ct, "getChart", ki);
function wi() {
  return C(ct.instances, (o) => o._plugins.invalidate());
}
function us(o, t) {
  const { x: e, y: i, base: s, width: n, height: a } = o.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let r, l, h, c, d;
  return o.horizontal ? (d = a / 2, r = Math.min(e, s), l = Math.max(e, s), h = i - d, c = i + d) : (d = n / 2, r = e - d, l = e + d, h = Math.min(i, s), c = Math.max(i, s)), {
    left: r,
    top: h,
    right: l,
    bottom: c
  };
}
function st(o, t, e, i) {
  return o ? 0 : Q(t, e, i);
}
function Lo(o, t, e) {
  const i = o.options.borderWidth, s = o.borderSkipped, n = Rs(i);
  return {
    t: st(s.top, n.top, 0, e),
    r: st(s.right, n.right, 0, t),
    b: st(s.bottom, n.bottom, 0, e),
    l: st(s.left, n.left, 0, t)
  };
}
function Ao(o, t, e) {
  const { enableBorderRadius: i } = o.getProps([
    "enableBorderRadius"
  ]), s = o.options.borderRadius, n = ut(s), a = Math.min(t, e), r = o.borderSkipped, l = i || E(s);
  return {
    topLeft: st(!l || r.top || r.left, n.topLeft, 0, a),
    topRight: st(!l || r.top || r.right, n.topRight, 0, a),
    bottomLeft: st(!l || r.bottom || r.left, n.bottomLeft, 0, a),
    bottomRight: st(!l || r.bottom || r.right, n.bottomRight, 0, a)
  };
}
function Oo(o) {
  const t = us(o), e = t.right - t.left, i = t.bottom - t.top, s = Lo(o, e / 2, i / 2), n = Ao(o, e / 2, i / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: e,
      h: i,
      radius: n
    },
    inner: {
      x: t.left + s.l,
      y: t.top + s.t,
      w: e - s.l - s.r,
      h: i - s.t - s.b,
      radius: {
        topLeft: Math.max(0, n.topLeft - Math.max(s.t, s.l)),
        topRight: Math.max(0, n.topRight - Math.max(s.t, s.r)),
        bottomLeft: Math.max(0, n.bottomLeft - Math.max(s.b, s.l)),
        bottomRight: Math.max(0, n.bottomRight - Math.max(s.b, s.r))
      }
    }
  };
}
function ke(o, t, e, i) {
  const s = t === null, n = e === null, r = o && !(s && n) && us(o, i);
  return r && (s || yt(t, r.left, r.right)) && (n || yt(e, r.top, r.bottom));
}
function To(o) {
  return o.topLeft || o.topRight || o.bottomLeft || o.bottomRight;
}
function zo(o, t) {
  o.rect(t.x, t.y, t.w, t.h);
}
function we(o, t, e = {}) {
  const i = o.x !== e.x ? -t : 0, s = o.y !== e.y ? -t : 0, n = (o.x + o.w !== e.x + e.w ? t : 0) - i, a = (o.y + o.h !== e.y + e.h ? t : 0) - s;
  return {
    x: o.x + i,
    y: o.y + s,
    w: o.w + n,
    h: o.h + a,
    radius: o.radius
  };
}
class Me extends ot {
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: a } = Oo(this), r = To(a.radius) ? Vt : zo;
    t.save(), (a.w !== n.w || a.h !== n.h) && (t.beginPath(), r(t, we(a, e, n)), t.clip(), r(t, we(n, -e, a)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), r(t, we(n, e)), t.fillStyle = s, t.fill(), t.restore();
  }
  inRange(t, e, i) {
    return ke(this, t, e, i);
  }
  inXRange(t, e) {
    return ke(this, t, null, e);
  }
  inYRange(t, e) {
    return ke(this, null, t, e);
  }
  getCenterPoint(t) {
    const { x: e, y: i, base: s, horizontal: n } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: n ? (e + s) / 2 : e,
      y: n ? i : (i + s) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
S(Me, "id", "bar"), S(Me, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), S(Me, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
const Ce = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
], Mi = /* @__PURE__ */ Ce.map((o) => o.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function fs(o) {
  return Ce[o % Ce.length];
}
function gs(o) {
  return Mi[o % Mi.length];
}
function Ro(o, t) {
  return o.borderColor = fs(t), o.backgroundColor = gs(t), ++t;
}
function Fo(o, t) {
  return o.backgroundColor = o.data.map(() => fs(t++)), t;
}
function Eo(o, t) {
  return o.backgroundColor = o.data.map(() => gs(t++)), t;
}
function Io(o) {
  let t = 0;
  return (e, i) => {
    const s = o.getDatasetMeta(i).controller;
    s instanceof Ft ? t = Fo(e, t) : s instanceof ie ? t = Eo(e, t) : s && (t = Ro(e, t));
  };
}
function Si(o) {
  let t;
  for (t in o)
    if (o[t].borderColor || o[t].backgroundColor)
      return !0;
  return !1;
}
var _a = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(o, t, e) {
    if (!e.enabled)
      return;
    const { options: { elements: i }, data: { datasets: s } } = o.config;
    if (!e.forceOverride && (Si(s) || i && Si(i)))
      return;
    const n = Io(o);
    s.forEach(n);
  }
};
const Di = (o, t) => {
  let { boxHeight: e = t, boxWidth: i = t } = o;
  return o.usePointStyle && (e = Math.min(e, t), i = o.pointStyleWidth || Math.min(i, t)), {
    boxWidth: i,
    boxHeight: e,
    itemHeight: Math.max(t, e)
  };
}, Bo = (o, t) => o !== null && t !== null && o.datasetIndex === t.datasetIndex && o.index === t.index;
class Pi extends ot {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e, i) {
    this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let e = O(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (e = e.filter((i) => t.filter(i, this.chart.data))), t.sort && (e = e.sort((i, s) => t.sort(i, s, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;
  }
  fit() {
    const { options: t, ctx: e } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const i = t.labels, s = I(i.font), n = s.size, a = this._computeTitleHeight(), { boxWidth: r, itemHeight: l } = Di(i, n);
    let h, c;
    e.font = s.string, this.isHorizontal() ? (h = this.maxWidth, c = this._fitRows(a, n, r, l) + 10) : (c = this.maxHeight, h = this._fitCols(a, s, r, l) + 10), this.width = Math.min(h, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, e, i, s) {
    const { ctx: n, maxWidth: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], h = this.lineWidths = [
      0
    ], c = s + r;
    let d = t;
    n.textAlign = "left", n.textBaseline = "middle";
    let u = -1, f = -c;
    return this.legendItems.forEach((g, p) => {
      const x = i + e / 2 + n.measureText(g.text).width;
      (p === 0 || h[h.length - 1] + x + 2 * r > a) && (d += c, h[h.length - (p > 0 ? 0 : 1)] = 0, f += c, u++), l[p] = {
        left: 0,
        top: f,
        row: u,
        width: x,
        height: s
      }, h[h.length - 1] += x + r;
    }), d;
  }
  _fitCols(t, e, i, s) {
    const { ctx: n, maxHeight: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], h = this.columnSizes = [], c = a - t;
    let d = r, u = 0, f = 0, g = 0, p = 0;
    return this.legendItems.forEach((x, m) => {
      const { itemWidth: b, itemHeight: _ } = Vo(i, e, n, x, s);
      m > 0 && f + _ + 2 * r > c && (d += u + r, h.push({
        width: u,
        height: f
      }), g += u + r, p++, u = f = 0), l[m] = {
        left: g,
        top: f,
        col: p,
        width: b,
        height: _
      }, u = Math.max(u, b), f += _ + r;
    }), d += u, h.push({
      width: u,
      height: f
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, a = vt(n, this.left, this.width);
    if (this.isHorizontal()) {
      let r = 0, l = V(i, this.left + s, this.right - this.lineWidths[r]);
      for (const h of e)
        r !== h.row && (r = h.row, l = V(i, this.left + s, this.right - this.lineWidths[r])), h.top += this.top + t + s, h.left = a.leftForLtr(a.x(l), h.width), l += h.width + s;
    } else {
      let r = 0, l = V(i, this.top + t + s, this.bottom - this.columnSizes[r].height);
      for (const h of e)
        h.col !== r && (r = h.col, l = V(i, this.top + t + s, this.bottom - this.columnSizes[r].height)), h.top = l, h.left += this.left + s, h.left = a.leftForLtr(a.x(h.left), h.width), l += h.height + s;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      Oe(t, this), this._draw(), Te(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: n, labels: a } = t, r = F.color, l = vt(t.rtl, this.left, this.width), h = I(a.font), { padding: c } = a, d = h.size, u = d / 2;
    let f;
    this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = 0.5, s.font = h.string;
    const { boxWidth: g, boxHeight: p, itemHeight: x } = Di(a, d), m = function(k, w, M) {
      if (isNaN(g) || g <= 0 || isNaN(p) || p < 0)
        return;
      s.save();
      const P = T(M.lineWidth, 1);
      if (s.fillStyle = T(M.fillStyle, r), s.lineCap = T(M.lineCap, "butt"), s.lineDashOffset = T(M.lineDashOffset, 0), s.lineJoin = T(M.lineJoin, "miter"), s.lineWidth = P, s.strokeStyle = T(M.strokeStyle, r), s.setLineDash(T(M.lineDash, [])), a.usePointStyle) {
        const L = {
          radius: p * Math.SQRT2 / 2,
          pointStyle: M.pointStyle,
          rotation: M.rotation,
          borderWidth: P
        }, D = l.xPlus(k, g / 2), A = w + u;
        Fs(s, L, D, A, a.pointStyleWidth && g);
      } else {
        const L = w + Math.max((d - p) / 2, 0), D = l.leftForLtr(k, g), A = ut(M.borderRadius);
        s.beginPath(), Object.values(A).some((j) => j !== 0) ? Vt(s, {
          x: D,
          y: L,
          w: g,
          h: p,
          radius: A
        }) : s.rect(D, L, g, p), s.fill(), P !== 0 && s.stroke();
      }
      s.restore();
    }, b = function(k, w, M) {
      gt(s, M.text, k, w + x / 2, h, {
        strikethrough: M.hidden,
        textAlign: l.textAlign(M.textAlign)
      });
    }, _ = this.isHorizontal(), v = this._computeTitleHeight();
    _ ? f = {
      x: V(n, this.left + c, this.right - i[0]),
      y: this.top + c + v,
      line: 0
    } : f = {
      x: this.left + c,
      y: V(n, this.top + v + c, this.bottom - e[0].height),
      line: 0
    }, qi(this.ctx, t.textDirection);
    const y = x + c;
    this.legendItems.forEach((k, w) => {
      s.strokeStyle = k.fontColor, s.fillStyle = k.fontColor;
      const M = s.measureText(k.text).width, P = l.textAlign(k.textAlign || (k.textAlign = a.textAlign)), L = g + u + M;
      let D = f.x, A = f.y;
      l.setWidth(this.width), _ ? w > 0 && D + L + c > this.right && (A = f.y += y, f.line++, D = f.x = V(n, this.left + c, this.right - i[f.line])) : w > 0 && A + y > this.bottom && (D = f.x = D + e[f.line].width + c, f.line++, A = f.y = V(n, this.top + v + c, this.bottom - e[f.line].height));
      const j = l.x(D);
      if (m(j, A, k), D = Ls(P, D + g + u, _ ? D + L : this.right, t.rtl), b(l.x(D), A, k), _)
        f.x += L + c;
      else if (typeof k.text != "string") {
        const G = h.lineHeight;
        f.y += ps(k, G);
      } else
        f.y += y;
    }), Gi(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, e = t.title, i = I(e.font), s = N(e.padding);
    if (!e.display)
      return;
    const n = vt(t.rtl, this.left, this.width), a = this.ctx, r = e.position, l = i.size / 2, h = s.top + l;
    let c, d = this.left, u = this.width;
    if (this.isHorizontal())
      u = Math.max(...this.lineWidths), c = this.top + h, d = V(t.align, d, this.right - u);
    else {
      const g = this.columnSizes.reduce((p, x) => Math.max(p, x.height), 0);
      c = h + V(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
    }
    const f = V(r, d, d + u);
    a.textAlign = n.textAlign(Ee(r)), a.textBaseline = "middle", a.strokeStyle = e.color, a.fillStyle = e.color, a.font = i.string, gt(a, e.text, f, c, i);
  }
  _computeTitleHeight() {
    const t = this.options.title, e = I(t.font), i = N(t.padding);
    return t.display ? e.lineHeight + i.height : 0;
  }
  _getLegendItemAt(t, e) {
    let i, s, n;
    if (yt(t, this.left, this.right) && yt(e, this.top, this.bottom)) {
      for (n = this.legendHitBoxes, i = 0; i < n.length; ++i)
        if (s = n[i], yt(t, s.left, s.left + s.width) && yt(e, s.top, s.top + s.height))
          return this.legendItems[i];
    }
    return null;
  }
  handleEvent(t) {
    const e = this.options;
    if (!No(t.type, e))
      return;
    const i = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const s = this._hoveredItem, n = Bo(s, i);
      s && !n && O(e.onLeave, [
        t,
        s,
        this
      ], this), this._hoveredItem = i, i && !n && O(e.onHover, [
        t,
        i,
        this
      ], this);
    } else
      i && O(e.onClick, [
        t,
        i,
        this
      ], this);
  }
}
function Vo(o, t, e, i, s) {
  const n = Ho(i, o, t, e), a = Wo(s, i, t.lineHeight);
  return {
    itemWidth: n,
    itemHeight: a
  };
}
function Ho(o, t, e, i) {
  let s = o.text;
  return s && typeof s != "string" && (s = s.reduce((n, a) => n.length > a.length ? n : a)), t + e.size / 2 + i.measureText(s).width;
}
function Wo(o, t, e) {
  let i = o;
  return typeof t.text != "string" && (i = ps(t, e)), i;
}
function ps(o, t) {
  const e = o.text ? o.text.length + 0.5 : 0;
  return t * e;
}
function No(o, t) {
  return !!((o === "mousemove" || o === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (o === "click" || o === "mouseup"));
}
var ya = {
  id: "legend",
  _element: Pi,
  start(o, t, e) {
    const i = o.legend = new Pi({
      ctx: o.ctx,
      options: e,
      chart: o
    });
    W.configure(o, i, e), W.addBox(o, i);
  },
  stop(o) {
    W.removeBox(o, o.legend), delete o.legend;
  },
  beforeUpdate(o, t, e) {
    const i = o.legend;
    W.configure(o, i, e), i.options = e;
  },
  afterUpdate(o) {
    const t = o.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(o, t) {
    t.replay || o.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(o, t, e) {
      const i = t.datasetIndex, s = e.chart;
      s.isDatasetVisible(i) ? (s.hide(i), t.hidden = !0) : (s.show(i), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (o) => o.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(o) {
        const t = o.data.datasets, { labels: { usePointStyle: e, pointStyle: i, textAlign: s, color: n, useBorderRadius: a, borderRadius: r } } = o.legend.options;
        return o._getSortedDatasetMetas().map((l) => {
          const h = l.controller.getStyle(e ? 0 : void 0), c = N(h.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: h.backgroundColor,
            fontColor: n,
            hidden: !l.visible,
            lineCap: h.borderCapStyle,
            lineDash: h.borderDash,
            lineDashOffset: h.borderDashOffset,
            lineJoin: h.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: h.borderColor,
            pointStyle: i || h.pointStyle,
            rotation: h.rotation,
            textAlign: s || h.textAlign,
            borderRadius: a && (r || h.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (o) => o.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (o) => !o.startsWith("on"),
    labels: {
      _scriptable: (o) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(o)
    }
  }
};
class Be extends ot {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e) {
    const i = this.options;
    if (this.left = 0, this.top = 0, !i.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = e;
    const s = X(i.text) ? i.text.length : 1;
    this._padding = N(i.padding);
    const n = s * I(i.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = n : this.width = n;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: e, left: i, bottom: s, right: n, options: a } = this, r = a.align;
    let l = 0, h, c, d;
    return this.isHorizontal() ? (c = V(r, i, n), d = e + t, h = n - i) : (a.position === "left" ? (c = i + t, d = V(r, s, e), l = pt * -0.5) : (c = n - t, d = V(r, e, s), l = pt * 0.5), h = s - e), {
      titleX: c,
      titleY: d,
      maxWidth: h,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, e = this.options;
    if (!e.display)
      return;
    const i = I(e.font), n = i.lineHeight / 2 + this._padding.top, { titleX: a, titleY: r, maxWidth: l, rotation: h } = this._drawArgs(n);
    gt(t, e.text, 0, 0, i, {
      color: e.color,
      maxWidth: l,
      rotation: h,
      textAlign: Ee(e.align),
      textBaseline: "middle",
      translation: [
        a,
        r
      ]
    });
  }
}
function jo(o, t) {
  const e = new Be({
    ctx: o.ctx,
    options: t,
    chart: o
  });
  W.configure(o, e, t), W.addBox(o, e), o.titleBlock = e;
}
var va = {
  id: "title",
  _element: Be,
  start(o, t, e) {
    jo(o, e);
  },
  stop(o) {
    const t = o.titleBlock;
    W.removeBox(o, t), delete o.titleBlock;
  },
  beforeUpdate(o, t, e) {
    const i = o.titleBlock;
    W.configure(o, i, e), i.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Jt = /* @__PURE__ */ new WeakMap();
var ka = {
  id: "subtitle",
  start(o, t, e) {
    const i = new Be({
      ctx: o.ctx,
      options: e,
      chart: o
    });
    W.configure(o, i, e), W.addBox(o, i), Jt.set(o, i);
  },
  stop(o) {
    W.removeBox(o, Jt.get(o)), Jt.delete(o);
  },
  beforeUpdate(o, t, e) {
    const i = Jt.get(o);
    W.configure(o, i, e), i.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const It = {
  average(o) {
    if (!o.length)
      return !1;
    let t, e, i = 0, s = 0, n = 0;
    for (t = 0, e = o.length; t < e; ++t) {
      const a = o[t].element;
      if (a && a.hasValue()) {
        const r = a.tooltipPosition();
        i += r.x, s += r.y, ++n;
      }
    }
    return {
      x: i / n,
      y: s / n
    };
  },
  nearest(o, t) {
    if (!o.length)
      return !1;
    let e = t.x, i = t.y, s = Number.POSITIVE_INFINITY, n, a, r;
    for (n = 0, a = o.length; n < a; ++n) {
      const l = o[n].element;
      if (l && l.hasValue()) {
        const h = l.getCenterPoint(), c = As(t, h);
        c < s && (s = c, r = l);
      }
    }
    if (r) {
      const l = r.tooltipPosition();
      e = l.x, i = l.y;
    }
    return {
      x: e,
      y: i
    };
  }
};
function J(o, t) {
  return t && (X(t) ? Array.prototype.push.apply(o, t) : o.push(t)), o;
}
function it(o) {
  return (typeof o == "string" || o instanceof String) && o.indexOf(`
`) > -1 ? o.split(`
`) : o;
}
function $o(o, t) {
  const { element: e, datasetIndex: i, index: s } = t, n = o.getDatasetMeta(i).controller, { label: a, value: r } = n.getLabelAndValue(s);
  return {
    chart: o,
    label: a,
    parsed: n.getParsed(s),
    raw: o.data.datasets[i].data[s],
    formattedValue: r,
    dataset: n.getDataset(),
    dataIndex: s,
    datasetIndex: i,
    element: e
  };
}
function Ci(o, t) {
  const e = o.chart.ctx, { body: i, footer: s, title: n } = o, { boxWidth: a, boxHeight: r } = t, l = I(t.bodyFont), h = I(t.titleFont), c = I(t.footerFont), d = n.length, u = s.length, f = i.length, g = N(t.padding);
  let p = g.height, x = 0, m = i.reduce((v, y) => v + y.before.length + y.lines.length + y.after.length, 0);
  if (m += o.beforeBody.length + o.afterBody.length, d && (p += d * h.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), m) {
    const v = t.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight;
    p += f * v + (m - f) * l.lineHeight + (m - 1) * t.bodySpacing;
  }
  u && (p += t.footerMarginTop + u * c.lineHeight + (u - 1) * t.footerSpacing);
  let b = 0;
  const _ = function(v) {
    x = Math.max(x, e.measureText(v).width + b);
  };
  return e.save(), e.font = h.string, C(o.title, _), e.font = l.string, C(o.beforeBody.concat(o.afterBody), _), b = t.displayColors ? a + 2 + t.boxPadding : 0, C(i, (v) => {
    C(v.before, _), C(v.lines, _), C(v.after, _);
  }), b = 0, e.font = c.string, C(o.footer, _), e.restore(), x += g.width, {
    width: x,
    height: p
  };
}
function Uo(o, t) {
  const { y: e, height: i } = t;
  return e < i / 2 ? "top" : e > o.height - i / 2 ? "bottom" : "center";
}
function Yo(o, t, e, i) {
  const { x: s, width: n } = i, a = e.caretSize + e.caretPadding;
  if (o === "left" && s + n + a > t.width || o === "right" && s - n - a < 0)
    return !0;
}
function Xo(o, t, e, i) {
  const { x: s, width: n } = e, { width: a, chartArea: { left: r, right: l } } = o;
  let h = "center";
  return i === "center" ? h = s <= (r + l) / 2 ? "left" : "right" : s <= n / 2 ? h = "left" : s >= a - n / 2 && (h = "right"), Yo(h, o, t, e) && (h = "center"), h;
}
function Li(o, t, e) {
  const i = e.yAlign || t.yAlign || Uo(o, e);
  return {
    xAlign: e.xAlign || t.xAlign || Xo(o, t, e, i),
    yAlign: i
  };
}
function Ko(o, t) {
  let { x: e, width: i } = o;
  return t === "right" ? e -= i : t === "center" && (e -= i / 2), e;
}
function qo(o, t, e) {
  let { y: i, height: s } = o;
  return t === "top" ? i += e : t === "bottom" ? i -= s + e : i -= s / 2, i;
}
function Ai(o, t, e, i) {
  const { caretSize: s, caretPadding: n, cornerRadius: a } = o, { xAlign: r, yAlign: l } = e, h = s + n, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = ut(a);
  let g = Ko(t, r);
  const p = qo(t, l, h);
  return l === "center" ? r === "left" ? g += h : r === "right" && (g -= h) : r === "left" ? g -= Math.max(c, u) + s : r === "right" && (g += Math.max(d, f) + s), {
    x: Q(g, 0, i.width - t.width),
    y: Q(p, 0, i.height - t.height)
  };
}
function Zt(o, t, e) {
  const i = N(e.padding);
  return t === "center" ? o.x + o.width / 2 : t === "right" ? o.x + o.width - i.right : o.x + i.left;
}
function Oi(o) {
  return J([], it(o));
}
function Go(o, t, e) {
  return mt(o, {
    tooltip: t,
    tooltipItems: e,
    type: "tooltip"
  });
}
function Ti(o, t) {
  const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return e ? o.override(e) : o;
}
const ms = {
  beforeTitle: tt,
  title(o) {
    if (o.length > 0) {
      const t = o[0], e = t.chart.data.labels, i = e ? e.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (i > 0 && t.dataIndex < i)
        return e[t.dataIndex];
    }
    return "";
  },
  afterTitle: tt,
  beforeBody: tt,
  beforeLabel: tt,
  label(o) {
    if (this && this.options && this.options.mode === "dataset")
      return o.label + ": " + o.formattedValue || o.formattedValue;
    let t = o.dataset.label || "";
    t && (t += ": ");
    const e = o.formattedValue;
    return z(e) || (t += e), t;
  },
  labelColor(o) {
    const e = o.chart.getDatasetMeta(o.datasetIndex).controller.getStyle(o.dataIndex);
    return {
      borderColor: e.borderColor,
      backgroundColor: e.backgroundColor,
      borderWidth: e.borderWidth,
      borderDash: e.borderDash,
      borderDashOffset: e.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(o) {
    const e = o.chart.getDatasetMeta(o.datasetIndex).controller.getStyle(o.dataIndex);
    return {
      pointStyle: e.pointStyle,
      rotation: e.rotation
    };
  },
  afterLabel: tt,
  afterBody: tt,
  beforeFooter: tt,
  footer: tt,
  afterFooter: tt
};
function $(o, t, e, i) {
  const s = o[t].call(e, i);
  return typeof s > "u" ? ms[t].call(e, i) : s;
}
class Le extends ot {
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new ts(this.chart, s);
    return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;
  }
  getContext() {
    return this.$context || (this.$context = Go(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, e) {
    const { callbacks: i } = e, s = $(i, "beforeTitle", this, t), n = $(i, "title", this, t), a = $(i, "afterTitle", this, t);
    let r = [];
    return r = J(r, it(s)), r = J(r, it(n)), r = J(r, it(a)), r;
  }
  getBeforeBody(t, e) {
    return Oi($(e.callbacks, "beforeBody", this, t));
  }
  getBody(t, e) {
    const { callbacks: i } = e, s = [];
    return C(t, (n) => {
      const a = {
        before: [],
        lines: [],
        after: []
      }, r = Ti(i, n);
      J(a.before, it($(r, "beforeLabel", this, n))), J(a.lines, $(r, "label", this, n)), J(a.after, it($(r, "afterLabel", this, n))), s.push(a);
    }), s;
  }
  getAfterBody(t, e) {
    return Oi($(e.callbacks, "afterBody", this, t));
  }
  getFooter(t, e) {
    const { callbacks: i } = e, s = $(i, "beforeFooter", this, t), n = $(i, "footer", this, t), a = $(i, "afterFooter", this, t);
    let r = [];
    return r = J(r, it(s)), r = J(r, it(n)), r = J(r, it(a)), r;
  }
  _createItems(t) {
    const e = this._active, i = this.chart.data, s = [], n = [], a = [];
    let r = [], l, h;
    for (l = 0, h = e.length; l < h; ++l)
      r.push($o(this.chart, e[l]));
    return t.filter && (r = r.filter((c, d, u) => t.filter(c, d, u, i))), t.itemSort && (r = r.sort((c, d) => t.itemSort(c, d, i))), C(r, (c) => {
      const d = Ti(t.callbacks, c);
      s.push($(d, "labelColor", this, c)), n.push($(d, "labelPointStyle", this, c)), a.push($(d, "labelTextColor", this, c));
    }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = a, this.dataPoints = r, r;
  }
  update(t, e) {
    const i = this.options.setContext(this.getContext()), s = this._active;
    let n, a = [];
    if (!s.length)
      this.opacity !== 0 && (n = {
        opacity: 0
      });
    else {
      const r = It[i.position].call(this, s, this._eventPosition);
      a = this._createItems(i), this.title = this.getTitle(a, i), this.beforeBody = this.getBeforeBody(a, i), this.body = this.getBody(a, i), this.afterBody = this.getAfterBody(a, i), this.footer = this.getFooter(a, i);
      const l = this._size = Ci(this, i), h = Object.assign({}, r, l), c = Li(this.chart, i, h), d = Ai(i, h, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, n = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: r.x,
        caretY: r.y
      };
    }
    this._tooltipItems = a, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: e
    });
  }
  drawCaret(t, e, i, s) {
    const n = this.getCaretPosition(t, i, s);
    e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);
  }
  getCaretPosition(t, e, i) {
    const { xAlign: s, yAlign: n } = this, { caretSize: a, cornerRadius: r } = i, { topLeft: l, topRight: h, bottomLeft: c, bottomRight: d } = ut(r), { x: u, y: f } = t, { width: g, height: p } = e;
    let x, m, b, _, v, y;
    return n === "center" ? (v = f + p / 2, s === "left" ? (x = u, m = x - a, _ = v + a, y = v - a) : (x = u + g, m = x + a, _ = v - a, y = v + a), b = x) : (s === "left" ? m = u + Math.max(l, c) + a : s === "right" ? m = u + g - Math.max(h, d) - a : m = this.caretX, n === "top" ? (_ = f, v = _ - a, x = m - a, b = m + a) : (_ = f + p, v = _ + a, x = m + a, b = m - a), y = _), {
      x1: x,
      x2: m,
      x3: b,
      y1: _,
      y2: v,
      y3: y
    };
  }
  drawTitle(t, e, i) {
    const s = this.title, n = s.length;
    let a, r, l;
    if (n) {
      const h = vt(i.rtl, this.x, this.width);
      for (t.x = Zt(this, i.titleAlign, i), e.textAlign = h.textAlign(i.titleAlign), e.textBaseline = "middle", a = I(i.titleFont), r = i.titleSpacing, e.fillStyle = i.titleColor, e.font = a.string, l = 0; l < n; ++l)
        e.fillText(s[l], h.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r, l + 1 === n && (t.y += i.titleMarginBottom - r);
    }
  }
  _drawColorBox(t, e, i, s, n) {
    const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h, boxPadding: c } = n, d = I(n.bodyFont), u = Zt(this, "left", n), f = s.x(u), g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, p = e.y + g;
    if (n.usePointStyle) {
      const x = {
        radius: Math.min(h, l) / 2,
        pointStyle: r.pointStyle,
        rotation: r.rotation,
        borderWidth: 1
      }, m = s.leftForLtr(f, h) + h / 2, b = p + l / 2;
      t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Ye(t, x, m, b), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Ye(t, x, m, b);
    } else {
      t.lineWidth = E(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
      const x = s.leftForLtr(f, h - c), m = s.leftForLtr(s.xPlus(f, 1), h - c - 2), b = ut(a.borderRadius);
      Object.values(b).some((_) => _ !== 0) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, Vt(t, {
        x,
        y: p,
        w: h,
        h: l,
        radius: b
      }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), Vt(t, {
        x: m,
        y: p + 1,
        w: h - 2,
        h: l - 2,
        radius: b
      }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(x, p, h, l), t.strokeRect(x, p, h, l), t.fillStyle = a.backgroundColor, t.fillRect(m, p + 1, h - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[i];
  }
  drawBody(t, e, i) {
    const { body: s } = this, { bodySpacing: n, bodyAlign: a, displayColors: r, boxHeight: l, boxWidth: h, boxPadding: c } = i, d = I(i.bodyFont);
    let u = d.lineHeight, f = 0;
    const g = vt(i.rtl, this.x, this.width), p = function(M) {
      e.fillText(M, g.x(t.x + f), t.y + u / 2), t.y += u + n;
    }, x = g.textAlign(a);
    let m, b, _, v, y, k, w;
    for (e.textAlign = a, e.textBaseline = "middle", e.font = d.string, t.x = Zt(this, x, i), e.fillStyle = i.bodyColor, C(this.beforeBody, p), f = r && x !== "right" ? a === "center" ? h / 2 + c : h + 2 + c : 0, v = 0, k = s.length; v < k; ++v) {
      for (m = s[v], b = this.labelTextColors[v], e.fillStyle = b, C(m.before, p), _ = m.lines, r && _.length && (this._drawColorBox(e, t, v, g, i), u = Math.max(d.lineHeight, l)), y = 0, w = _.length; y < w; ++y)
        p(_[y]), u = d.lineHeight;
      C(m.after, p);
    }
    f = 0, u = d.lineHeight, C(this.afterBody, p), t.y -= n;
  }
  drawFooter(t, e, i) {
    const s = this.footer, n = s.length;
    let a, r;
    if (n) {
      const l = vt(i.rtl, this.x, this.width);
      for (t.x = Zt(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = l.textAlign(i.footerAlign), e.textBaseline = "middle", a = I(i.footerFont), e.fillStyle = i.footerColor, e.font = a.string, r = 0; r < n; ++r)
        e.fillText(s[r], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + i.footerSpacing;
    }
  }
  drawBackground(t, e, i, s) {
    const { xAlign: n, yAlign: a } = this, { x: r, y: l } = t, { width: h, height: c } = i, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: g } = ut(s.cornerRadius);
    e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(r + d, l), a === "top" && this.drawCaret(t, e, i, s), e.lineTo(r + h - u, l), e.quadraticCurveTo(r + h, l, r + h, l + u), a === "center" && n === "right" && this.drawCaret(t, e, i, s), e.lineTo(r + h, l + c - g), e.quadraticCurveTo(r + h, l + c, r + h - g, l + c), a === "bottom" && this.drawCaret(t, e, i, s), e.lineTo(r + f, l + c), e.quadraticCurveTo(r, l + c, r, l + c - f), a === "center" && n === "left" && this.drawCaret(t, e, i, s), e.lineTo(r, l + d), e.quadraticCurveTo(r, l, r + d, l), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();
  }
  _updateAnimationTarget(t) {
    const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y;
    if (s || n) {
      const a = It[t.position].call(this, this._active, this._eventPosition);
      if (!a)
        return;
      const r = this._size = Ci(this, t), l = Object.assign({}, a, this._size), h = Li(e, t, l), c = Ai(t, l, h, e);
      (s._to !== c.x || n._to !== c.y) && (this.xAlign = h.xAlign, this.yAlign = h.yAlign, this.width = r.width, this.height = r.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const e = this.options.setContext(this.getContext());
    let i = this.opacity;
    if (!i)
      return;
    this._updateAnimationTarget(e);
    const s = {
      width: this.width,
      height: this.height
    }, n = {
      x: this.x,
      y: this.y
    };
    i = Math.abs(i) < 1e-3 ? 0 : i;
    const a = N(e.padding), r = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    e.enabled && r && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), qi(t, e.textDirection), n.y += a.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Gi(t, e.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, e) {
    const i = this._active, s = t.map(({ datasetIndex: r, index: l }) => {
      const h = this.chart.getDatasetMeta(r);
      if (!h)
        throw new Error("Cannot find a dataset at index " + r);
      return {
        datasetIndex: r,
        element: h.data[l],
        index: l
      };
    }), n = !oe(i, s), a = this._positionChanged(s, e);
    (n || a) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, e, i = !0) {
    if (e && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const s = this.options, n = this._active || [], a = this._getActiveElements(t, n, e, i), r = this._positionChanged(a, t), l = e || !oe(a, n) || r;
    return l && (this._active = a, (s.enabled || s.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, e))), l;
  }
  _getActiveElements(t, e, i, s) {
    const n = this.options;
    if (t.type === "mouseout")
      return [];
    if (!s)
      return e;
    const a = this.chart.getElementsAtEventForMode(t, n.mode, n, i);
    return n.reverse && a.reverse(), a;
  }
  _positionChanged(t, e) {
    const { caretX: i, caretY: s, options: n } = this, a = It[n.position].call(this, t, e);
    return a !== !1 && (i !== a.x || s !== a.y);
  }
}
S(Le, "positioners", It);
var wa = {
  id: "tooltip",
  _element: Le,
  positioners: It,
  afterInit(o, t, e) {
    e && (o.tooltip = new Le({
      chart: o,
      options: e
    }));
  },
  beforeUpdate(o, t, e) {
    o.tooltip && o.tooltip.initialize(e);
  },
  reset(o, t, e) {
    o.tooltip && o.tooltip.initialize(e);
  },
  afterDraw(o) {
    const t = o.tooltip;
    if (t && t._willRender()) {
      const e = {
        tooltip: t
      };
      if (o.notifyPlugins("beforeTooltipDraw", {
        ...e,
        cancelable: !0
      }) === !1)
        return;
      t.draw(o.ctx), o.notifyPlugins("afterTooltipDraw", e);
    }
  },
  afterEvent(o, t) {
    if (o.tooltip) {
      const e = t.replay;
      o.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (o, t) => t.bodyFont.size,
    boxWidth: (o, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: ms
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (o) => o !== "filter" && o !== "itemSort" && o !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const Jo = (o, t, e, i) => (typeof t == "string" ? (e = o.push(t) - 1, i.unshift({
  index: e,
  label: t
})) : isNaN(t) && (e = null), e);
function Zo(o, t, e, i) {
  const s = o.indexOf(t);
  if (s === -1)
    return Jo(o, t, e, i);
  const n = o.lastIndexOf(t);
  return s !== n ? e : s;
}
const Qo = (o, t) => o === null ? null : Q(Math.round(o), 0, t);
function zi(o) {
  const t = this.getLabels();
  return o >= 0 && o < t.length ? t[o] : o;
}
class Ri extends xt {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const e = this._addedLabels;
    if (e.length) {
      const i = this.getLabels();
      for (const { index: s, label: n } of e)
        i[s] === n && i.splice(s, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, e) {
    if (z(t))
      return null;
    const i = this.getLabels();
    return e = isFinite(e) && i[e] === t ? e : Zo(i, t, T(e, t), this._addedLabels), Qo(e, i.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let { min: i, max: s } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;
  }
  buildTicks() {
    const t = this.min, e = this.max, i = this.options.offset, s = [];
    let n = this.getLabels();
    n = t === 0 && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0);
    for (let a = t; a <= e; a++)
      s.push({
        value: a
      });
    return s;
  }
  getLabelForValue(t) {
    return zi.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
S(Ri, "id", "category"), S(Ri, "defaults", {
  ticks: {
    callback: zi
  }
});
function ta(o, t) {
  const e = [], { bounds: s, step: n, min: a, max: r, precision: l, count: h, maxTicks: c, maxDigits: d, includeBounds: u } = o, f = n || 1, g = c - 1, { min: p, max: x } = t, m = !z(a), b = !z(r), _ = !z(h), v = (x - p) / (d + 1);
  let y = Xe((x - p) / g / f) * f, k, w, M, P;
  if (y < 1e-14 && !m && !b)
    return [
      {
        value: p
      },
      {
        value: x
      }
    ];
  P = Math.ceil(x / y) - Math.floor(p / y), P > g && (y = Xe(P * y / g / f) * f), z(l) || (k = Math.pow(10, l), y = Math.ceil(y * k) / k), s === "ticks" ? (w = Math.floor(p / y) * y, M = Math.ceil(x / y) * y) : (w = p, M = x), m && b && n && Es((r - a) / n, y / 1e3) ? (P = Math.round(Math.min((r - a) / y, c)), y = (r - a) / P, w = a, M = r) : _ ? (w = m ? a : w, M = b ? r : M, P = h - 1, y = (M - w) / P) : (P = (M - w) / y, ge(P, Math.round(P), y / 1e3) ? P = Math.round(P) : P = Math.ceil(P));
  const L = Math.max(Ge(y), Ge(w));
  k = Math.pow(10, z(l) ? L : l), w = Math.round(w * k) / k, M = Math.round(M * k) / k;
  let D = 0;
  for (m && (u && w !== a ? (e.push({
    value: a
  }), w < a && D++, ge(Math.round((w + D * y) * k) / k, a, Fi(a, v, o)) && D++) : w < a && D++); D < P; ++D)
    e.push({
      value: Math.round((w + D * y) * k) / k
    });
  return b && u && M !== r ? e.length && ge(e[e.length - 1].value, r, Fi(r, v, o)) ? e[e.length - 1].value = r : e.push({
    value: r
  }) : (!b || M === r) && e.push({
    value: M
  }), e;
}
function Fi(o, t, { horizontal: e, minRotation: i }) {
  const s = q(i), n = (e ? Math.sin(s) : Math.cos(s)) || 1e-3, a = 0.75 * t * ("" + o).length;
  return Math.min(t / n, a);
}
class he extends xt {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    return z(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();
    let { min: s, max: n } = this;
    const a = (l) => s = e ? s : l, r = (l) => n = i ? n : l;
    if (t) {
      const l = nt(s), h = nt(n);
      l < 0 && h < 0 ? r(0) : l > 0 && h > 0 && a(0);
    }
    if (s === n) {
      let l = n === 0 ? 1 : Math.abs(n * 0.05);
      r(n + l), t || a(s - l);
    }
    this.min = s, this.max = n;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: e, stepSize: i } = t, s;
    return i ? (s = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), e = e || 11), e && (s = Math.min(e, s)), s;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, e = t.ticks;
    let i = this.getTickLimit();
    i = Math.max(2, i);
    const s = {
      maxTicks: i,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: e.precision,
      step: e.stepSize,
      count: e.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: e.minRotation || 0,
      includeBounds: e.includeBounds !== !1
    }, n = this._range || this, a = ta(s, n);
    return t.bounds === "ticks" && Xi(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
  }
  configure() {
    const t = this.ticks;
    let e = this.min, i = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const s = (i - e) / Math.max(t.length - 1, 1) / 2;
      e -= s, i += s;
    }
    this._startValue = e, this._endValue = i, this._valueRange = i - e;
  }
  getLabelForValue(t) {
    return ue(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Ei extends he {
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = H(t) ? t : 0, this.max = H(e) ? e : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), e = t ? this.width : this.height, i = q(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || 1e-3, n = this._resolveTickFontOptions(0);
    return Math.ceil(e / Math.min(40, n.lineHeight / s));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
S(Ei, "id", "linear"), S(Ei, "defaults", {
  ticks: {
    callback: ze.formatters.numeric
  }
});
const Wt = (o) => Math.floor(Rt(o)), lt = (o, t) => Math.pow(10, Wt(o) + t);
function Ii(o) {
  return o / Math.pow(10, Wt(o)) === 1;
}
function Bi(o, t, e) {
  const i = Math.pow(10, e), s = Math.floor(o / i);
  return Math.ceil(t / i) - s;
}
function ea(o, t) {
  const e = t - o;
  let i = Wt(e);
  for (; Bi(o, t, i) > 10; )
    i++;
  for (; Bi(o, t, i) < 10; )
    i--;
  return Math.min(i, Wt(o));
}
function ia(o, { min: t, max: e }) {
  t = Y(o.min, t);
  const i = [], s = Wt(t);
  let n = ea(t, e), a = n < 0 ? Math.pow(10, Math.abs(n)) : 1;
  const r = Math.pow(10, n), l = s > n ? Math.pow(10, s) : 0, h = Math.round((t - l) * a) / a, c = Math.floor((t - l) / r / 10) * r * 10;
  let d = Math.floor((h - c) / Math.pow(10, n)), u = Y(o.min, Math.round((l + c + d * Math.pow(10, n)) * a) / a);
  for (; u < e; )
    i.push({
      value: u,
      major: Ii(u),
      significand: d
    }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (n++, d = 2, a = n >= 0 ? 1 : a), u = Math.round((l + c + d * Math.pow(10, n)) * a) / a;
  const f = Y(o.max, u);
  return i.push({
    value: f,
    major: Ii(f),
    significand: d
  }), i;
}
class Vi extends xt {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    const i = he.prototype.parse.apply(this, [
      t,
      e
    ]);
    if (i === 0) {
      this._zero = !0;
      return;
    }
    return H(i) && i > 0 ? i : null;
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = H(t) ? Math.max(0, t) : null, this.max = H(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !H(this._userMin) && (this.min = t === lt(this.min, 0) ? lt(this.min, -1) : lt(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let i = this.min, s = this.max;
    const n = (r) => i = t ? i : r, a = (r) => s = e ? s : r;
    i === s && (i <= 0 ? (n(1), a(10)) : (n(lt(i, -1)), a(lt(s, 1)))), i <= 0 && n(lt(s, -1)), s <= 0 && a(lt(i, 1)), this.min = i, this.max = s;
  }
  buildTicks() {
    const t = this.options, e = {
      min: this._userMin,
      max: this._userMax
    }, i = ia(e, this);
    return t.bounds === "ticks" && Xi(i, this, "value"), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i;
  }
  getLabelForValue(t) {
    return t === void 0 ? "0" : ue(t, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const t = this.min;
    super.configure(), this._startValue = Rt(t), this._valueRange = Rt(this.max) - Rt(t);
  }
  getPixelForValue(t) {
    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Rt(t) - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    const e = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + e * this._valueRange);
  }
}
S(Vi, "id", "logarithmic"), S(Vi, "defaults", {
  ticks: {
    callback: ze.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function Ae(o) {
  const t = o.ticks;
  if (t.display && o.display) {
    const e = N(t.backdropPadding);
    return T(t.font && t.font.size, F.font.size) + e.height;
  }
  return 0;
}
function sa(o, t, e) {
  return e = X(e) ? e : [
    e
  ], {
    w: Is(o, t.string, e),
    h: e.length * t.lineHeight
  };
}
function Hi(o, t, e, i, s) {
  return o === i || o === s ? {
    start: t - e / 2,
    end: t + e / 2
  } : o < i || o > s ? {
    start: t - e,
    end: t
  } : {
    start: t,
    end: t + e
  };
}
function na(o) {
  const t = {
    l: o.left + o._padding.left,
    r: o.right - o._padding.right,
    t: o.top + o._padding.top,
    b: o.bottom - o._padding.bottom
  }, e = Object.assign({}, t), i = [], s = [], n = o._pointLabels.length, a = o.options.pointLabels, r = a.centerPointLabels ? pt / n : 0;
  for (let l = 0; l < n; l++) {
    const h = a.setContext(o.getPointLabelContext(l));
    s[l] = h.padding;
    const c = o.getPointPosition(l, o.drawingArea + s[l], r), d = I(h.font), u = sa(o.ctx, d, o._pointLabels[l]);
    i[l] = u;
    const f = Re(o.getIndexAngle(l) + r), g = Math.round(Fe(f)), p = Hi(g, c.x, u.w, 0, 180), x = Hi(g, c.y, u.h, 90, 270);
    oa(e, t, f, p, x);
  }
  o.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), o._pointLabelItems = aa(o, i, s);
}
function oa(o, t, e, i, s) {
  const n = Math.abs(Math.sin(e)), a = Math.abs(Math.cos(e));
  let r = 0, l = 0;
  i.start < t.l ? (r = (t.l - i.start) / n, o.l = Math.min(o.l, t.l - r)) : i.end > t.r && (r = (i.end - t.r) / n, o.r = Math.max(o.r, t.r + r)), s.start < t.t ? (l = (t.t - s.start) / a, o.t = Math.min(o.t, t.t - l)) : s.end > t.b && (l = (s.end - t.b) / a, o.b = Math.max(o.b, t.b + l));
}
function aa(o, t, e) {
  const i = [], s = o._pointLabels.length, n = o.options, a = Ae(n) / 2, r = o.drawingArea, l = n.pointLabels.centerPointLabels ? pt / s : 0;
  for (let h = 0; h < s; h++) {
    const c = o.getPointPosition(h, r + a + e[h], l), d = Math.round(Fe(Re(c.angle + Mt))), u = t[h], f = ha(c.y, u.h, d), g = ra(d), p = la(c.x, u.w, g);
    i.push({
      x: c.x,
      y: f,
      textAlign: g,
      left: p,
      top: f,
      right: p + u.w,
      bottom: f + u.h
    });
  }
  return i;
}
function ra(o) {
  return o === 0 || o === 180 ? "center" : o < 180 ? "left" : "right";
}
function la(o, t, e) {
  return e === "right" ? o -= t : e === "center" && (o -= t / 2), o;
}
function ha(o, t, e) {
  return e === 90 || e === 270 ? o -= t / 2 : (e > 270 || e < 90) && (o -= t), o;
}
function ca(o, t) {
  const { ctx: e, options: { pointLabels: i } } = o;
  for (let s = t - 1; s >= 0; s--) {
    const n = i.setContext(o.getPointLabelContext(s)), a = I(n.font), { x: r, y: l, textAlign: h, left: c, top: d, right: u, bottom: f } = o._pointLabelItems[s], { backdropColor: g } = n;
    if (!z(g)) {
      const p = ut(n.borderRadius), x = N(n.backdropPadding);
      e.fillStyle = g;
      const m = c - x.left, b = d - x.top, _ = u - c + x.width, v = f - d + x.height;
      Object.values(p).some((y) => y !== 0) ? (e.beginPath(), Vt(e, {
        x: m,
        y: b,
        w: _,
        h: v,
        radius: p
      }), e.fill()) : e.fillRect(m, b, _, v);
    }
    gt(e, o._pointLabels[s], r, l + a.lineHeight / 2, a, {
      color: n.color,
      textAlign: h,
      textBaseline: "middle"
    });
  }
}
function xs(o, t, e, i) {
  const { ctx: s } = o;
  if (e)
    s.arc(o.xCenter, o.yCenter, t, 0, dt);
  else {
    let n = o.getPointPosition(0, t);
    s.moveTo(n.x, n.y);
    for (let a = 1; a < i; a++)
      n = o.getPointPosition(a, t), s.lineTo(n.x, n.y);
  }
}
function da(o, t, e, i, s) {
  const n = o.ctx, a = t.circular, { color: r, lineWidth: l } = t;
  !a && !i || !r || !l || e < 0 || (n.save(), n.strokeStyle = r, n.lineWidth = l, n.setLineDash(s.dash), n.lineDashOffset = s.dashOffset, n.beginPath(), xs(o, e, a, i), n.closePath(), n.stroke(), n.restore());
}
function ua(o, t, e) {
  return mt(o, {
    label: e,
    index: t,
    type: "pointLabel"
  });
}
class Qt extends he {
  constructor(t) {
    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const t = this._padding = N(Ae(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;
    this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!1);
    this.min = H(t) && !isNaN(t) ? t : 0, this.max = H(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Ae(this.options));
  }
  generateTickLabels(t) {
    he.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, i) => {
      const s = O(this.options.pointLabels.callback, [
        e,
        i
      ], this);
      return s || s === 0 ? s : "";
    }).filter((e, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const t = this.options;
    t.display && t.pointLabels.display ? na(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(t, e, i, s) {
    this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));
  }
  getIndexAngle(t) {
    const e = dt / (this._pointLabels.length || 1), i = this.options.startAngle || 0;
    return Re(t * e + q(i));
  }
  getDistanceFromCenterForValue(t) {
    if (z(t))
      return NaN;
    const e = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;
  }
  getValueForDistanceFromCenter(t) {
    if (z(t))
      return NaN;
    const e = t / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - e : this.min + e;
  }
  getPointLabelContext(t) {
    const e = this._pointLabels || [];
    if (t >= 0 && t < e.length) {
      const i = e[t];
      return ua(this.getContext(), t, i);
    }
  }
  getPointPosition(t, e, i = 0) {
    const s = this.getIndexAngle(t) - Mt + i;
    return {
      x: Math.cos(s) * e + this.xCenter,
      y: Math.sin(s) * e + this.yCenter,
      angle: s
    };
  }
  getPointPositionForValue(t, e) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  getPointLabelPosition(t) {
    const { left: e, top: i, right: s, bottom: n } = this._pointLabelItems[t];
    return {
      left: e,
      top: i,
      right: s,
      bottom: n
    };
  }
  drawBackground() {
    const { backgroundColor: t, grid: { circular: e } } = this.options;
    if (t) {
      const i = this.ctx;
      i.save(), i.beginPath(), xs(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();
    }
  }
  drawGrid() {
    const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, a = this._pointLabels.length;
    let r, l, h;
    if (e.pointLabels.display && ca(this, a), s.display && this.ticks.forEach((c, d) => {
      if (d !== 0) {
        l = this.getDistanceFromCenterForValue(c.value);
        const u = this.getContext(d), f = s.setContext(u), g = n.setContext(u);
        da(this, f, l, a, g);
      }
    }), i.display) {
      for (t.save(), r = a - 1; r >= 0; r--) {
        const c = i.setContext(this.getPointLabelContext(r)), { color: d, lineWidth: u } = c;
        !u || !d || (t.lineWidth = u, t.strokeStyle = d, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, l = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), h = this.getPointPosition(r, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(h.x, h.y), t.stroke());
      }
      t.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const t = this.ctx, e = this.options, i = e.ticks;
    if (!i.display)
      return;
    const s = this.getIndexAngle(0);
    let n, a;
    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((r, l) => {
      if (l === 0 && !e.reverse)
        return;
      const h = i.setContext(this.getContext(l)), c = I(h.font);
      if (n = this.getDistanceFromCenterForValue(this.ticks[l].value), h.showLabelBackdrop) {
        t.font = c.string, a = t.measureText(r.label).width, t.fillStyle = h.backdropColor;
        const d = N(h.backdropPadding);
        t.fillRect(-a / 2 - d.left, -n - c.size / 2 - d.top, a + d.width, c.size + d.height);
      }
      gt(t, r.label, 0, -n, c, {
        color: h.color
      });
    }), t.restore();
  }
  drawTitle() {
  }
}
S(Qt, "id", "radialLinear"), S(Qt, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: ze.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(t) {
      return t;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), S(Qt, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), S(Qt, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const fe = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, U = /* @__PURE__ */ Object.keys(fe);
function fa(o, t) {
  return o - t;
}
function Wi(o, t) {
  if (z(t))
    return null;
  const e = o._adapter, { parser: i, round: s, isoWeekday: n } = o._parseOpts;
  let a = t;
  return typeof i == "function" && (a = i(a)), H(a) || (a = typeof i == "string" ? e.parse(a, i) : e.parse(a)), a === null ? null : (s && (a = s === "week" && (ae(n) || n === !0) ? e.startOf(a, "isoWeek", n) : e.startOf(a, s)), +a);
}
function Ni(o, t, e, i) {
  const s = U.length;
  for (let n = U.indexOf(o); n < s - 1; ++n) {
    const a = fe[U[n]], r = a.steps ? a.steps : Number.MAX_SAFE_INTEGER;
    if (a.common && Math.ceil((e - t) / (r * a.size)) <= i)
      return U[n];
  }
  return U[s - 1];
}
function ga(o, t, e, i, s) {
  for (let n = U.length - 1; n >= U.indexOf(e); n--) {
    const a = U[n];
    if (fe[a].common && o._adapter.diff(s, i, a) >= t - 1)
      return a;
  }
  return U[e ? U.indexOf(e) : 0];
}
function pa(o) {
  for (let t = U.indexOf(o) + 1, e = U.length; t < e; ++t)
    if (fe[U[t]].common)
      return U[t];
}
function ji(o, t, e) {
  if (!e)
    o[t] = !0;
  else if (e.length) {
    const { lo: i, hi: s } = $s(e, t), n = e[i] >= t ? e[i] : e[s];
    o[n] = !0;
  }
}
function ma(o, t, e, i) {
  const s = o._adapter, n = +s.startOf(t[0].value, i), a = t[t.length - 1].value;
  let r, l;
  for (r = n; r <= a; r = +s.add(r, 1, i))
    l = e[r], l >= 0 && (t[l].major = !0);
  return t;
}
function $i(o, t, e) {
  const i = [], s = {}, n = t.length;
  let a, r;
  for (a = 0; a < n; ++a)
    r = t[a], s[r] = a, i.push({
      value: r,
      major: !1
    });
  return n === 0 || !e ? i : ma(o, i, s, e);
}
class ce extends xt {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, e = {}) {
    const i = t.time || (t.time = {}), s = this._adapter = new _n._date(t.adapters.date);
    s.init(e), ee(i.displayFormats, s.formats()), this._parseOpts = {
      parser: i.parser,
      round: i.round,
      isoWeekday: i.isoWeekday
    }, super.init(t), this._normalized = e.normalized;
  }
  parse(t, e) {
    return t === void 0 ? null : Wi(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, e = this._adapter, i = t.time.unit || "day";
    let { min: s, max: n, minDefined: a, maxDefined: r } = this.getUserBounds();
    function l(h) {
      !a && !isNaN(h.min) && (s = Math.min(s, h.min)), !r && !isNaN(h.max) && (n = Math.max(n, h.max));
    }
    (!a || !r) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), s = H(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = H(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    return t.length && (e = t[0], i = t[t.length - 1]), {
      min: e,
      max: i
    };
  }
  buildTicks() {
    const t = this.options, e = t.time, i = t.ticks, s = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
    const n = this.min, a = this.max, r = Bs(s, n, a);
    return this._unit = e.unit || (i.autoSkip ? Ni(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : ga(this, r.length, e.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : pa(this._unit), this.initOffsets(s), t.reverse && r.reverse(), $i(this, r, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let e = 0, i = 0, s, n;
    this.options.offset && t.length && (s = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - s : e = (this.getDecimalForValue(t[1]) - s) / 2, n = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? i = n : i = (n - this.getDecimalForValue(t[t.length - 2])) / 2);
    const a = t.length < 3 ? 0.5 : 0.25;
    e = Q(e, 0, a), i = Q(i, 0, a), this._offsets = {
      start: e,
      end: i,
      factor: 1 / (e + 1 + i)
    };
  }
  _generate() {
    const t = this._adapter, e = this.min, i = this.max, s = this.options, n = s.time, a = n.unit || Ni(n.minUnit, e, i, this._getLabelCapacity(e)), r = T(s.ticks.stepSize, 1), l = a === "week" ? n.isoWeekday : !1, h = ae(l) || l === !0, c = {};
    let d = e, u, f;
    if (h && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, h ? "day" : a), t.diff(i, e, a) > 1e5 * r)
      throw new Error(e + " and " + i + " are too far apart with stepSize of " + r + " " + a);
    const g = s.ticks.source === "data" && this.getDataTimestamps();
    for (u = d, f = 0; u < i; u = +t.add(u, r, a), f++)
      ji(c, u, g);
    return (u === i || s.bounds === "ticks" || f === 1) && ji(c, u, g), Object.keys(c).sort((p, x) => p - x).map((p) => +p);
  }
  getLabelForValue(t) {
    const e = this._adapter, i = this.options.time;
    return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);
  }
  _tickFormatFunction(t, e, i, s) {
    const n = this.options, a = n.ticks.callback;
    if (a)
      return O(a, [
        t,
        e,
        i
      ], this);
    const r = n.time.displayFormats, l = this._unit, h = this._majorUnit, c = l && r[l], d = h && r[h], u = i[e], f = h && d && u && u.major;
    return this._adapter.format(t, s || (f ? d : c));
  }
  generateTickLabels(t) {
    let e, i, s;
    for (e = 0, i = t.length; e < i; ++e)
      s = t[e], s.label = this._tickFormatFunction(s.value, e, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const e = this._offsets, i = this.getDecimalForValue(t);
    return this.getPixelForDecimal((e.start + i) * e.factor);
  }
  getValueForPixel(t) {
    const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;
    return this.min + i * (this.max - this.min);
  }
  _getLabelSize(t) {
    const e = this.options.ticks, i = this.ctx.measureText(t).width, s = q(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), a = Math.sin(s), r = this._resolveTickFontOptions(0).size;
    return {
      w: i * n + r * a,
      h: i * a + r * n
    };
  }
  _getLabelCapacity(t) {
    const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, $i(this, [
      t
    ], this._majorUnit), s), a = this._getLabelSize(n), r = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1;
    return r > 0 ? r : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], e, i;
    if (t.length)
      return t;
    const s = this.getMatchingVisibleMetas();
    if (this._normalized && s.length)
      return this._cache.data = s[0].controller.getAllParsedValues(this);
    for (e = 0, i = s.length; e < i; ++e)
      t = t.concat(s[e].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let e, i;
    if (t.length)
      return t;
    const s = this.getLabels();
    for (e = 0, i = s.length; e < i; ++e)
      t.push(Wi(this, s[e]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Ji(t.sort(fa));
  }
}
S(ce, "id", "time"), S(ce, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function te(o, t, e) {
  let i = 0, s = o.length - 1, n, a, r, l;
  e ? (t >= o[i].pos && t <= o[s].pos && ({ lo: i, hi: s } = Se(o, "pos", t)), { pos: n, time: r } = o[i], { pos: a, time: l } = o[s]) : (t >= o[i].time && t <= o[s].time && ({ lo: i, hi: s } = Se(o, "time", t)), { time: n, pos: r } = o[i], { time: a, pos: l } = o[s]);
  const h = a - n;
  return h ? r + (l - r) * (t - n) / h : r;
}
class Ui extends ce {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);
    this._minPos = te(e, this.min), this._tableRange = te(e, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: e, max: i } = this, s = [], n = [];
    let a, r, l, h, c;
    for (a = 0, r = t.length; a < r; ++a)
      h = t[a], h >= e && h <= i && s.push(h);
    if (s.length < 2)
      return [
        {
          time: e,
          pos: 0
        },
        {
          time: i,
          pos: 1
        }
      ];
    for (a = 0, r = s.length; a < r; ++a)
      c = s[a + 1], l = s[a - 1], h = s[a], Math.round((c + l) / 2) !== h && n.push({
        time: h,
        pos: a / (r - 1)
      });
    return n;
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const e = this.getDataTimestamps(), i = this.getLabelTimestamps();
    return e.length && i.length ? t = this.normalize(e.concat(i)) : t = e.length ? e : i, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (te(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;
    return te(this._table, i * this._tableRange + this._minPos, !0);
  }
}
S(Ui, "id", "timeseries"), S(Ui, "defaults", ce.defaults);
export {
  qs as Animation,
  ts as Animations,
  be as BarController,
  Me as BarElement,
  os as BasePlatform,
  Tn as BasicPlatform,
  Ri as CategoryScale,
  ct as Chart,
  _a as Colors,
  ft as DatasetController,
  $n as DomPlatform,
  Ft as DoughnutController,
  ot as Element,
  Mn as Interaction,
  ya as Legend,
  Ei as LinearScale,
  Vi as LogarithmicScale,
  ie as PolarAreaController,
  Qt as RadialLinearScale,
  xt as Scale,
  ka as SubTitle,
  Da as Ticks,
  ce as TimeScale,
  Ui as TimeSeriesScale,
  va as Title,
  wa as Tooltip,
  _n as _adapters,
  Un as _detectPlatform,
  et as animator,
  Pa as defaults,
  W as layouts,
  Z as registry
};
//# sourceMappingURL=chart.js.map

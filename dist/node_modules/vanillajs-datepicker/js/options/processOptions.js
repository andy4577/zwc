import { pushUnique as L, hasProperty as I } from "../lib/utils.js";
import { dateValue as B, regularizeDate as k } from "../lib/date.js";
import { reFormatTokens as H, parseDate as y } from "../lib/date-format.js";
import { parseHTML as v } from "../lib/dom.js";
import M from "./defaultOptions.js";
const {
  language: O,
  format: j,
  weekStart: E
} = M;
function N(n, d) {
  return n.length < 6 && d >= 0 && d < 7 ? L(n, d) : n;
}
function W(n) {
  return (n + 6) % 7;
}
function A(n, d, e, a) {
  const s = y(n, d, e);
  return s !== void 0 ? s : a;
}
function V(n, d, e = 3) {
  const a = parseInt(n, 10);
  return a >= 0 && a <= e ? a : d;
}
function C(n, d) {
  const e = Object.assign({}, n), a = {}, s = d.constructor.locales, T = d.rangeSideIndex;
  let {
    format: m,
    language: p,
    locale: f,
    maxDate: w,
    maxView: c,
    minDate: g,
    pickLevel: o,
    startView: S,
    weekStart: h
  } = d.config || {};
  if (e.language) {
    let t;
    if (e.language !== p && (s[e.language] ? t = e.language : (t = e.language.split("-")[0], s[t] === void 0 && (t = !1))), delete e.language, t) {
      p = a.language = t;
      const i = f || s[O];
      f = Object.assign({
        format: j,
        weekStart: E
      }, s[O]), p !== O && Object.assign(f, s[p]), a.locale = f, m === i.format && (m = a.format = f.format), h === i.weekStart && (h = a.weekStart = f.weekStart, a.weekEnd = W(f.weekStart));
    }
  }
  if (e.format) {
    const t = typeof e.format.toDisplay == "function", i = typeof e.format.toValue == "function", x = H.test(e.format);
    (t && i || x) && (m = a.format = e.format), delete e.format;
  }
  let b = o;
  e.pickLevel !== void 0 && (b = V(e.pickLevel, 2), delete e.pickLevel), b !== o && (b > o && (e.minDate === void 0 && (e.minDate = g), e.maxDate === void 0 && (e.maxDate = w)), e.datesDisabled || (e.datesDisabled = []), o = a.pickLevel = b);
  let r = g, l = w;
  if (e.minDate !== void 0) {
    const t = B(0, 0, 1);
    r = e.minDate === null ? t : A(e.minDate, m, f, r), r !== t && (r = k(r, o, !1)), delete e.minDate;
  }
  if (e.maxDate !== void 0 && (l = e.maxDate === null ? void 0 : A(e.maxDate, m, f, l), l !== void 0 && (l = k(l, o, !0)), delete e.maxDate), l < r ? (g = a.minDate = l, w = a.maxDate = r) : (g !== r && (g = a.minDate = r), w !== l && (w = a.maxDate = l)), e.datesDisabled && (a.datesDisabled = e.datesDisabled.reduce((t, i) => {
    const x = y(i, m, f);
    return x !== void 0 ? L(t, k(x, o, T)) : t;
  }, []), delete e.datesDisabled), e.defaultViewDate !== void 0) {
    const t = y(e.defaultViewDate, m, f);
    t !== void 0 && (a.defaultViewDate = t), delete e.defaultViewDate;
  }
  if (e.weekStart !== void 0) {
    const t = Number(e.weekStart) % 7;
    isNaN(t) || (h = a.weekStart = t, a.weekEnd = W(t)), delete e.weekStart;
  }
  if (e.daysOfWeekDisabled && (a.daysOfWeekDisabled = e.daysOfWeekDisabled.reduce(N, []), delete e.daysOfWeekDisabled), e.daysOfWeekHighlighted && (a.daysOfWeekHighlighted = e.daysOfWeekHighlighted.reduce(N, []), delete e.daysOfWeekHighlighted), e.maxNumberOfDates !== void 0) {
    const t = parseInt(e.maxNumberOfDates, 10);
    t >= 0 && (a.maxNumberOfDates = t, a.multidate = t !== 1), delete e.maxNumberOfDates;
  }
  e.dateDelimiter && (a.dateDelimiter = String(e.dateDelimiter), delete e.dateDelimiter);
  let D = c;
  e.maxView !== void 0 && (D = V(e.maxView, c), delete e.maxView), D = o > D ? o : D, D !== c && (c = a.maxView = D);
  let u = S;
  if (e.startView !== void 0 && (u = V(e.startView, u), delete e.startView), u < o ? u = o : u > c && (u = c), u !== S && (a.startView = u), e.prevArrow) {
    const t = v(e.prevArrow);
    t.childNodes.length > 0 && (a.prevArrow = t.childNodes), delete e.prevArrow;
  }
  if (e.nextArrow) {
    const t = v(e.nextArrow);
    t.childNodes.length > 0 && (a.nextArrow = t.childNodes), delete e.nextArrow;
  }
  if (e.disableTouchKeyboard !== void 0 && (a.disableTouchKeyboard = "ontouchstart" in document && !!e.disableTouchKeyboard, delete e.disableTouchKeyboard), e.orientation) {
    const t = e.orientation.toLowerCase().split(/\s+/g);
    a.orientation = {
      x: t.find((i) => i === "left" || i === "right") || "auto",
      y: t.find((i) => i === "top" || i === "bottom") || "auto"
    }, delete e.orientation;
  }
  if (e.todayBtnMode !== void 0) {
    switch (e.todayBtnMode) {
      case 0:
      case 1:
        a.todayBtnMode = e.todayBtnMode;
    }
    delete e.todayBtnMode;
  }
  return Object.keys(e).forEach((t) => {
    e[t] !== void 0 && I(M, t) && (a[t] = e[t]);
  }), a;
}
export {
  C as default
};
//# sourceMappingURL=processOptions.js.map

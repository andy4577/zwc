import { stripTime as y, today as h } from "./date.js";
import { lastItemOf as w } from "./utils.js";
const d = /dd?|DD?|mm?|MM?|yy?(?:yy)?/, M = /[\s!-/:-@[-`{-~年月日]+/;
let m = {};
const g = {
  y(e, t) {
    return new Date(e).setFullYear(parseInt(t, 10));
  },
  m(e, t, n) {
    const r = new Date(e);
    let u = parseInt(t, 10) - 1;
    if (isNaN(u)) {
      if (!t)
        return NaN;
      const o = t.toLowerCase(), a = (f) => f.toLowerCase().startsWith(o);
      if (u = n.monthsShort.findIndex(a), u < 0 && (u = n.months.findIndex(a)), u < 0)
        return NaN;
    }
    return r.setMonth(u), r.getMonth() !== l(u) ? r.setDate(0) : r.getTime();
  },
  d(e, t) {
    return new Date(e).setDate(parseInt(t, 10));
  }
}, F = {
  d(e) {
    return e.getDate();
  },
  dd(e) {
    return p(e.getDate(), 2);
  },
  D(e, t) {
    return t.daysShort[e.getDay()];
  },
  DD(e, t) {
    return t.days[e.getDay()];
  },
  m(e) {
    return e.getMonth() + 1;
  },
  mm(e) {
    return p(e.getMonth() + 1, 2);
  },
  M(e, t) {
    return t.monthsShort[e.getMonth()];
  },
  MM(e, t) {
    return t.months[e.getMonth()];
  },
  y(e) {
    return e.getFullYear();
  },
  yy(e) {
    return p(e.getFullYear(), 2).slice(-2);
  },
  yyyy(e) {
    return p(e.getFullYear(), 4);
  }
};
function l(e) {
  return e > -1 ? e % 12 : l(e + 12);
}
function p(e, t) {
  return e.toString().padStart(t, "0");
}
function N(e) {
  if (typeof e != "string")
    throw new Error("Invalid date format.");
  if (e in m)
    return m[e];
  const t = e.split(d), n = e.match(new RegExp(d, "g"));
  if (t.length === 0 || !n)
    throw new Error("Invalid date format.");
  const r = n.map((o) => F[o]), u = Object.keys(g).reduce((o, a) => (n.find((s) => s[0] !== "D" && s[0].toLowerCase() === a) && o.push(a), o), []);
  return m[e] = {
    parser(o, a) {
      const f = o.split(M).reduce((s, i, c) => {
        if (i.length > 0 && n[c]) {
          const D = n[c][0];
          D === "M" ? s.m = i : D !== "D" && (s[D] = i);
        }
        return s;
      }, {});
      return u.reduce((s, i) => {
        const c = g[i](s, f[i], a);
        return isNaN(c) ? s : c;
      }, h());
    },
    formatter(o, a) {
      let f = r.reduce((s, i, c) => s += `${t[c]}${i(o, a)}`, "");
      return f += w(t);
    }
  };
}
function Y(e, t, n) {
  if (e instanceof Date || typeof e == "number") {
    const r = y(e);
    return isNaN(r) ? void 0 : r;
  }
  if (!!e) {
    if (e === "today")
      return h();
    if (t && t.toValue) {
      const r = t.toValue(e, t, n);
      return isNaN(r) ? void 0 : y(r);
    }
    return N(t).parser(e, n);
  }
}
function k(e, t, n) {
  if (isNaN(e) || !e && e !== 0)
    return "";
  const r = typeof e == "number" ? new Date(e) : e;
  return t.toDisplay ? t.toDisplay(r, t, n) : N(t).formatter(r, n);
}
export {
  k as formatDate,
  Y as parseDate,
  d as reFormatTokens,
  M as reNonDateParts
};
//# sourceMappingURL=date-format.js.map

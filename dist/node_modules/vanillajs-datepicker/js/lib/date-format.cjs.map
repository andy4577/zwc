{"version":3,"file":"date-format.cjs","sources":["../../../../../../../node_modules/vanillajs-datepicker/js/lib/date-format.js"],"sourcesContent":["import {stripTime, today} from './date.js';\nimport {lastItemOf} from './utils.js';\n\n// pattern for format parts\nexport const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;\n// pattern for non date parts\nexport const reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/;\n// cache for persed formats\nlet knownFormats = {};\n// parse funtions for date parts\nconst parseFns = {\n  y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n  m(date, month, locale) {\n    const newDate = new Date(date);\n    let monthIndex = parseInt(month, 10) - 1;\n\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n\n      const monthName = month.toLowerCase();\n      const compareNames = name => name.toLowerCase().startsWith(monthName);\n      // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n      if (monthIndex < 0) {\n        return NaN;\n      }\n    }\n\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex)\n      ? newDate.setDate(0)\n      : newDate.getTime();\n  },\n  d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  },\n};\n// format functions for date parts\nconst formatFns = {\n  d(date) {\n    return date.getDate();\n  },\n  dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n  D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n  DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n  m(date) {\n    return date.getMonth() + 1;\n  },\n  mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n  M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n  MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n  y(date) {\n    return date.getFullYear();\n  },\n  yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n  yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  },\n};\n\n// get month index in normal range (0 - 11) from any number\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\n\nfunction padZero(num, length) {\n  return num.toString().padStart(length, '0');\n}\n\nfunction parseFormatString(format) {\n  if (typeof format !== 'string') {\n    throw new Error(\"Invalid date format.\");\n  }\n  if (format in knownFormats) {\n    return knownFormats[format];\n  }\n\n  // sprit the format string into parts and seprators\n  const separators = format.split(reFormatTokens);\n  const parts = format.match(new RegExp(reFormatTokens, 'g'));\n  if (separators.length === 0 || !parts) {\n    throw new Error(\"Invalid date format.\");\n  }\n\n  // collect format functions used in the format\n  const partFormatters = parts.map(token => formatFns[token]);\n\n  // collect parse function keys used in the format\n  // iterate over parseFns' keys in order to keep the order of the keys.\n  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {\n    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);\n    if (token) {\n      keys.push(key);\n    }\n    return keys;\n  }, []);\n\n  return knownFormats[format] = {\n    parser(dateStr, locale) {\n      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n        if (part.length > 0 && parts[index]) {\n          const token = parts[index][0];\n          if (token === 'M') {\n            dtParts.m = part;\n          } else if (token !== 'D') {\n            dtParts[token] = part;\n          }\n        }\n        return dtParts;\n      }, {});\n\n      // iterate over partParserkeys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n      return partParserKeys.reduce((origDate, key) => {\n        const newDate = parseFns[key](origDate, dateParts[key], locale);\n        // ingnore the part failed to parse\n        return isNaN(newDate) ? origDate : newDate;\n      }, today());\n    },\n    formatter(date, locale) {\n      let dateStr = partFormatters.reduce((str, fn, index) => {\n        return str += `${separators[index]}${fn(date, locale)}`;\n      }, '');\n      // separators' length is always parts' length + 1,\n      return dateStr += lastItemOf(separators);\n    },\n  };\n}\n\nexport function parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === 'number') {\n    const date = stripTime(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n  if (!dateStr) {\n    return undefined;\n  }\n  if (dateStr === 'today') {\n    return today();\n  }\n\n  if (format && format.toValue) {\n    const date = format.toValue(dateStr, format, locale);\n    return isNaN(date) ? undefined : stripTime(date);\n  }\n\n  return parseFormatString(format).parser(dateStr, locale);\n}\n\nexport function formatDate(date, format, locale) {\n  if (isNaN(date) || (!date && date !== 0)) {\n    return '';\n  }\n\n  const dateObj = typeof date === 'number' ? new Date(date) : date;\n\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n\n  return parseFormatString(format).formatter(dateObj, locale);\n}\n"],"names":["reFormatTokens","reNonDateParts","knownFormats","parseFns","date","year","month","locale","newDate","monthIndex","monthName","compareNames","name","normalizeMonth","day","formatFns","padZero","num","length","parseFormatString","format","separators","parts","partFormatters","token","partParserKeys","keys","key","part","dateStr","dateParts","dtParts","index","origDate","today","str","fn","lastItemOf","parseDate","stripTime","formatDate","dateObj"],"mappings":"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"}
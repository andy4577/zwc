{"version":3,"file":"date-format.js","sources":["../../../../../../../node_modules/vanillajs-datepicker/js/lib/date-format.js"],"sourcesContent":["import {stripTime, today} from './date.js';\nimport {lastItemOf} from './utils.js';\n\n// pattern for format parts\nexport const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;\n// pattern for non date parts\nexport const reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/;\n// cache for persed formats\nlet knownFormats = {};\n// parse funtions for date parts\nconst parseFns = {\n  y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n  m(date, month, locale) {\n    const newDate = new Date(date);\n    let monthIndex = parseInt(month, 10) - 1;\n\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n\n      const monthName = month.toLowerCase();\n      const compareNames = name => name.toLowerCase().startsWith(monthName);\n      // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n      if (monthIndex < 0) {\n        return NaN;\n      }\n    }\n\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex)\n      ? newDate.setDate(0)\n      : newDate.getTime();\n  },\n  d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  },\n};\n// format functions for date parts\nconst formatFns = {\n  d(date) {\n    return date.getDate();\n  },\n  dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n  D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n  DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n  m(date) {\n    return date.getMonth() + 1;\n  },\n  mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n  M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n  MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n  y(date) {\n    return date.getFullYear();\n  },\n  yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n  yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  },\n};\n\n// get month index in normal range (0 - 11) from any number\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\n\nfunction padZero(num, length) {\n  return num.toString().padStart(length, '0');\n}\n\nfunction parseFormatString(format) {\n  if (typeof format !== 'string') {\n    throw new Error(\"Invalid date format.\");\n  }\n  if (format in knownFormats) {\n    return knownFormats[format];\n  }\n\n  // sprit the format string into parts and seprators\n  const separators = format.split(reFormatTokens);\n  const parts = format.match(new RegExp(reFormatTokens, 'g'));\n  if (separators.length === 0 || !parts) {\n    throw new Error(\"Invalid date format.\");\n  }\n\n  // collect format functions used in the format\n  const partFormatters = parts.map(token => formatFns[token]);\n\n  // collect parse function keys used in the format\n  // iterate over parseFns' keys in order to keep the order of the keys.\n  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {\n    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);\n    if (token) {\n      keys.push(key);\n    }\n    return keys;\n  }, []);\n\n  return knownFormats[format] = {\n    parser(dateStr, locale) {\n      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n        if (part.length > 0 && parts[index]) {\n          const token = parts[index][0];\n          if (token === 'M') {\n            dtParts.m = part;\n          } else if (token !== 'D') {\n            dtParts[token] = part;\n          }\n        }\n        return dtParts;\n      }, {});\n\n      // iterate over partParserkeys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n      return partParserKeys.reduce((origDate, key) => {\n        const newDate = parseFns[key](origDate, dateParts[key], locale);\n        // ingnore the part failed to parse\n        return isNaN(newDate) ? origDate : newDate;\n      }, today());\n    },\n    formatter(date, locale) {\n      let dateStr = partFormatters.reduce((str, fn, index) => {\n        return str += `${separators[index]}${fn(date, locale)}`;\n      }, '');\n      // separators' length is always parts' length + 1,\n      return dateStr += lastItemOf(separators);\n    },\n  };\n}\n\nexport function parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === 'number') {\n    const date = stripTime(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n  if (!dateStr) {\n    return undefined;\n  }\n  if (dateStr === 'today') {\n    return today();\n  }\n\n  if (format && format.toValue) {\n    const date = format.toValue(dateStr, format, locale);\n    return isNaN(date) ? undefined : stripTime(date);\n  }\n\n  return parseFormatString(format).parser(dateStr, locale);\n}\n\nexport function formatDate(date, format, locale) {\n  if (isNaN(date) || (!date && date !== 0)) {\n    return '';\n  }\n\n  const dateObj = typeof date === 'number' ? new Date(date) : date;\n\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n\n  return parseFormatString(format).formatter(dateObj, locale);\n}\n"],"names":["reFormatTokens","reNonDateParts","knownFormats","parseFns","date","year","month","locale","newDate","monthIndex","monthName","compareNames","name","normalizeMonth","day","formatFns","padZero","num","length","parseFormatString","format","separators","parts","partFormatters","token","partParserKeys","keys","key","part","dateStr","dateParts","dtParts","index","origDate","today","str","fn","lastItemOf","parseDate","stripTime","formatDate","dateObj"],"mappings":"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"}
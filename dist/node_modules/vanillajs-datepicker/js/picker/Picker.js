import { hasProperty as R, isInRange as O, lastItemOf as W, limitToRange as $ } from "../lib/utils.js";
import { today as I } from "../lib/date.js";
import { parseHTML as X, getParent as _, showElement as x, hideElement as D, emptyChildNodes as F } from "../lib/dom.js";
import { registerListeners as j } from "../lib/event.js";
import k from "./templates/pickerTemplate.js";
import K from "./views/DaysView.js";
import q from "./views/MonthsView.js";
import A from "./views/YearsView.js";
import { triggerDatepickerEvent as g } from "../events/functions.js";
import { onMousedownPicker as z, onClickView as G, onClickViewSwitch as J, onClickPrevBtn as Q, onClickNextBtn as U, onClickTodayBtn as Z, onClickClearBtn as tt } from "../events/pickerListeners.js";
const M = ["left", "top", "right", "bottom"].reduce((i, t) => (i[t] = `datepicker-orient-${t}`, i), {}), S = (i) => i && `${i}px`;
function T(i, t) {
  if (t.title !== void 0 && (t.title ? (i.controls.title.textContent = t.title, x(i.controls.title)) : (i.controls.title.textContent = "", D(i.controls.title))), t.prevArrow) {
    const e = i.controls.prevBtn;
    F(e), t.prevArrow.forEach((n) => {
      e.appendChild(n.cloneNode(!0));
    });
  }
  if (t.nextArrow) {
    const e = i.controls.nextBtn;
    F(e), t.nextArrow.forEach((n) => {
      e.appendChild(n.cloneNode(!0));
    });
  }
  if (t.locale && (i.controls.todayBtn.textContent = t.locale.today, i.controls.clearBtn.textContent = t.locale.clear), t.todayBtn !== void 0 && (t.todayBtn ? x(i.controls.todayBtn) : D(i.controls.todayBtn)), R(t, "minDate") || R(t, "maxDate")) {
    const { minDate: e, maxDate: n } = i.datepicker.config;
    i.controls.todayBtn.disabled = !O(I(), e, n);
  }
  t.clearBtn !== void 0 && (t.clearBtn ? x(i.controls.clearBtn) : D(i.controls.clearBtn));
}
function Y(i) {
  const { dates: t, config: e } = i, n = t.length > 0 ? W(t) : e.defaultViewDate;
  return $(n, e.minDate, e.maxDate);
}
function N(i, t) {
  const e = new Date(i.viewDate), n = new Date(t), { id: d, year: c, first: s, last: a } = i.currentView, l = n.getFullYear();
  switch (i.viewDate = t, l !== e.getFullYear() && g(i.datepicker, "changeYear"), n.getMonth() !== e.getMonth() && g(i.datepicker, "changeMonth"), d) {
    case 0:
      return t < s || t > a;
    case 1:
      return l !== c;
    default:
      return l < s || l > a;
  }
}
function P(i) {
  return window.getComputedStyle(i).direction;
}
function H(i) {
  const t = _(i);
  if (!(t === document.body || !t))
    return window.getComputedStyle(t).overflow !== "visible" ? t : H(t);
}
class ht {
  constructor(t) {
    const { config: e } = this.datepicker = t, n = k.replace(/%buttonClass%/g, e.buttonClass), d = this.element = X(n).firstChild, [c, s, a] = d.firstChild.children, l = c.firstElementChild, [p, f, B] = c.lastElementChild.children, [C, b] = a.firstChild.children, o = {
      title: l,
      prevBtn: p,
      viewSwitch: f,
      nextBtn: B,
      todayBtn: C,
      clearBtn: b
    };
    this.main = s, this.controls = o;
    const h = t.inline ? "inline" : "dropdown";
    d.classList.add(`datepicker-${h}`), T(this, e), this.viewDate = Y(t), j(t, [
      [d, "mousedown", z],
      [s, "click", G.bind(null, t)],
      [o.viewSwitch, "click", J.bind(null, t)],
      [o.prevBtn, "click", Q.bind(null, t)],
      [o.nextBtn, "click", U.bind(null, t)],
      [o.todayBtn, "click", Z.bind(null, t)],
      [o.clearBtn, "click", tt.bind(null, t)]
    ]), this.views = [
      new K(this),
      new q(this),
      new A(this, { id: 2, name: "years", cellClass: "year", step: 1 }),
      new A(this, { id: 3, name: "decades", cellClass: "decade", step: 10 })
    ], this.currentView = this.views[e.startView], this.currentView.render(), this.main.appendChild(this.currentView.element), e.container ? e.container.appendChild(this.element) : t.inputField.after(this.element);
  }
  setOptions(t) {
    T(this, t), this.views.forEach((e) => {
      e.init(t, !1);
    }), this.currentView.render();
  }
  detach() {
    this.element.remove();
  }
  show() {
    if (this.active)
      return;
    const { datepicker: t, element: e } = this;
    if (t.inline)
      e.classList.add("active");
    else {
      const n = P(t.inputField);
      n !== P(_(e)) ? e.dir = n : e.dir && e.removeAttribute("dir"), e.style.visiblity = "hidden", e.classList.add("active"), this.place(), e.style.visiblity = "", t.config.disableTouchKeyboard && t.inputField.blur();
    }
    this.active = !0, g(t, "show");
  }
  hide() {
    !this.active || (this.datepicker.exitEditMode(), this.element.classList.remove("active"), this.active = !1, g(this.datepicker, "hide"));
  }
  place() {
    const { classList: t, offsetParent: e, style: n } = this.element, { config: d, inputField: c } = this.datepicker, {
      width: s,
      height: a
    } = this.element.getBoundingClientRect(), {
      left: l,
      top: p,
      right: f,
      bottom: B,
      width: C,
      height: b
    } = c.getBoundingClientRect();
    let { x: o, y: h } = d.orientation, u = l, m = p;
    if (e === document.body || !e)
      u += window.scrollX, m += window.scrollY;
    else {
      const r = e.getBoundingClientRect();
      u -= r.left - e.scrollLeft, m -= r.top - e.scrollTop;
    }
    const E = H(c);
    let v = 0, L = 0, {
      clientWidth: w,
      clientHeight: y
    } = document.documentElement;
    if (E) {
      const r = E.getBoundingClientRect();
      r.top > 0 && (L = r.top), r.left > 0 && (v = r.left), r.right < w && (w = r.right), r.bottom < y && (y = r.bottom);
    }
    let V = 0;
    o === "auto" && (l < v ? (o = "left", V = v - l) : l + s > w ? (o = "right", w < f && (V = w - f)) : P(c) === "rtl" ? o = f - s < v ? "left" : "right" : o = "left"), o === "right" && (u += C - s), u += V, h === "auto" && (p - a > L ? h = B + a > y ? "top" : "bottom" : h = "bottom"), h === "top" ? m -= a : m += b, t.remove(...Object.values(M)), t.add(M[o], M[h]), n.left = S(u), n.top = S(m);
  }
  setViewSwitchLabel(t) {
    this.controls.viewSwitch.textContent = t;
  }
  setPrevBtnDisabled(t) {
    this.controls.prevBtn.disabled = t;
  }
  setNextBtnDisabled(t) {
    this.controls.nextBtn.disabled = t;
  }
  changeView(t) {
    const e = this.currentView, n = this.views[t];
    return n.id !== e.id && (this.currentView = n, this._renderMethod = "render", g(this.datepicker, "changeView"), this.main.replaceChild(n.element, e.element)), this;
  }
  changeFocus(t) {
    return this._renderMethod = N(this, t) ? "render" : "refreshFocus", this.views.forEach((e) => {
      e.updateFocus();
    }), this;
  }
  update() {
    const t = Y(this.datepicker);
    return this._renderMethod = N(this, t) ? "render" : "refresh", this.views.forEach((e) => {
      e.updateFocus(), e.updateSelection();
    }), this;
  }
  render(t = !0) {
    const e = t && this._renderMethod || "render";
    delete this._renderMethod, this.currentView[e]();
  }
}
export {
  ht as default
};
//# sourceMappingURL=Picker.js.map

import { createTagRepeat as o, hasProperty as f, pushUnique as l } from "../../lib/utils.js";
import { startOfYearPeriod as r, dateValue as d } from "../../lib/date.js";
import { parseHTML as u } from "../../lib/dom.js";
import m from "./View.js";
function p(n) {
  return [...n].reduce((e, t, s) => e += s ? t : t.toUpperCase(), "");
}
class x extends m {
  constructor(e, t) {
    super(e, t);
  }
  init(e, t = !0) {
    t && (this.navStep = this.step * 10, this.beforeShowOption = `beforeShow${p(this.cellClass)}`, this.grid = this.element, this.element.classList.add(this.name, "datepicker-grid"), this.grid.appendChild(u(o("span", 12)))), super.init(e);
  }
  setOptions(e) {
    if (f(e, "minDate") && (e.minDate === void 0 ? this.minYear = this.minDate = void 0 : (this.minYear = r(e.minDate, this.step), this.minDate = d(this.minYear, 0, 1))), f(e, "maxDate") && (e.maxDate === void 0 ? this.maxYear = this.maxDate = void 0 : (this.maxYear = r(e.maxDate, this.step), this.maxDate = d(this.maxYear, 11, 31))), this.isMinView ? e.datesDisabled && (this.datesDisabled = e.datesDisabled) : this.datesDisabled = [], e[this.beforeShowOption] !== void 0) {
      const t = e[this.beforeShowOption];
      this.beforeShow = typeof t == "function" ? t : void 0;
    }
  }
  updateFocus() {
    const e = new Date(this.picker.viewDate), t = r(e, this.navStep), s = t + 9 * this.step;
    this.first = t, this.last = s, this.start = t - this.step, this.focused = r(e, this.step);
  }
  updateSelection() {
    const { dates: e, rangepicker: t } = this.picker.datepicker;
    this.selected = e.reduce((s, i) => l(s, r(i, this.step)), []), t && t.dates && (this.range = t.dates.map((s) => {
      if (s !== void 0)
        return r(s, this.step);
    }));
  }
  render() {
    this.disabled = this.datesDisabled.map((e) => new Date(e).getFullYear()), this.picker.setViewSwitchLabel(`${this.first}-${this.last}`), this.picker.setPrevBtnDisabled(this.first <= this.minYear), this.picker.setNextBtnDisabled(this.last >= this.maxYear), Array.from(this.grid.children).forEach((e, t) => {
      const s = e.classList, i = this.start + t * this.step, a = d(i, 0, 1);
      if (e.className = `datepicker-cell ${this.cellClass}`, this.isMinView && (e.dataset.date = a), e.textContent = e.dataset.year = i, t === 0 ? s.add("prev") : t === 11 && s.add("next"), (i < this.minYear || i > this.maxYear || this.disabled.includes(i)) && s.add("disabled"), this.range) {
        const [h, c] = this.range;
        i > h && i < c && s.add("range"), i === h && s.add("range-start"), i === c && s.add("range-end");
      }
      this.selected.includes(i) && s.add("selected"), i === this.focused && s.add("focused"), this.beforeShow && this.performBeforeHook(e, i, a);
    });
  }
  refresh() {
    const [e, t] = this.range || [];
    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach((s) => {
      s.classList.remove("range", "range-start", "range-end", "selected", "focused");
    }), Array.from(this.grid.children).forEach((s) => {
      const i = Number(s.textContent), a = s.classList;
      i > e && i < t && a.add("range"), i === e && a.add("range-start"), i === t && a.add("range-end"), this.selected.includes(i) && a.add("selected"), i === this.focused && a.add("focused");
    });
  }
  refreshFocus() {
    const e = Math.round((this.focused - this.start) / this.step);
    this.grid.querySelectorAll(".focused").forEach((t) => {
      t.classList.remove("focused");
    }), this.grid.children[e].classList.add("focused");
  }
}
export {
  x as default
};
//# sourceMappingURL=YearsView.js.map

{"version":3,"file":"Datepicker.js","sources":["../../../../../../node_modules/vanillajs-datepicker/js/Datepicker.js"],"sourcesContent":["import {lastItemOf, stringToArray, isInRange} from './lib/utils.js';\nimport {today, regularizeDate} from './lib/date.js';\nimport {parseDate, formatDate} from './lib/date-format.js';\nimport {isActiveElement} from './lib/dom.js';\nimport {registerListeners, unregisterListeners} from './lib/event.js';\nimport {locales} from './i18n/base-locales.js';\nimport defaultOptions from './options/defaultOptions.js';\nimport processOptions from './options/processOptions.js';\nimport Picker from './picker/Picker.js';\nimport {triggerDatepickerEvent} from './events/functions.js';\nimport {onKeydown, onFocus, onMousedown, onClickInput, onPaste} from './events/inputFieldListeners.js';\nimport {onClickOutside} from './events/otherListeners.js';\n\nfunction stringifyDates(dates, config) {\n  return dates\n    .map(dt => formatDate(dt, config.format, config.locale))\n    .join(config.dateDelimiter);\n}\n\n// parse input dates and create an array of time values for selection\n// returns undefined if there are no valid dates in inputDates\n// when origDates (current selection) is passed, the function works to mix\n// the input dates into the current selection\nfunction processInputDates(datepicker, inputDates, clear = false) {\n  // const {config, dates: origDates, rangepicker} = datepicker;\n  const {config, dates: origDates, rangeSideIndex} = datepicker;\n  if (inputDates.length === 0) {\n    // empty input is considered valid unless origiDates is passed\n    return clear ? [] : undefined;\n  }\n\n  // const rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n  let newDates = inputDates.reduce((dates, dt) => {\n    let date = parseDate(dt, config.format, config.locale);\n    if (date === undefined) {\n      return dates;\n    }\n    // adjust to 1st of the month/Jan 1st of the year\n    // or to the last day of the monh/Dec 31st of the year if the datepicker\n    // is the range-end picker of a rangepicker\n    date = regularizeDate(date, config.pickLevel, rangeSideIndex);\n    if (\n      isInRange(date, config.minDate, config.maxDate)\n      && !dates.includes(date)\n      && !config.datesDisabled.includes(date)\n      && (config.pickLevel > 0 || !config.daysOfWeekDisabled.includes(new Date(date).getDay()))\n    ) {\n      dates.push(date);\n    }\n    return dates;\n  }, []);\n  if (newDates.length === 0) {\n    return;\n  }\n  if (config.multidate && !clear) {\n    // get the synmetric difference between origDates and newDates\n    newDates = newDates.reduce((dates, date) => {\n      if (!origDates.includes(date)) {\n        dates.push(date);\n      }\n      return dates;\n    }, origDates.filter(date => !newDates.includes(date)));\n  }\n  // do length check always because user can input multiple dates regardless of the mode\n  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates\n    ? newDates.slice(config.maxNumberOfDates * -1)\n    : newDates;\n}\n\n// refresh the UI elements\n// modes: 1: input only, 2, picker only, 3 both\nfunction refreshUI(datepicker, mode = 3, quickRender = true) {\n  const {config, picker, inputField} = datepicker;\n  if (mode & 2) {\n    const newView = picker.active ? config.pickLevel : config.startView;\n    picker.update().changeView(newView).render(quickRender);\n  }\n  if (mode & 1 && inputField) {\n    inputField.value = stringifyDates(datepicker.dates, config);\n  }\n}\n\nfunction setDate(datepicker, inputDates, options) {\n  let {clear, render, autohide, revert} = options;\n  if (render === undefined) {\n    render = true;\n  }\n  if (!render) {\n    autohide = false;\n  } else if (autohide === undefined) {\n    autohide = datepicker.config.autohide;\n  }\n\n  const newDates = processInputDates(datepicker, inputDates, clear);\n  if (!newDates && !revert) {\n    return;\n  }\n  if (newDates && newDates.toString() !== datepicker.dates.toString()) {\n    datepicker.dates = newDates;\n    refreshUI(datepicker, render ? 3 : 1);\n    triggerDatepickerEvent(datepicker, 'changeDate');\n  } else {\n    refreshUI(datepicker, 1);\n  }\n\n  if (autohide) {\n    datepicker.hide();\n  }\n}\n\n/**\n * Class representing a date picker\n */\nexport default class Datepicker {\n  /**\n   * Create a date picker\n   * @param  {Element} element - element to bind a date picker\n   * @param  {Object} [options] - config options\n   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\n   * date picker belongs to. Use this only when creating date picker as a part\n   * of date range picker\n   */\n  constructor(element, options = {}, rangepicker = undefined) {\n    element.datepicker = this;\n    this.element = element;\n\n    const config = this.config = Object.assign({\n      buttonClass: (options.buttonClass && String(options.buttonClass)) || 'button',\n      container: null,\n      defaultViewDate: today(),\n      maxDate: undefined,\n      minDate: undefined,\n    }, processOptions(defaultOptions, this));\n    // configure by type\n    const inline = this.inline = element.tagName !== 'INPUT';\n    let inputField;\n    if (inline) {\n      config.container = element;\n    } else {\n      if (options.container) {\n        // omit string type check because it doesn't guarantee to avoid errors\n        // (invalid selector string causes abend with sytax error)\n        config.container = options.container instanceof HTMLElement\n          ? options.container\n          : document.querySelector(options.container);\n      }\n      inputField = this.inputField = element;\n      inputField.classList.add('datepicker-input');\n    }\n    if (rangepicker) {\n      // check validiry\n      const index = rangepicker.inputs.indexOf(inputField);\n      const datepickers = rangepicker.datepickers;\n      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n        throw Error('Invalid rangepicker object.');\n      }\n      // attach itaelf to the rangepicker here so that processInputDates() can\n      // determine if this is the range-end picker of the rangepicker while\n      // setting inital values when pickLevel > 0\n      datepickers[index] = this;\n      // add getter for rangepicker\n      Object.defineProperty(this, 'rangepicker', {\n        get() {\n          return rangepicker;\n        },\n      });\n      Object.defineProperty(this, 'rangeSideIndex', {\n        get() {\n          return index;\n        },\n      });\n    }\n\n    // set up config\n    this._options = options;\n    Object.assign(config, processOptions(options, this));\n\n    // set initial dates\n    let initialDates;\n    if (inline) {\n      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n    } else {\n      initialDates = stringToArray(inputField.value, config.dateDelimiter);\n    }\n    this.dates = [];\n    // process initial value\n    const inputDateValues = processInputDates(this, initialDates);\n    if (inputDateValues && inputDateValues.length > 0) {\n      this.dates = inputDateValues;\n    }\n    if (inputField) {\n      inputField.value = stringifyDates(this.dates, config);\n    }\n\n    const picker = this.picker = new Picker(this);\n\n    if (inline) {\n      this.show();\n    } else {\n      // set up event listeners in other modes\n      const onMousedownDocument = onClickOutside.bind(null, this);\n      const listeners = [\n        [inputField, 'keydown', onKeydown.bind(null, this)],\n        [inputField, 'focus', onFocus.bind(null, this)],\n        [inputField, 'mousedown', onMousedown.bind(null, this)],\n        [inputField, 'click', onClickInput.bind(null, this)],\n        [inputField, 'paste', onPaste.bind(null, this)],\n        [document, 'mousedown', onMousedownDocument],\n        [document, 'touchstart', onMousedownDocument],\n        [window, 'resize', picker.place.bind(picker)]\n      ];\n      registerListeners(this, listeners);\n    }\n  }\n\n  /**\n   * Format Date object or time value in given format and language\n   * @param  {Date|Number} date - date or time value to format\n   * @param  {String|Object} format - format string or object that contains\n   * toDisplay() custom formatter, whose signature is\n   * - args:\n   *   - date: {Date} - Date instance of the date passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {String} formatted date\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {String} formatted date\n   */\n  static formatDate(date, format, lang) {\n    return formatDate(date, format, lang && locales[lang] || locales.en);\n  }\n\n  /**\n   * Parse date string\n   * @param  {String|Date|Number} dateStr - date string, Date object or time\n   * value to parse\n   * @param  {String|Object} format - format string or object that contains\n   * toValue() custom parser, whose signature is\n   * - args:\n   *   - dateStr: {String|Date|Number} - the dateStr passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {Date|Number} parsed date or its time value\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {Number} time value of parsed date\n   */\n  static parseDate(dateStr, format, lang) {\n    return parseDate(dateStr, format, lang && locales[lang] || locales.en);\n  }\n\n  /**\n   * @type {Object} - Installed locales in `[languageCode]: localeObject` format\n   * en`:_English (US)_ is pre-installed.\n   */\n  static get locales() {\n    return locales;\n  }\n\n  /**\n   * @type {Boolean} - Whether the picker element is shown. `true` whne shown\n   */\n  get active() {\n    return !!(this.picker && this.picker.active);\n  }\n\n  /**\n   * @type {HTMLDivElement} - DOM object of picker element\n   */\n  get pickerElement() {\n    return this.picker ? this.picker.element : undefined;\n  }\n\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n  setOptions(options) {\n    const picker = this.picker;\n    const newOptions = processOptions(options, this);\n    Object.assign(this._options, options);\n    Object.assign(this.config, newOptions);\n    picker.setOptions(newOptions);\n\n    refreshUI(this, 3);\n  }\n\n  /**\n   * Show the picker element\n   */\n  show() {\n    if (this.inputField) {\n      if (this.inputField.disabled) {\n        return;\n      }\n      if (!isActiveElement(this.inputField) && !this.config.disableTouchKeyboard) {\n        this._showing = true;\n        this.inputField.focus();\n        delete this._showing;\n      }\n    }\n    this.picker.show();\n  }\n\n  /**\n   * Hide the picker element\n   * Not available on inline picker\n   */\n  hide() {\n    if (this.inline) {\n      return;\n    }\n    this.picker.hide();\n    this.picker.update().changeView(this.config.startView).render();\n  }\n\n  /**\n   * Destroy the Datepicker instance\n   * @return {Detepicker} - the instance destroyed\n   */\n  destroy() {\n    this.hide();\n    unregisterListeners(this);\n    this.picker.detach();\n    if (!this.inline) {\n      this.inputField.classList.remove('datepicker-input');\n    }\n    delete this.element.datepicker;\n    return this;\n  }\n\n  /**\n   * Get the selected date(s)\n   *\n   * The method returns a Date object of selected date by default, and returns\n   * an array of selected dates in multidate mode. If format string is passed,\n   * it returns date string(s) formatted in given format.\n   *\n   * @param  {String} [format] - Format string to stringify the date(s)\n   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\n   * selected, empty array in multidate mode and untitled in sigledate mode\n   */\n  getDate(format = undefined) {\n    const callback = format\n      ? date => formatDate(date, format, this.config.locale)\n      : date => new Date(date);\n\n    if (this.config.multidate) {\n      return this.dates.map(callback);\n    }\n    if (this.dates.length > 0) {\n      return callback(this.dates[0]);\n    }\n  }\n\n  /**\n   * Set selected date(s)\n   *\n   * In multidate mode, you can pass multiple dates as a series of arguments\n   * or an array. (Since each date is parsed individually, the type of the\n   * dates doesn't have to be the same.)\n   * The given dates are used to toggle the select status of each date. The\n   * number of selected dates is kept from exceeding the length set to\n   * maxNumberOfDates.\n   *\n   * With clear: true option, the method can be used to clear the selection\n   * and to replace the selection instead of toggling in multidate mode.\n   * If the option is passed with no date arguments or an empty dates array,\n   * it works as \"clear\" (clear the selection then set nothing), and if the\n   * option is passed with new dates to select, it works as \"replace\" (clear\n   * the selection then set the given dates)\n   *\n   * When render: false option is used, the method omits re-rendering the\n   * picker element. In this case, you need to call refresh() method later in\n   * order for the picker element to reflect the changes. The input field is\n   * refreshed always regardless of this option.\n   *\n   * When invalid (unparsable, repeated, disabled or out-of-range) dates are\n   * passed, the method ignores them and applies only valid ones. In the case\n   * that all the given dates are invalid, which is distinguished from passing\n   * no dates, the method considers it as an error and leaves the selection\n   * untouched. (The input field also remains untouched unless revert: true\n   * option is used.)\n   *\n   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\n   * objects, time values or mix of those for new selection\n   * @param {Object} [options] - function options\n   * - clear: {boolean} - Whether to clear the existing selection\n   *     defualt: false\n   * - render: {boolean} - Whether to re-render the picker element\n   *     default: true\n   * - autohide: {boolean} - Whether to hide the picker element after re-render\n   *     Ignored when used with render: false\n   *     default: config.autohide\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n  setDate(...args) {\n    const dates = [...args];\n    const opts = {};\n    const lastArg = lastItemOf(args);\n    if (\n      typeof lastArg === 'object'\n      && !Array.isArray(lastArg)\n      && !(lastArg instanceof Date)\n      && lastArg\n    ) {\n      Object.assign(opts, dates.pop());\n    }\n\n    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n    setDate(this, inputDates, opts);\n  }\n\n  /**\n   * Update the selected date(s) with input field's value\n   * Not available on inline picker\n   *\n   * The input field will be refreshed with properly formatted date string.\n   *\n   * In the case that all the entered dates are invalid (unparsable, repeated,\n   * disabled or out-of-range), whixh is distinguished from empty input field,\n   * the method leaves the input field untouched as well as the selection by\n   * default. If revert: true option is used in this case, the input field is\n   * refreshed with the existing selection.\n   *\n   * @param  {Object} [options] - function options\n   * - autohide: {boolean} - whether to hide the picker element after refresh\n   *     default: false\n   * - revert: {boolean} - Whether to refresh the input field when all the\n   *     passed dates are invalid\n   *     default: false\n   */\n  update(options = undefined) {\n    if (this.inline) {\n      return;\n    }\n\n    const opts = Object.assign(options || {}, {clear: true, render: true});\n    const inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n    setDate(this, inputDates, opts);\n  }\n\n  /**\n   * Refresh the picker element and the associated input field\n   * @param {String} [target] - target item when refreshing one item only\n   * 'picker' or 'input'\n   * @param {Boolean} [forceRender] - whether to re-render the picker element\n   * regardless of its state instead of optimized refresh\n   */\n  refresh(target = undefined, forceRender = false) {\n    if (target && typeof target !== 'string') {\n      forceRender = target;\n      target = undefined;\n    }\n\n    let mode;\n    if (target === 'picker') {\n      mode = 2;\n    } else if (target === 'input') {\n      mode = 1;\n    } else {\n      mode = 3;\n    }\n    refreshUI(this, mode, !forceRender);\n  }\n\n  /**\n   * Enter edit mode\n   * Not available on inline picker or when the picker element is hidden\n   */\n  enterEditMode() {\n    if (this.inline || !this.picker.active || this.editMode) {\n      return;\n    }\n    this.editMode = true;\n    this.inputField.classList.add('in-edit');\n  }\n\n  /**\n   * Exit from edit mode\n   * Not available on inline picker\n   * @param  {Object} [options] - function options\n   * - update: {boolean} - whether to call update() after exiting\n   *     If false, input field is revert to the existing selection\n   *     default: false\n   */\n  exitEditMode(options = undefined) {\n    if (this.inline || !this.editMode) {\n      return;\n    }\n    const opts = Object.assign({update: false}, options);\n    delete this.editMode;\n    this.inputField.classList.remove('in-edit');\n    if (opts.update) {\n      this.update(opts);\n    }\n  }\n}\n"],"names":["stringifyDates","dates","config","dt","formatDate","processInputDates","datepicker","inputDates","clear","origDates","rangeSideIndex","newDates","date","parseDate","regularizeDate","isInRange","refreshUI","mode","quickRender","picker","inputField","newView","setDate","options","render","autohide","revert","triggerDatepickerEvent","Datepicker","element","rangepicker","today","processOptions","defaultOptions","inline","index","datepickers","initialDates","stringToArray","inputDateValues","Picker","onMousedownDocument","onClickOutside","listeners","onKeydown","onFocus","onMousedown","onClickInput","onPaste","registerListeners","format","lang","locales","dateStr","newOptions","isActiveElement","unregisterListeners","callback","args","opts","lastArg","lastItemOf","target","forceRender"],"mappings":";;;;;;;;;;;;AAaA,SAASA,EAAeC,GAAOC,GAAQ;AACrC,SAAOD,EACJ,IAAI,CAAAE,MAAMC,EAAWD,GAAID,EAAO,QAAQA,EAAO,MAAM,CAAC,EACtD,KAAKA,EAAO,aAAa;AAC9B;AAMA,SAASG,EAAkBC,GAAYC,GAAYC,IAAQ,IAAO;AAEhE,QAAM,EAAC,QAAAN,GAAQ,OAAOO,GAAW,gBAAAC,EAAc,IAAIJ;AACnD,MAAIC,EAAW,WAAW;AAExB,WAAOC,IAAQ,CAAE,IAAG;AAItB,MAAIG,IAAWJ,EAAW,OAAO,CAACN,GAAOE,MAAO;AAC9C,QAAIS,IAAOC,EAAUV,GAAID,EAAO,QAAQA,EAAO,MAAM;AACrD,WAAIU,MAAS,WAMbA,IAAOE,EAAeF,GAAMV,EAAO,WAAWQ,CAAc,GAE1DK,EAAUH,GAAMV,EAAO,SAASA,EAAO,OAAO,KAC3C,CAACD,EAAM,SAASW,CAAI,KACpB,CAACV,EAAO,cAAc,SAASU,CAAI,MAClCV,EAAO,YAAY,KAAK,CAACA,EAAO,mBAAmB,SAAS,IAAI,KAAKU,CAAI,EAAE,OAAQ,CAAA,MAEvFX,EAAM,KAAKW,CAAI,IAEVX;AAAA,EACR,GAAE,CAAE,CAAA;AACL,MAAIU,EAAS,WAAW;AAGxB,WAAIT,EAAO,aAAa,CAACM,MAEvBG,IAAWA,EAAS,OAAO,CAACV,GAAOW,OAC5BH,EAAU,SAASG,CAAI,KAC1BX,EAAM,KAAKW,CAAI,GAEVX,IACNQ,EAAU,OAAO,CAAAG,MAAQ,CAACD,EAAS,SAASC,CAAI,CAAC,CAAC,IAGhDV,EAAO,oBAAoBS,EAAS,SAAST,EAAO,mBACvDS,EAAS,MAAMT,EAAO,mBAAmB,EAAE,IAC3CS;AACN;AAIA,SAASK,EAAUV,GAAYW,IAAO,GAAGC,IAAc,IAAM;AAC3D,QAAM,EAAC,QAAAhB,GAAQ,QAAAiB,GAAQ,YAAAC,EAAU,IAAId;AACrC,MAAIW,IAAO,GAAG;AACZ,UAAMI,IAAUF,EAAO,SAASjB,EAAO,YAAYA,EAAO;AAC1D,IAAAiB,EAAO,OAAM,EAAG,WAAWE,CAAO,EAAE,OAAOH,CAAW;AAAA,EACvD;AACD,EAAID,IAAO,KAAKG,MACdA,EAAW,QAAQpB,EAAeM,EAAW,OAAOJ,CAAM;AAE9D;AAEA,SAASoB,EAAQhB,GAAYC,GAAYgB,GAAS;AAChD,MAAI,EAAC,OAAAf,GAAO,QAAAgB,GAAQ,UAAAC,GAAU,QAAAC,EAAM,IAAIH;AACxC,EAAIC,MAAW,WACbA,IAAS,KAENA,IAEMC,MAAa,WACtBA,IAAWnB,EAAW,OAAO,YAF7BmB,IAAW;AAKb,QAAMd,IAAWN,EAAkBC,GAAYC,GAAYC,CAAK;AAChE,EAAI,CAACG,KAAY,CAACe,MAGdf,KAAYA,EAAS,SAAQ,MAAOL,EAAW,MAAM,cACvDA,EAAW,QAAQK,GACnBK,EAAUV,GAAYkB,IAAS,IAAI,CAAC,GACpCG,EAAuBrB,GAAY,YAAY,KAE/CU,EAAUV,GAAY,CAAC,GAGrBmB,KACFnB,EAAW,KAAI;AAEnB;AAKe,MAAMsB,EAAW;AAAA,EAS9B,YAAYC,GAASN,IAAU,CAAA,GAAIO,IAAc,QAAW;AAC1D,IAAAD,EAAQ,aAAa,MACrB,KAAK,UAAUA;AAEf,UAAM3B,IAAS,KAAK,SAAS,OAAO,OAAO;AAAA,MACzC,aAAcqB,EAAQ,eAAe,OAAOA,EAAQ,WAAW,KAAM;AAAA,MACrE,WAAW;AAAA,MACX,iBAAiBQ,EAAO;AAAA,MACxB,SAAS;AAAA,MACT,SAAS;AAAA,IACV,GAAEC,EAAeC,GAAgB,IAAI,CAAC,GAEjCC,IAAS,KAAK,SAASL,EAAQ,YAAY;AACjD,QAAIT;AAcJ,QAbIc,IACFhC,EAAO,YAAY2B,KAEfN,EAAQ,cAGVrB,EAAO,YAAYqB,EAAQ,qBAAqB,cAC5CA,EAAQ,YACR,SAAS,cAAcA,EAAQ,SAAS,IAE9CH,IAAa,KAAK,aAAaS,GAC/BT,EAAW,UAAU,IAAI,kBAAkB,IAEzCU,GAAa;AAEf,YAAMK,IAAQL,EAAY,OAAO,QAAQV,CAAU,GAC7CgB,IAAcN,EAAY;AAChC,UAAIK,IAAQ,KAAKA,IAAQ,KAAK,CAAC,MAAM,QAAQC,CAAW;AACtD,cAAM,MAAM,6BAA6B;AAK3C,MAAAA,EAAYD,KAAS,MAErB,OAAO,eAAe,MAAM,eAAe;AAAA,QACzC,MAAM;AACJ,iBAAOL;AAAA,QACR;AAAA,MACT,CAAO,GACD,OAAO,eAAe,MAAM,kBAAkB;AAAA,QAC5C,MAAM;AACJ,iBAAOK;AAAA,QACR;AAAA,MACT,CAAO;AAAA,IACF;AAGD,SAAK,WAAWZ,GAChB,OAAO,OAAOrB,GAAQ8B,EAAeT,GAAS,IAAI,CAAC;AAGnD,QAAIc;AACJ,IAAIH,KACFG,IAAeC,EAAcT,EAAQ,QAAQ,MAAM3B,EAAO,aAAa,GACvE,OAAO2B,EAAQ,QAAQ,QAEvBQ,IAAeC,EAAclB,EAAW,OAAOlB,EAAO,aAAa,GAErE,KAAK,QAAQ;AAEb,UAAMqC,IAAkBlC,EAAkB,MAAMgC,CAAY;AAC5D,IAAIE,KAAmBA,EAAgB,SAAS,MAC9C,KAAK,QAAQA,IAEXnB,MACFA,EAAW,QAAQpB,EAAe,KAAK,OAAOE,CAAM;AAGtD,UAAMiB,IAAS,KAAK,SAAS,IAAIqB,EAAO,IAAI;AAE5C,QAAIN;AACF,WAAK,KAAI;AAAA,SACJ;AAEL,YAAMO,IAAsBC,EAAe,KAAK,MAAM,IAAI,GACpDC,IAAY;AAAA,QAChB,CAACvB,GAAY,WAAWwB,EAAU,KAAK,MAAM,IAAI,CAAC;AAAA,QAClD,CAACxB,GAAY,SAASyB,EAAQ,KAAK,MAAM,IAAI,CAAC;AAAA,QAC9C,CAACzB,GAAY,aAAa0B,EAAY,KAAK,MAAM,IAAI,CAAC;AAAA,QACtD,CAAC1B,GAAY,SAAS2B,EAAa,KAAK,MAAM,IAAI,CAAC;AAAA,QACnD,CAAC3B,GAAY,SAAS4B,EAAQ,KAAK,MAAM,IAAI,CAAC;AAAA,QAC9C,CAAC,UAAU,aAAaP,CAAmB;AAAA,QAC3C,CAAC,UAAU,cAAcA,CAAmB;AAAA,QAC5C,CAAC,QAAQ,UAAUtB,EAAO,MAAM,KAAKA,CAAM,CAAC;AAAA,MACpD;AACM,MAAA8B,EAAkB,MAAMN,CAAS;AAAA,IAClC;AAAA,EACF;AAAA,EAgBD,OAAO,WAAW/B,GAAMsC,GAAQC,GAAM;AACpC,WAAO/C,EAAWQ,GAAMsC,GAAQC,KAAQC,EAAQD,MAASC,EAAQ,EAAE;AAAA,EACpE;AAAA,EAiBD,OAAO,UAAUC,GAASH,GAAQC,GAAM;AACtC,WAAOtC,EAAUwC,GAASH,GAAQC,KAAQC,EAAQD,MAASC,EAAQ,EAAE;AAAA,EACtE;AAAA,EAMD,WAAW,UAAU;AACnB,WAAOA;AAAA,EACR;AAAA,EAKD,IAAI,SAAS;AACX,WAAO,CAAC,EAAE,KAAK,UAAU,KAAK,OAAO;AAAA,EACtC;AAAA,EAKD,IAAI,gBAAgB;AAClB,WAAO,KAAK,SAAS,KAAK,OAAO,UAAU;AAAA,EAC5C;AAAA,EAMD,WAAW7B,GAAS;AAClB,UAAMJ,IAAS,KAAK,QACdmC,IAAatB,EAAeT,GAAS,IAAI;AAC/C,WAAO,OAAO,KAAK,UAAUA,CAAO,GACpC,OAAO,OAAO,KAAK,QAAQ+B,CAAU,GACrCnC,EAAO,WAAWmC,CAAU,GAE5BtC,EAAU,MAAM,CAAC;AAAA,EAClB;AAAA,EAKD,OAAO;AACL,QAAI,KAAK,YAAY;AACnB,UAAI,KAAK,WAAW;AAClB;AAEF,MAAI,CAACuC,EAAgB,KAAK,UAAU,KAAK,CAAC,KAAK,OAAO,yBACpD,KAAK,WAAW,IAChB,KAAK,WAAW,SAChB,OAAO,KAAK;AAAA,IAEf;AACD,SAAK,OAAO;EACb;AAAA,EAMD,OAAO;AACL,IAAI,KAAK,WAGT,KAAK,OAAO,QACZ,KAAK,OAAO,OAAM,EAAG,WAAW,KAAK,OAAO,SAAS,EAAE;EACxD;AAAA,EAMD,UAAU;AACR,gBAAK,KAAI,GACTC,EAAoB,IAAI,GACxB,KAAK,OAAO,UACP,KAAK,UACR,KAAK,WAAW,UAAU,OAAO,kBAAkB,GAErD,OAAO,KAAK,QAAQ,YACb;AAAA,EACR;AAAA,EAaD,QAAQN,IAAS,QAAW;AAC1B,UAAMO,IAAWP,IACb,CAAAtC,MAAQR,EAAWQ,GAAMsC,GAAQ,KAAK,OAAO,MAAM,IACnD,CAAAtC,MAAQ,IAAI,KAAKA,CAAI;AAEzB,QAAI,KAAK,OAAO;AACd,aAAO,KAAK,MAAM,IAAI6C,CAAQ;AAEhC,QAAI,KAAK,MAAM,SAAS;AACtB,aAAOA,EAAS,KAAK,MAAM,EAAE;AAAA,EAEhC;AAAA,EA6CD,WAAWC,GAAM;AACf,UAAMzD,IAAQ,CAAC,GAAGyD,CAAI,GAChBC,IAAO,CAAA,GACPC,IAAUC,EAAWH,CAAI;AAC/B,IACE,OAAOE,KAAY,YAChB,CAAC,MAAM,QAAQA,CAAO,KACtB,EAAEA,aAAmB,SACrBA,KAEH,OAAO,OAAOD,GAAM1D,EAAM,IAAK,CAAA;AAGjC,UAAMM,IAAa,MAAM,QAAQN,EAAM,EAAE,IAAIA,EAAM,KAAKA;AACxD,IAAAqB,EAAQ,MAAMf,GAAYoD,CAAI;AAAA,EAC/B;AAAA,EAqBD,OAAOpC,IAAU,QAAW;AAC1B,QAAI,KAAK;AACP;AAGF,UAAMoC,IAAO,OAAO,OAAOpC,KAAW,CAAA,GAAI,EAAC,OAAO,IAAM,QAAQ,GAAI,CAAC,GAC/DhB,IAAa+B,EAAc,KAAK,WAAW,OAAO,KAAK,OAAO,aAAa;AACjF,IAAAhB,EAAQ,MAAMf,GAAYoD,CAAI;AAAA,EAC/B;AAAA,EASD,QAAQG,IAAS,QAAWC,IAAc,IAAO;AAC/C,IAAID,KAAU,OAAOA,KAAW,aAC9BC,IAAcD,GACdA,IAAS;AAGX,QAAI7C;AACJ,IAAI6C,MAAW,WACb7C,IAAO,IACE6C,MAAW,UACpB7C,IAAO,IAEPA,IAAO,GAETD,EAAU,MAAMC,GAAM,CAAC8C,CAAW;AAAA,EACnC;AAAA,EAMD,gBAAgB;AACd,IAAI,KAAK,UAAU,CAAC,KAAK,OAAO,UAAU,KAAK,aAG/C,KAAK,WAAW,IAChB,KAAK,WAAW,UAAU,IAAI,SAAS;AAAA,EACxC;AAAA,EAUD,aAAaxC,IAAU,QAAW;AAChC,QAAI,KAAK,UAAU,CAAC,KAAK;AACvB;AAEF,UAAMoC,IAAO,OAAO,OAAO,EAAC,QAAQ,GAAK,GAAGpC,CAAO;AACnD,WAAO,KAAK,UACZ,KAAK,WAAW,UAAU,OAAO,SAAS,GACtCoC,EAAK,UACP,KAAK,OAAOA,CAAI;AAAA,EAEnB;AACH;"}
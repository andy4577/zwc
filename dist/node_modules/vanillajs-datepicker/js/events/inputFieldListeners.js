import { isInRange as D } from "../lib/utils.js";
import { isActiveElement as M } from "../lib/dom.js";
import { addYears as w, addMonths as y, addDays as d, startOfYearPeriod as _ } from "../lib/date.js";
import { unfocus as b, goToPrevOrNext as g, switchView as A } from "./functions.js";
function m(e, n, t, i, r, o) {
  if (!!D(e, r, o)) {
    if (i(e)) {
      const f = n(e, t);
      return m(f, n, t, i, r, o);
    }
    return e;
  }
}
function a(e, n, t, i) {
  const r = e.picker, o = r.currentView, f = o.step || 1;
  let s = r.viewDate, u, c;
  switch (o.id) {
    case 0:
      i ? s = d(s, t * 7) : n.ctrlKey || n.metaKey ? s = w(s, t) : s = d(s, t), u = d, c = (l) => o.disabled.includes(l);
      break;
    case 1:
      s = y(s, i ? t * 4 : t), u = y, c = (l) => {
        const h = new Date(l), { year: K, disabled: E } = o;
        return h.getFullYear() === K && E.includes(h.getMonth());
      };
      break;
    default:
      s = w(s, t * (i ? 4 : 1) * f), u = w, c = (l) => o.disabled.includes(_(l, f));
  }
  s = m(
    s,
    u,
    t < 0 ? -f : f,
    c,
    o.minDate,
    o.maxDate
  ), s !== void 0 && r.changeFocus(s).render();
}
function T(e, n) {
  const t = n.key;
  if (t === "Tab") {
    b(e);
    return;
  }
  const i = e.picker, { id: r, isMinView: o } = i.currentView;
  if (i.active)
    if (e.editMode) {
      t === "Enter" ? e.exitEditMode({ update: !0, autohide: e.config.autohide }) : t === "Escape" && i.hide();
      return;
    } else if (t === "ArrowLeft")
      if (n.ctrlKey || n.metaKey)
        g(e, -1);
      else if (n.shiftKey) {
        e.enterEditMode();
        return;
      } else
        a(e, n, -1, !1);
    else if (t === "ArrowRight")
      if (n.ctrlKey || n.metaKey)
        g(e, 1);
      else if (n.shiftKey) {
        e.enterEditMode();
        return;
      } else
        a(e, n, 1, !1);
    else if (t === "ArrowUp")
      if (n.ctrlKey || n.metaKey)
        A(e);
      else if (n.shiftKey) {
        e.enterEditMode();
        return;
      } else
        a(e, n, -1, !0);
    else if (t === "ArrowDown") {
      if (n.shiftKey && !n.ctrlKey && !n.metaKey) {
        e.enterEditMode();
        return;
      }
      a(e, n, 1, !0);
    } else if (t === "Enter") {
      if (o) {
        e.setDate(i.viewDate);
        return;
      }
      i.changeView(r - 1).render();
    } else {
      t === "Escape" ? i.hide() : (t === "Backspace" || t === "Delete" || t.length === 1 && !n.ctrlKey && !n.metaKey) && e.enterEditMode();
      return;
    }
  else if (t === "ArrowDown")
    i.show();
  else {
    t === "Enter" ? e.update() : t === "Escape" && i.show();
    return;
  }
  n.preventDefault();
}
function C(e) {
  e.config.showOnFocus && !e._showing && e.show();
}
function P(e, n) {
  const t = n.target;
  (e.picker.active || e.config.showOnClick) && (t._active = M(t), t._clicking = setTimeout(() => {
    delete t._active, delete t._clicking;
  }, 2e3));
}
function Y(e, n) {
  const t = n.target;
  !t._clicking || (clearTimeout(t._clicking), delete t._clicking, t._active && e.enterEditMode(), delete t._active, e.config.showOnClick && e.show());
}
function B(e, n) {
  n.clipboardData.types.includes("text/plain") && e.enterEditMode();
}
export {
  Y as onClickInput,
  C as onFocus,
  T as onKeydown,
  P as onMousedown,
  B as onPaste
};
//# sourceMappingURL=inputFieldListeners.js.map

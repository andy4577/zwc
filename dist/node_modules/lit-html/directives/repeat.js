import { noChange as w } from "../lit-html.js";
import { directive as A, Directive as V, PartType as D } from "../directive.js";
import { getCommittedValue as b, setChildPartValue as m, insertPart as v, removePart as g, setCommittedValue as j } from "../directive-helpers.js";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const k = (s, f, c) => {
  const d = /* @__PURE__ */ new Map();
  for (let n = f; n <= c; n++)
    d.set(s[n], n);
  return d;
}, L = A(class extends V {
  constructor(s) {
    if (super(s), s.type !== D.CHILD)
      throw Error("repeat() can only be used in text expressions");
  }
  ht(s, f, c) {
    let d;
    c === void 0 ? c = f : f !== void 0 && (d = f);
    const n = [], e = [];
    let l = 0;
    for (const a of s)
      n[l] = d ? d(a, l) : l, e[l] = c(a, l), l++;
    return { values: e, keys: n };
  }
  render(s, f, c) {
    return this.ht(s, f, c).values;
  }
  update(s, [f, c, d]) {
    var n;
    const e = b(s), { values: l, keys: a } = this.ht(f, c, d);
    if (!Array.isArray(e))
      return this.ut = a, l;
    const p = (n = this.ut) !== null && n !== void 0 ? n : this.ut = [], u = [];
    let y, C, t = 0, o = e.length - 1, r = 0, i = l.length - 1;
    for (; t <= o && r <= i; )
      if (e[t] === null)
        t++;
      else if (e[o] === null)
        o--;
      else if (p[t] === a[r])
        u[r] = m(e[t], l[r]), t++, r++;
      else if (p[o] === a[i])
        u[i] = m(e[o], l[i]), o--, i--;
      else if (p[t] === a[i])
        u[i] = m(e[t], l[i]), v(s, u[i + 1], e[t]), t++, i--;
      else if (p[o] === a[r])
        u[r] = m(e[o], l[r]), v(s, e[t], e[o]), o--, r++;
      else if (y === void 0 && (y = k(a, r, i), C = k(p, t, o)), y.has(p[t]))
        if (y.has(p[o])) {
          const h = C.get(a[r]), x = h !== void 0 ? e[h] : null;
          if (x === null) {
            const P = v(s, e[t]);
            m(P, l[r]), u[r] = P;
          } else
            u[r] = m(x, l[r]), v(s, e[t], x), e[h] = null;
          r++;
        } else
          g(e[o]), o--;
      else
        g(e[t]), t++;
    for (; r <= i; ) {
      const h = v(s, u[i + 1]);
      m(h, l[r]), u[r++] = h;
    }
    for (; t <= o; ) {
      const h = e[t++];
      h !== null && g(h);
    }
    return this.ut = a, j(s, u), w;
  }
});
export {
  L as repeat
};
//# sourceMappingURL=repeat.js.map

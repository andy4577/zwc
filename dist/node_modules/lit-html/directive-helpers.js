import { _$LH as c } from "./lit-html.js";
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { I: d } = c, f = (e) => e.strings === void 0, _ = () => document.createComment(""), u = (e, n, t) => {
  var l;
  const r = e._$AA.parentNode, A = n === void 0 ? e._$AB : n._$AA;
  if (t === void 0) {
    const i = r.insertBefore(_(), A), o = r.insertBefore(_(), A);
    t = new d(i, o, e, e.options);
  } else {
    const i = t._$AB.nextSibling, o = t._$AM, a = o !== e;
    if (a) {
      let s;
      (l = t._$AQ) === null || l === void 0 || l.call(t, e), t._$AM = e, t._$AP !== void 0 && (s = e._$AU) !== o._$AU && t._$AP(s);
    }
    if (i !== A || a) {
      let s = t._$AA;
      for (; s !== i; ) {
        const $ = s.nextSibling;
        r.insertBefore(s, A), s = $;
      }
    }
  }
  return t;
}, g = (e, n, t = e) => (e._$AI(n, t), e), m = {}, p = (e, n = m) => e._$AH = n, x = (e) => e._$AH, B = (e) => {
  var n;
  (n = e._$AP) === null || n === void 0 || n.call(e, !1, !0);
  let t = e._$AA;
  const l = e._$AB.nextSibling;
  for (; t !== l; ) {
    const r = t.nextSibling;
    t.remove(), t = r;
  }
};
export {
  x as getCommittedValue,
  u as insertPart,
  f as isSingleExpression,
  B as removePart,
  g as setChildPartValue,
  p as setCommittedValue
};
//# sourceMappingURL=directive-helpers.js.map

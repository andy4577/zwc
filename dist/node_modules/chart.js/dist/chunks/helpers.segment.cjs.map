{"version":3,"file":"helpers.segment.cjs","sources":["../../../../../../../node_modules/chart.js/dist/chunks/helpers.segment.js"],"sourcesContent":["/*!\n * Chart.js v4.1.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || typeof value === 'undefined';\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set();\n    let i, ilen;\n    for(i = 0, ilen = items.length; i < ilen; ++i){\n        set.add(items[i]);\n    }\n    if (set.size === ilen) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , _parsed  } = meta;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\nfunction toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n function _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n function clearCanvas(canvas, ctx) {\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n         case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n         case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5;\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\n function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += font.lineHeight;\n    }\n    ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    ctx.lineTo(x + w, y + radius.topRight);\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _createResolver(scopes, prefixes = [\n    ''\n], rootScopes = scopes, fallback, getTarget = ()=>scopes[0]) {\n    if (!defined(fallback)) {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: rootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, rootScopes, fallback)\n    };\n    return new Proxy(cache, {\n deleteProperty (target, prop) {\n            delete target[prop];\n            delete target._keys;\n            delete scopes[0][prop];\n            return true;\n        },\n get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value;\n            delete target._keys;\n            return true;\n        }\n    });\n}\n function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n deleteProperty (target, prop) {\n            delete target[prop];\n            delete proxy[prop];\n            return true;\n        },\n get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n set (target, prop, value) {\n            proxy[prop] = value;\n            delete target[prop];\n            return true;\n        }\n    });\n}\n function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n        return target[prop];\n    }\n    const value = resolve();\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop];\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    value = value(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (defined(_context.index) && isIndexable(prop)) {\n        value = value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n                return fallback;\n            }\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (defined(fallback) && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (defined(value)) {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (defined(value)) {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */ /**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = Math.floor(chart.height);\n    chart.width = Math.floor(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        window.addEventListener('test', null, options);\n        window.removeEventListener('test', null, options);\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, fontString as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, overrideTextDirection as aA, _textX as aB, restoreTextDirection as aC, drawPointLegend as aD, distanceBetweenPoints as aE, noop as aF, _setMinAndMaxByKey as aG, niceNum as aH, almostWhole as aI, almostEquals as aJ, _decimalPlaces as aK, Ticks as aL, log10 as aM, _longestText as aN, _filterBetween as aO, _lookup as aP, isPatternOrGradient as aQ, getHoverColor as aR, clone as aS, _merger as aT, _mergerIf as aU, _deprecated as aV, _splitKey as aW, toFontString as aX, splineCurve as aY, splineCurveMonotone as aZ, getStyle as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, _elementsEqual as ah, _isClickEvent as ai, _isBetween as aj, _readValueToProps as ak, _updateBezierControlPoints as al, _computeSegments as am, _boundSegments as an, _steppedInterpolation as ao, _bezierInterpolation as ap, _pointInLine as aq, _steppedLineTo as ar, _bezierCurveTo as as, drawPoint as at, addRoundedRectPath as au, toTRBL as av, toTRBLCorners as aw, _boundSegment as ax, _normalizeAngle as ay, getRtlAdapter as az, isArray as b, toLineHeight as b0, PITAU as b1, INFINITY as b2, RAD_PER_DEG as b3, QUARTER_PI as b4, TWO_THIRDS_PI as b5, _angleDiff as b6, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };\n//# sourceMappingURL=helpers.segment.js.map\n"],"names":["noop","uid","id","isNullOrUndef","value","isArray","type","isObject","isNumberFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","toDimension","callback","fn","args","thisArg","each","loopable","reverse","i","len","keys","_elementsEqual","a0","a1","ilen","v0","v1","clone","source","target","klen","k","isValidKey","key","_merger","options","tval","sval","merge","sources","merger","current","mergeIf","_mergerIf","keyResolvers","v","o","_splitKey","parts","tmp","part","_getKeyResolver","obj","resolveObjectKey","_capitalize","str","defined","isFunction","setsEqual","a","b","item","_isClickEvent","PI","TAU","INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","x","y","epsilon","niceNum","range","roundedRange","niceRange","fraction","_factorize","result","sqrt","isNumber","n","almostWhole","rounded","_setMinAndMaxByKey","array","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","e","p","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","distanceBetweenPoints","pt1","pt2","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","s","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","min","max","_int16Range","_isBetween","_lookup","table","cmp","index","hi","lo","mid","_lookupByKey","last","ti","_rlookupByKey","_filterBetween","values","arrayEvents","listenArrayEvents","listener","method","base","res","object","unlistenArrayEvents","stub","listeners","_arrayUnique","items","set","requestAnimFrame","throttled","argsToUse","ticking","debounce","delay","timeout","_toLeftRightCenter","align","_alignStartEnd","_textX","left","right","rtl","atEdge","t","elasticIn","elasticOut","effects","isPatternOrGradient","color","Color","getHoverColor","numbers","colors","applyAnimationsDefaults","defaults","name","applyLayoutsDefaults","intlCache","getNumberFormat","locale","cacheKey","formatter","formatNumber","num","formatters","tickValue","ticks","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","remain","Ticks","applyScaleDefaults","_ctx","overrides","descriptors","getScope$1","node","root","scope","Defaults","_descriptors","_appliers","context","ctx","targetScope","targetName","scopeObject","targetScopeObject","privateName","local","appliers","apply","toFontString","font","_measureText","data","gc","longest","string","textWidth","_longestText","arrayOfThings","cache","j","jlen","thing","nestedThing","gcLen","_alignPixel","chart","pixel","width","devicePixelRatio","halfWidth","clearCanvas","canvas","drawPoint","drawPointLegend","w","xOffset","yOffset","size","cornerRadius","xOffsetW","yOffsetW","style","rotation","radius","rad","_isPointInArea","point","area","margin","clipArea","unclipArea","renderText","text","opts","lines","stroke","line","setRenderOpts","drawBackdrop","decorateText","metrics","top","bottom","yDecoration","oldColor","addRoundedRectPath","rect","h","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","numberOrZero","_readValueToProps","props","ret","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","resolve","inputs","info","cacheable","_addGrace","minmax","grace","beginAtZero","change","keepZero","add","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","getTarget","_resolve","_cached","_resolveWithPrefixes","getKeysFromAllScopes","storage","_attachContext","proxy","subProxy","descriptorDefaults","receiver","_resolveWithContext","_scriptable","_indexable","_allKeys","readKey","prefix","needsSubResolver","_proxy","_context","_subProxy","_resolveScriptable","_resolveArray","_stack","createSubResolver","isIndexable","arr","resolver","resolveFallback","getScope","parent","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","meta","count","iScale","parsed","_isDomSupported","_getParentNode","domNode","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","getStyle","el","positions","getPositionedStyle","styles","suffix","pos","useOffsetPos","getCanvasPosition","touches","offsetX","offsetY","box","getRelativePosition","event","currentDevicePixelRatio","borderBox","paddings","borders","height","getContainerSize","maxWidth","maxHeight","container","containerStyle","containerBorder","containerPadding","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","containerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","supportsEventListenerOptions","passiveSupported","readUsedSize","getRightToLeftAdapter","rectX","itemWidth","getLeftToRightAdapter","_itemWidth","getRtlAdapter","overrideTextDirection","direction","original","restoreTextDirection"],"mappings":"0KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAYI,SAASA,IAAO,CACR,CAGH,MAACC,IAAO,IAAI,CACjB,IAAIC,EAAK,EACT,MAAO,IAAIA,GACf,GAAK,EAKD,SAASC,EAAcC,EAAO,CAC9B,OAAOA,IAAU,MAAQ,OAAOA,EAAU,GAC9C,CAKI,SAASC,EAAQD,EAAO,CACxB,GAAI,MAAM,SAAW,MAAM,QAAQA,CAAK,EACpC,MAAO,GAEX,MAAME,EAAO,OAAO,UAAU,SAAS,KAAKF,CAAK,EACjD,OAAIE,EAAK,MAAM,EAAG,CAAC,IAAM,WAAaA,EAAK,MAAM,EAAE,IAAM,QAI7D,CAKI,SAASC,EAASH,EAAO,CACzB,OAAOA,IAAU,MAAQ,OAAO,UAAU,SAAS,KAAKA,CAAK,IAAM,iBACvE,CAII,SAASI,EAAeJ,EAAO,CAC/B,OAAQ,OAAOA,GAAU,UAAYA,aAAiB,SAAW,SAAS,CAACA,CAAK,CACpF,CAKI,SAASK,GAAgBL,EAAOM,EAAc,CAC9C,OAAOF,EAAeJ,CAAK,EAAIA,EAAQM,CAC3C,CAKI,SAASC,EAAeP,EAAOM,EAAc,CAC7C,OAAO,OAAON,EAAU,IAAcM,EAAeN,CACzD,CACK,MAACQ,GAAe,CAACR,EAAOS,IAAY,OAAOT,GAAU,UAAYA,EAAM,SAAS,GAAG,EAAI,WAAWA,CAAK,EAAI,IAAM,CAACA,EAAQS,EACzHC,GAAc,CAACV,EAAOS,IAAY,OAAOT,GAAU,UAAYA,EAAM,SAAS,GAAG,EAAI,WAAWA,CAAK,EAAI,IAAMS,EAAY,CAACT,EAO9H,SAASW,GAASC,EAAIC,EAAMC,EAAS,CACrC,GAAIF,GAAM,OAAOA,EAAG,MAAS,WACzB,OAAOA,EAAG,MAAME,EAASD,CAAI,CAErC,CACA,SAASE,GAAKC,EAAUJ,EAAIE,EAASG,EAAS,CAC1C,IAAIC,EAAGC,EAAKC,EACZ,GAAInB,EAAQe,CAAQ,EAEhB,GADAG,EAAMH,EAAS,OACXC,EACA,IAAIC,EAAIC,EAAM,EAAGD,GAAK,EAAGA,IACrBN,EAAG,KAAKE,EAASE,EAASE,GAAIA,CAAC,MAGnC,KAAIA,EAAI,EAAGA,EAAIC,EAAKD,IAChBN,EAAG,KAAKE,EAASE,EAASE,GAAIA,CAAC,UAGhCf,EAASa,CAAQ,EAGxB,IAFAI,EAAO,OAAO,KAAKJ,CAAQ,EAC3BG,EAAMC,EAAK,OACPF,EAAI,EAAGA,EAAIC,EAAKD,IAChBN,EAAG,KAAKE,EAASE,EAASI,EAAKF,IAAKE,EAAKF,EAAE,CAGvD,CAMI,SAASG,GAAeC,EAAIC,EAAI,CAChC,IAAIL,EAAGM,EAAMC,EAAIC,EACjB,GAAI,CAACJ,GAAM,CAACC,GAAMD,EAAG,SAAWC,EAAG,OAC/B,MAAO,GAEX,IAAIL,EAAI,EAAGM,EAAOF,EAAG,OAAQJ,EAAIM,EAAM,EAAEN,EAGrC,GAFAO,EAAKH,EAAGJ,GACRQ,EAAKH,EAAGL,GACJO,EAAG,eAAiBC,EAAG,cAAgBD,EAAG,QAAUC,EAAG,MACvD,MAAO,GAGf,MAAO,EACX,CAII,SAASC,EAAMC,EAAQ,CACvB,GAAI3B,EAAQ2B,CAAM,EACd,OAAOA,EAAO,IAAID,CAAK,EAE3B,GAAIxB,EAASyB,CAAM,EAAG,CAClB,MAAMC,EAAS,OAAO,OAAO,IAAI,EAC3BT,EAAO,OAAO,KAAKQ,CAAM,EACzBE,EAAOV,EAAK,OAClB,IAAIW,EAAI,EACR,KAAMA,EAAID,EAAM,EAAEC,EACdF,EAAOT,EAAKW,IAAMJ,EAAMC,EAAOR,EAAKW,GAAG,EAE3C,OAAOF,CACV,CACD,OAAOD,CACX,CACA,SAASI,GAAWC,EAAK,CACrB,MAAO,CACH,YACA,YACA,aACH,EAAC,QAAQA,CAAG,IAAM,EACvB,CAKI,SAASC,GAAQD,EAAKJ,EAAQD,EAAQO,EAAS,CAC/C,GAAI,CAACH,GAAWC,CAAG,EACf,OAEJ,MAAMG,EAAOP,EAAOI,GACdI,EAAOT,EAAOK,GAChB9B,EAASiC,CAAI,GAAKjC,EAASkC,CAAI,EAE/BC,EAAMF,EAAMC,EAAMF,CAAO,EAEzBN,EAAOI,GAAON,EAAMU,CAAI,CAEhC,CACA,SAASC,EAAMT,EAAQD,EAAQO,EAAS,CACpC,MAAMI,EAAUtC,EAAQ2B,CAAM,EAAIA,EAAS,CACvCA,CACR,EACUJ,EAAOe,EAAQ,OACrB,GAAI,CAACpC,EAAS0B,CAAM,EAChB,OAAOA,EAEXM,EAAUA,GAAW,GACrB,MAAMK,EAASL,EAAQ,QAAUD,GACjC,IAAIO,EACJ,QAAQvB,EAAI,EAAGA,EAAIM,EAAM,EAAEN,EAAE,CAEzB,GADAuB,EAAUF,EAAQrB,GACd,CAACf,EAASsC,CAAO,EACjB,SAEJ,MAAMrB,EAAO,OAAO,KAAKqB,CAAO,EAChC,QAAQV,EAAI,EAAGD,EAAOV,EAAK,OAAQW,EAAID,EAAM,EAAEC,EAC3CS,EAAOpB,EAAKW,GAAIF,EAAQY,EAASN,CAAO,CAE/C,CACD,OAAON,CACX,CACA,SAASa,GAAQb,EAAQD,EAAQ,CAE7B,OAAOU,EAAMT,EAAQD,EAAQ,CACzB,OAAQe,EAChB,CAAK,CACL,CAII,SAASA,GAAUV,EAAKJ,EAAQD,EAAQ,CACxC,GAAI,CAACI,GAAWC,CAAG,EACf,OAEJ,MAAMG,EAAOP,EAAOI,GACdI,EAAOT,EAAOK,GAChB9B,EAASiC,CAAI,GAAKjC,EAASkC,CAAI,EAC/BK,GAAQN,EAAMC,CAAI,EACV,OAAO,UAAU,eAAe,KAAKR,EAAQI,CAAG,IACxDJ,EAAOI,GAAON,EAAMU,CAAI,EAEhC,CASA,MAAMO,EAAe,CAEjB,GAAKC,GAAIA,EAET,EAAIC,GAAIA,EAAE,EACV,EAAIA,GAAIA,EAAE,CACd,EAGI,SAASC,GAAUd,EAAK,CACxB,MAAMe,EAAQf,EAAI,MAAM,GAAG,EACrBb,EAAO,CAAA,EACb,IAAI6B,EAAM,GACV,UAAWC,KAAQF,EACfC,GAAOC,EACHD,EAAI,SAAS,IAAI,EACjBA,EAAMA,EAAI,MAAM,EAAG,EAAE,EAAI,KAEzB7B,EAAK,KAAK6B,CAAG,EACbA,EAAM,IAGd,OAAO7B,CACX,CACA,SAAS+B,GAAgBlB,EAAK,CAC1B,MAAMb,EAAO2B,GAAUd,CAAG,EAC1B,OAAQmB,GAAM,CACV,UAAWrB,KAAKX,EAAK,CACjB,GAAIW,IAAM,GACN,MAEJqB,EAAMA,GAAOA,EAAIrB,EACpB,CACD,OAAOqB,CACf,CACA,CACA,SAASC,EAAiBD,EAAKnB,EAAK,CAEhC,OADiBW,EAAaX,KAASW,EAAaX,GAAOkB,GAAgBlB,CAAG,IAC9DmB,CAAG,CACvB,CAGI,SAASE,EAAYC,EAAK,CAC1B,OAAOA,EAAI,OAAO,CAAC,EAAE,YAAW,EAAKA,EAAI,MAAM,CAAC,CACpD,CACK,MAACC,EAAWxD,GAAQ,OAAOA,EAAU,IACpCyD,EAAczD,GAAQ,OAAOA,GAAU,WAEvC0D,GAAY,CAACC,EAAGC,IAAI,CACtB,GAAID,EAAE,OAASC,EAAE,KACb,MAAO,GAEX,UAAWC,KAAQF,EACf,GAAI,CAACC,EAAE,IAAIC,CAAI,EACX,MAAO,GAGf,MAAO,EACX,EAII,SAASC,GAAc,EAAG,CAC1B,OAAO,EAAE,OAAS,WAAa,EAAE,OAAS,SAAW,EAAE,OAAS,aACpE,CAKS,MAACC,EAAK,KAAK,GACdC,EAAM,EAAID,EAEVE,EAAW,OAAO,kBAClBC,GAAcH,EAAK,IACnBI,EAAUJ,EAAK,EACfK,EAAaL,EAAK,EAClBM,EAAgBN,EAAK,EAAI,EACzBO,EAAQ,KAAK,MACbC,GAAO,KAAK,KAClB,SAASC,GAAaC,EAAGC,EAAGC,EAAS,CACjC,OAAO,KAAK,IAAIF,EAAIC,CAAC,EAAIC,CAC7B,CAGI,SAASC,GAAQC,EAAO,CACxB,MAAMC,EAAe,KAAK,MAAMD,CAAK,EACrCA,EAAQL,GAAaK,EAAOC,EAAcD,EAAQ,GAAI,EAAIC,EAAeD,EACzE,MAAME,EAAY,KAAK,IAAI,GAAI,KAAK,MAAMT,EAAMO,CAAK,CAAC,CAAC,EACjDG,EAAWH,EAAQE,EAEzB,OADqBC,GAAY,EAAI,EAAIA,GAAY,EAAI,EAAIA,GAAY,EAAI,EAAI,IAC3DD,CAC1B,CAII,SAASE,GAAWjF,EAAO,CAC3B,MAAMkF,EAAS,CAAA,EACTC,EAAO,KAAK,KAAKnF,CAAK,EAC5B,IAAIkB,EACJ,IAAIA,EAAI,EAAGA,EAAIiE,EAAMjE,IACblB,EAAQkB,IAAM,IACdgE,EAAO,KAAKhE,CAAC,EACbgE,EAAO,KAAKlF,EAAQkB,CAAC,GAG7B,OAAIiE,KAAUA,EAAO,IACjBD,EAAO,KAAKC,CAAI,EAEpBD,EAAO,KAAK,CAACvB,EAAGC,IAAID,EAAIC,CAAC,EAAE,MACpBsB,CACX,CACA,SAASE,GAASC,EAAG,CACjB,MAAO,CAAC,MAAM,WAAWA,CAAC,CAAC,GAAK,SAASA,CAAC,CAC9C,CACA,SAASC,GAAYb,EAAGE,EAAS,CAC7B,MAAMY,EAAU,KAAK,MAAMd,CAAC,EAC5B,OAAOc,EAAUZ,GAAWF,GAAKc,EAAUZ,GAAWF,CAC1D,CAGI,SAASe,GAAmBC,EAAO5D,EAAQ6D,EAAU,CACrD,IAAIxE,EAAGM,EAAMxB,EACb,IAAIkB,EAAI,EAAGM,EAAOiE,EAAM,OAAQvE,EAAIM,EAAMN,IACtClB,EAAQyF,EAAMvE,GAAGwE,GACZ,MAAM1F,CAAK,IACZ6B,EAAO,IAAM,KAAK,IAAIA,EAAO,IAAK7B,CAAK,EACvC6B,EAAO,IAAM,KAAK,IAAIA,EAAO,IAAK7B,CAAK,EAGnD,CACA,SAAS2F,GAAUC,EAAS,CACxB,OAAOA,GAAW7B,EAAK,IAC3B,CACA,SAAS8B,GAAUC,EAAS,CACxB,OAAOA,GAAW,IAAM/B,EAC5B,CAOI,SAASgC,GAAetB,EAAG,CAC3B,GAAI,CAACrE,EAAeqE,CAAC,EACjB,OAEJ,IAAIuB,EAAI,EACJC,EAAI,EACR,KAAM,KAAK,MAAMxB,EAAIuB,CAAC,EAAIA,IAAMvB,GAC5BuB,GAAK,GACLC,IAEJ,OAAOA,CACX,CAEA,SAASC,GAAkBC,EAAaC,EAAY,CAChD,MAAMC,EAAsBD,EAAW,EAAID,EAAY,EACjDG,EAAsBF,EAAW,EAAID,EAAY,EACjDI,EAA2B,KAAK,KAAKF,EAAsBA,EAAsBC,EAAsBA,CAAmB,EAChI,IAAIE,EAAQ,KAAK,MAAMF,EAAqBD,CAAmB,EAC/D,OAAIG,EAAQ,IAAOzC,IACfyC,GAASxC,GAEN,CACH,MAAAwC,EACA,SAAUD,CAClB,CACA,CACA,SAASE,GAAsBC,EAAKC,EAAK,CACrC,OAAO,KAAK,KAAK,KAAK,IAAIA,EAAI,EAAID,EAAI,EAAG,CAAC,EAAI,KAAK,IAAIC,EAAI,EAAID,EAAI,EAAG,CAAC,CAAC,CAC5E,CAUI,SAASE,EAAgBjD,EAAG,CAC5B,OAAQA,EAAIK,EAAMA,GAAOA,CAC7B,CAGI,SAAS6C,GAAcL,EAAOM,EAAOC,EAAKC,EAAuB,CACjE,MAAMrD,EAAIiD,EAAgBJ,CAAK,EACzBS,EAAIL,EAAgBE,CAAK,EACzBd,EAAIY,EAAgBG,CAAG,EACvBG,EAAeN,EAAgBK,EAAItD,CAAC,EACpCwD,EAAaP,EAAgBZ,EAAIrC,CAAC,EAClCyD,EAAeR,EAAgBjD,EAAIsD,CAAC,EACpCI,EAAaT,EAAgBjD,EAAIqC,CAAC,EACxC,OAAOrC,IAAMsD,GAAKtD,IAAMqC,GAAKgB,GAAyBC,IAAMjB,GAAKkB,EAAeC,GAAcC,EAAeC,CACjH,CAOI,SAASC,GAAYtH,EAAOuH,EAAKC,EAAK,CACtC,OAAO,KAAK,IAAID,EAAK,KAAK,IAAIC,EAAKxH,CAAK,CAAC,CAC7C,CAII,SAASyH,GAAYzH,EAAO,CAC5B,OAAOsH,GAAYtH,EAAO,OAAQ,KAAK,CAC3C,CAOI,SAAS0H,GAAW1H,EAAO8G,EAAOC,EAAKpC,EAAU,KAAM,CACvD,OAAO3E,GAAS,KAAK,IAAI8G,EAAOC,CAAG,EAAIpC,GAAW3E,GAAS,KAAK,IAAI8G,EAAOC,CAAG,EAAIpC,CACtF,CAEA,SAASgD,EAAQC,EAAO5H,EAAO6H,EAAK,CAChCA,EAAMA,IAASC,GAAQF,EAAME,GAAS9H,GACtC,IAAI+H,EAAKH,EAAM,OAAS,EACpBI,EAAK,EACLC,EACJ,KAAMF,EAAKC,EAAK,GACZC,EAAMD,EAAKD,GAAM,EACbF,EAAII,CAAG,EACPD,EAAKC,EAELF,EAAKE,EAGb,MAAO,CACH,GAAAD,EACA,GAAAD,CACR,CACA,CAQS,MAACG,GAAe,CAACN,EAAO3F,EAAKjC,EAAOmI,IAAOR,EAAQC,EAAO5H,EAAOmI,EAAQL,GAAQ,CAClF,MAAMM,EAAKR,EAAME,GAAO7F,GACxB,OAAOmG,EAAKpI,GAASoI,IAAOpI,GAAS4H,EAAME,EAAQ,GAAG7F,KAASjC,CACvE,EAAS8H,GAAQF,EAAME,GAAO7F,GAAOjC,CAAK,EAOhCqI,GAAgB,CAACT,EAAO3F,EAAKjC,IAAQ2H,EAAQC,EAAO5H,EAAQ8H,GAAQF,EAAME,GAAO7F,IAAQjC,CAAK,EAOpG,SAASsI,GAAeC,EAAQhB,EAAKC,EAAK,CAC1C,IAAIV,EAAQ,EACRC,EAAMwB,EAAO,OACjB,KAAMzB,EAAQC,GAAOwB,EAAOzB,GAASS,GACjCT,IAEJ,KAAMC,EAAMD,GAASyB,EAAOxB,EAAM,GAAKS,GACnCT,IAEJ,OAAOD,EAAQ,GAAKC,EAAMwB,EAAO,OAASA,EAAO,MAAMzB,EAAOC,CAAG,EAAIwB,CACzE,CACA,MAAMC,GAAc,CAChB,OACA,MACA,QACA,SACA,SACJ,EACA,SAASC,GAAkBhD,EAAOiD,EAAU,CACxC,GAAIjD,EAAM,SAAU,CAChBA,EAAM,SAAS,UAAU,KAAKiD,CAAQ,EACtC,MACH,CACD,OAAO,eAAejD,EAAO,WAAY,CACrC,aAAc,GACd,WAAY,GACZ,MAAO,CACH,UAAW,CACPiD,CACH,CACJ,CACT,CAAK,EACDF,GAAY,QAASvG,GAAM,CACvB,MAAM0G,EAAS,UAAYrF,EAAYrB,CAAG,EACpC2G,EAAOnD,EAAMxD,GACnB,OAAO,eAAewD,EAAOxD,EAAK,CAC9B,aAAc,GACd,WAAY,GACZ,SAAUpB,EAAM,CACZ,MAAMgI,EAAMD,EAAK,MAAM,KAAM/H,CAAI,EACjC,OAAA4E,EAAM,SAAS,UAAU,QAASqD,GAAS,CACnC,OAAOA,EAAOH,IAAY,YAC1BG,EAAOH,GAAQ,GAAG9H,CAAI,CAE9C,CAAiB,EACMgI,CACV,CACb,CAAS,CACT,CAAK,CACL,CACA,SAASE,GAAoBtD,EAAOiD,EAAU,CAC1C,MAAMM,EAAOvD,EAAM,SACnB,GAAI,CAACuD,EACD,OAEJ,MAAMC,EAAYD,EAAK,UACjBlB,EAAQmB,EAAU,QAAQP,CAAQ,EACpCZ,IAAU,IACVmB,EAAU,OAAOnB,EAAO,CAAC,EAEzB,EAAAmB,EAAU,OAAS,KAGvBT,GAAY,QAASvG,GAAM,CACvB,OAAOwD,EAAMxD,EACrB,CAAK,EACD,OAAOwD,EAAM,SACjB,CAGI,SAASyD,GAAaC,EAAO,CAC7B,MAAMC,EAAM,IAAI,IAChB,IAAIlI,EAAGM,EACP,IAAIN,EAAI,EAAGM,EAAO2H,EAAM,OAAQjI,EAAIM,EAAM,EAAEN,EACxCkI,EAAI,IAAID,EAAMjI,EAAE,EAEpB,OAAIkI,EAAI,OAAS5H,EACN2H,EAEJ,MAAM,KAAKC,CAAG,CACzB,CAOQ,MAACC,GAAmB,UAAW,CACnC,OAAI,OAAO,OAAW,IACX,SAAS1I,EAAU,CACtB,OAAOA,EAAQ,CAC3B,EAEW,OAAO,qBAClB,EAAI,EAIA,SAAS2I,GAAU1I,EAAIE,EAAS,CAChC,IAAIyI,EAAY,CAAA,EACZC,EAAU,GACd,OAAO,YAAY3I,EAAM,CAErB0I,EAAY1I,EACP2I,IACDA,EAAU,GACVH,GAAiB,KAAK,OAAQ,IAAI,CAC9BG,EAAU,GACV5I,EAAG,MAAME,EAASyI,CAAS,CAC3C,CAAa,EAEb,CACA,CAGI,SAASE,GAAS7I,EAAI8I,EAAO,CAC7B,IAAIC,EACJ,OAAO,YAAY9I,EAAM,CACrB,OAAI6I,GACA,aAAaC,CAAO,EACpBA,EAAU,WAAW/I,EAAI8I,EAAO7I,CAAI,GAEpCD,EAAG,MAAM,KAAMC,CAAI,EAEhB6I,CACf,CACA,CAIS,MAACE,GAAsBC,GAAQA,IAAU,QAAU,OAASA,IAAU,MAAQ,QAAU,SAIvFC,GAAiB,CAACD,EAAO/C,EAAOC,IAAM8C,IAAU,QAAU/C,EAAQ+C,IAAU,MAAQ9C,GAAOD,EAAQC,GAAO,EAI1GgD,GAAS,CAACF,EAAOG,EAAMC,EAAOC,IAE7BL,KADOK,EAAM,OAAS,SACJD,EAAQJ,IAAU,UAAYG,EAAOC,GAAS,EAAID,EAqDzEG,EAAUC,GAAIA,IAAM,GAAKA,IAAM,EAC/BC,GAAY,CAACD,EAAGnD,EAAGhB,IAAI,EAAE,KAAK,IAAI,EAAG,IAAMmE,GAAK,EAAE,EAAI,KAAK,KAAKA,EAAInD,GAAKjD,EAAMiC,CAAC,GAChFqE,GAAa,CAACF,EAAGnD,EAAGhB,IAAI,KAAK,IAAI,EAAG,IAAMmE,CAAC,EAAI,KAAK,KAAKA,EAAInD,GAAKjD,EAAMiC,CAAC,EAAI,EAKzEsE,EAAU,CAChB,OAASH,GAAIA,EACb,WAAaA,GAAIA,EAAIA,EACrB,YAAcA,GAAI,CAACA,GAAKA,EAAI,GAC5B,cAAgBA,IAAKA,GAAK,IAAO,EAAI,GAAMA,EAAIA,EAAI,KAAQ,EAAEA,GAAKA,EAAI,GAAK,GAC3E,YAAcA,GAAIA,EAAIA,EAAIA,EAC1B,aAAeA,IAAKA,GAAK,GAAKA,EAAIA,EAAI,EACtC,eAAiBA,IAAKA,GAAK,IAAO,EAAI,GAAMA,EAAIA,EAAIA,EAAI,KAAQA,GAAK,GAAKA,EAAIA,EAAI,GAClF,YAAcA,GAAIA,EAAIA,EAAIA,EAAIA,EAC9B,aAAeA,GAAI,GAAGA,GAAK,GAAKA,EAAIA,EAAIA,EAAI,GAC5C,eAAiBA,IAAKA,GAAK,IAAO,EAAI,GAAMA,EAAIA,EAAIA,EAAIA,EAAI,MAASA,GAAK,GAAKA,EAAIA,EAAIA,EAAI,GAC3F,YAAcA,GAAIA,EAAIA,EAAIA,EAAIA,EAAIA,EAClC,aAAeA,IAAKA,GAAK,GAAKA,EAAIA,EAAIA,EAAIA,EAAI,EAC9C,eAAiBA,IAAKA,GAAK,IAAO,EAAI,GAAMA,EAAIA,EAAIA,EAAIA,EAAIA,EAAI,KAAQA,GAAK,GAAKA,EAAIA,EAAIA,EAAIA,EAAI,GAClG,WAAaA,GAAI,CAAC,KAAK,IAAIA,EAAIjG,CAAO,EAAI,EAC1C,YAAciG,GAAI,KAAK,IAAIA,EAAIjG,CAAO,EACtC,cAAgBiG,GAAI,KAAQ,KAAK,IAAIrG,EAAKqG,CAAC,EAAI,GAC/C,WAAaA,GAAIA,IAAM,EAAI,EAAI,KAAK,IAAI,EAAG,IAAMA,EAAI,EAAE,EACvD,YAAcA,GAAIA,IAAM,EAAI,EAAI,CAAC,KAAK,IAAI,EAAG,IAAMA,CAAC,EAAI,EACxD,cAAgBA,GAAID,EAAOC,CAAC,EAAIA,EAAIA,EAAI,GAAM,GAAM,KAAK,IAAI,EAAG,IAAMA,EAAI,EAAI,EAAE,EAAI,IAAO,CAAC,KAAK,IAAI,EAAG,KAAOA,EAAI,EAAI,EAAE,EAAI,GAC7H,WAAaA,GAAIA,GAAK,EAAIA,EAAI,EAAE,KAAK,KAAK,EAAIA,EAAIA,CAAC,EAAI,GACvD,YAAcA,GAAI,KAAK,KAAK,GAAKA,GAAK,GAAKA,CAAC,EAC5C,cAAgBA,IAAKA,GAAK,IAAO,EAAI,KAAQ,KAAK,KAAK,EAAIA,EAAIA,CAAC,EAAI,GAAK,IAAO,KAAK,KAAK,GAAKA,GAAK,GAAKA,CAAC,EAAI,GAC9G,cAAgBA,GAAID,EAAOC,CAAC,EAAIA,EAAIC,GAAUD,EAAG,KAAO,EAAG,EAC3D,eAAiBA,GAAID,EAAOC,CAAC,EAAIA,EAAIE,GAAWF,EAAG,KAAO,EAAG,EAC7D,iBAAkBA,EAAG,CAGjB,OAAOD,EAAOC,CAAC,EAAIA,EAAIA,EAAI,GAAM,GAAMC,GAAUD,EAAI,EAAG,MAAG,GAAC,EAAI,GAAM,GAAME,GAAWF,EAAI,EAAI,EAAG,MAAG,GAAC,CACzG,EACD,WAAYA,EAAG,CAEX,OAAOA,EAAIA,IAAM,QAAI,GAAKA,EAAI,QACjC,EACD,YAAaA,EAAG,CAEZ,OAAQA,GAAK,GAAKA,IAAM,QAAI,GAAKA,EAAI,SAAK,CAC7C,EACD,cAAeA,EAAG,CACd,IAAInD,EAAI,QACR,OAAKmD,GAAK,IAAO,EACN,IAAOA,EAAIA,KAAOnD,GAAK,OAAS,GAAKmD,EAAInD,IAE7C,KAAQmD,GAAK,GAAKA,KAAOnD,GAAK,OAAS,GAAKmD,EAAInD,GAAK,EAC/D,EACD,aAAemD,GAAI,EAAIG,EAAQ,cAAc,EAAIH,CAAC,EAClD,cAAeA,EAAG,CAGd,OAAIA,EAAI,EAAI,KACD,OAAIA,EAAIA,EAEfA,EAAI,EAAI,KACD,QAAKA,GAAK,IAAM,MAAKA,EAAI,IAEhCA,EAAI,IAAM,KACH,QAAKA,GAAK,KAAO,MAAKA,EAAI,MAE9B,QAAKA,GAAK,MAAQ,MAAKA,EAAI,OACrC,EACD,gBAAkBA,GAAIA,EAAI,GAAMG,EAAQ,aAAaH,EAAI,CAAC,EAAI,GAAMG,EAAQ,cAAcH,EAAI,EAAI,CAAC,EAAI,GAAM,EACjH,EAEA,SAASI,EAAoBxK,EAAO,CAChC,GAAIA,GAAS,OAAOA,GAAU,SAAU,CACpC,MAAME,EAAOF,EAAM,WACnB,OAAOE,IAAS,0BAA4BA,IAAS,yBACxD,CACD,MAAO,EACX,CACA,SAASuK,GAAMzK,EAAO,CAClB,OAAOwK,EAAoBxK,CAAK,EAAIA,EAAQ,IAAI0K,GAAAA,MAAM1K,CAAK,CAC/D,CACA,SAAS2K,EAAc3K,EAAO,CAC1B,OAAOwK,EAAoBxK,CAAK,EAAIA,EAAQ,IAAI0K,GAAK,MAAC1K,CAAK,EAAE,SAAS,EAAG,EAAE,OAAO,EAAG,EAAE,UAAS,CACpG,CAEA,MAAM4K,GAAU,CACZ,IACA,IACA,cACA,SACA,SACJ,EACMC,GAAS,CACX,QACA,cACA,iBACJ,EACA,SAASC,GAAwBC,EAAU,CACvCA,EAAS,IAAI,YAAa,CACtB,MAAO,OACP,SAAU,IACV,OAAQ,eACR,GAAI,OACJ,KAAM,OACN,KAAM,OACN,GAAI,OACJ,KAAM,MACd,CAAK,EACDA,EAAS,SAAS,YAAa,CAC3B,UAAW,GACX,WAAY,GACZ,YAAcC,GAAOA,IAAS,cAAgBA,IAAS,cAAgBA,IAAS,IACxF,CAAK,EACDD,EAAS,IAAI,aAAc,CACvB,OAAQ,CACJ,KAAM,QACN,WAAYF,EACf,EACD,QAAS,CACL,KAAM,SACN,WAAYD,EACf,CACT,CAAK,EACDG,EAAS,SAAS,aAAc,CAC5B,UAAW,WACnB,CAAK,EACDA,EAAS,IAAI,cAAe,CACxB,OAAQ,CACJ,UAAW,CACP,SAAU,GACb,CACJ,EACD,OAAQ,CACJ,UAAW,CACP,SAAU,CACb,CACJ,EACD,KAAM,CACF,WAAY,CACR,OAAQ,CACJ,KAAM,aACT,EACD,QAAS,CACL,KAAM,UACN,SAAU,CACb,CACJ,CACJ,EACD,KAAM,CACF,WAAY,CACR,OAAQ,CACJ,GAAI,aACP,EACD,QAAS,CACL,KAAM,UACN,OAAQ,SACR,GAAKlI,GAAIA,EAAI,CAChB,CACJ,CACJ,CACT,CAAK,CACL,CAEA,SAASoI,GAAqBF,EAAU,CACpCA,EAAS,IAAI,SAAU,CACnB,YAAa,GACb,QAAS,CACL,IAAK,EACL,MAAO,EACP,OAAQ,EACR,KAAM,CACT,CACT,CAAK,CACL,CAEA,MAAMG,GAAY,IAAI,IACtB,SAASC,GAAgBC,EAAQjJ,EAAS,CACtCA,EAAUA,GAAW,GACrB,MAAMkJ,EAAWD,EAAS,KAAK,UAAUjJ,CAAO,EAChD,IAAImJ,EAAYJ,GAAU,IAAIG,CAAQ,EACtC,OAAKC,IACDA,EAAY,IAAI,KAAK,aAAaF,EAAQjJ,CAAO,EACjD+I,GAAU,IAAIG,EAAUC,CAAS,GAE9BA,CACX,CACA,SAASC,GAAaC,EAAKJ,EAAQjJ,EAAS,CACxC,OAAOgJ,GAAgBC,EAAQjJ,CAAO,EAAE,OAAOqJ,CAAG,CACtD,CAEA,MAAMC,GAAa,CAClB,OAAQzL,EAAO,CACR,OAAOC,EAAQD,CAAK,EAAKA,EAAQ,GAAKA,CACzC,EACJ,QAAS0L,EAAW5D,EAAO6D,EAAO,CAC3B,GAAID,IAAc,EACd,MAAO,IAEX,MAAMN,EAAS,KAAK,MAAM,QAAQ,OAClC,IAAIQ,EACAC,EAAQH,EACZ,GAAIC,EAAM,OAAS,EAAG,CAClB,MAAMG,EAAU,KAAK,IAAI,KAAK,IAAIH,EAAM,GAAG,KAAK,EAAG,KAAK,IAAIA,EAAMA,EAAM,OAAS,GAAG,KAAK,CAAC,GACtFG,EAAU,MAAQA,EAAU,QAC5BF,EAAW,cAEfC,EAAQE,GAAeL,EAAWC,CAAK,CAC1C,CACD,MAAMK,EAAW1H,EAAM,KAAK,IAAIuH,CAAK,CAAC,EAChCI,EAAa,KAAK,IAAI,KAAK,IAAI,GAAK,KAAK,MAAMD,CAAQ,EAAG,EAAE,EAAG,CAAC,EAChE7J,EAAU,CACZ,SAAAyJ,EACA,sBAAuBK,EACvB,sBAAuBA,CACnC,EACQ,cAAO,OAAO9J,EAAS,KAAK,QAAQ,MAAM,MAAM,EACzCoJ,GAAaG,EAAWN,EAAQjJ,CAAO,CACjD,EACJ,YAAauJ,EAAW5D,EAAO6D,EAAO,CAC/B,GAAID,IAAc,EACd,MAAO,IAEX,MAAMQ,EAASP,EAAM7D,GAAO,aAAe4D,EAAY,KAAK,IAAI,GAAI,KAAK,MAAMpH,EAAMoH,CAAS,CAAC,CAAC,EAChG,MAAI,CACA,EACA,EACA,EACA,EACA,GACA,EACZ,EAAU,SAASQ,CAAM,GAAKpE,EAAQ,GAAM6D,EAAM,OAC/BF,GAAW,QAAQ,KAAK,KAAMC,EAAW5D,EAAO6D,CAAK,EAEzD,EACV,CACL,EACA,SAASI,GAAeL,EAAWC,EAAO,CACtC,IAAIE,EAAQF,EAAM,OAAS,EAAIA,EAAM,GAAG,MAAQA,EAAM,GAAG,MAAQA,EAAM,GAAG,MAAQA,EAAM,GAAG,MAC3F,OAAI,KAAK,IAAIE,CAAK,GAAK,GAAKH,IAAc,KAAK,MAAMA,CAAS,IAC1DG,EAAQH,EAAY,KAAK,MAAMA,CAAS,GAErCG,CACX,CACI,IAACM,GAAQ,CACT,WAAAV,EACJ,EAEA,SAASW,GAAmBrB,EAAU,CAClCA,EAAS,IAAI,QAAS,CAClB,QAAS,GACT,OAAQ,GACR,QAAS,GACT,YAAa,GACpB,OAAQ,QACR,MAAO,EACA,KAAM,CACF,QAAS,GACT,UAAW,EACX,gBAAiB,GACjB,UAAW,GACX,WAAY,EACZ,UAAW,CAACsB,EAAMlK,IAAUA,EAAQ,UACpC,UAAW,CAACkK,EAAMlK,IAAUA,EAAQ,MACpC,OAAQ,EACX,EACD,OAAQ,CACJ,QAAS,GACT,KAAM,CAAE,EACR,WAAY,EACZ,MAAO,CACV,EACD,MAAO,CACH,QAAS,GACT,KAAM,GACN,QAAS,CACL,IAAK,EACL,OAAQ,CACX,CACJ,EACD,MAAO,CACH,YAAa,EACb,YAAa,GACb,OAAQ,GACR,gBAAiB,EACjB,gBAAiB,GACjB,QAAS,EACT,QAAS,GACT,SAAU,GACV,gBAAiB,EACjB,YAAa,EACb,SAAUgK,GAAM,WAAW,OAC3B,MAAO,CAAE,EACT,MAAO,CAAE,EACT,MAAO,SACP,WAAY,OACZ,kBAAmB,GACnB,cAAe,4BACf,gBAAiB,CACpB,CACT,CAAK,EACDpB,EAAS,MAAM,cAAe,QAAS,GAAI,OAAO,EAClDA,EAAS,MAAM,aAAc,QAAS,GAAI,aAAa,EACvDA,EAAS,MAAM,eAAgB,QAAS,GAAI,aAAa,EACzDA,EAAS,MAAM,cAAe,QAAS,GAAI,OAAO,EAClDA,EAAS,SAAS,QAAS,CACvB,UAAW,GACX,YAAcC,GAAO,CAACA,EAAK,WAAW,QAAQ,GAAK,CAACA,EAAK,WAAW,OAAO,GAAKA,IAAS,YAAcA,IAAS,SAChH,WAAaA,GAAOA,IAAS,cAAgBA,IAAS,kBAAoBA,IAAS,MAC3F,CAAK,EACDD,EAAS,SAAS,SAAU,CACxB,UAAW,OACnB,CAAK,EACDA,EAAS,SAAS,cAAe,CAC7B,YAAcC,GAAOA,IAAS,mBAAqBA,IAAS,WAC5D,WAAaA,GAAOA,IAAS,iBACrC,CAAK,CACL,CAEK,MAACsB,GAAY,OAAO,OAAO,IAAI,EAC9BC,GAAc,OAAO,OAAO,IAAI,EACrC,SAASC,EAAWC,EAAMxK,EAAK,CAC5B,GAAI,CAACA,EACD,OAAOwK,EAEX,MAAMrL,EAAOa,EAAI,MAAM,GAAG,EAC1B,QAAQf,EAAI,EAAGmE,EAAIjE,EAAK,OAAQF,EAAImE,EAAG,EAAEnE,EAAE,CACvC,MAAMa,EAAIX,EAAKF,GACfuL,EAAOA,EAAK1K,KAAO0K,EAAK1K,GAAK,OAAO,OAAO,IAAI,EAClD,CACD,OAAO0K,CACX,CACA,SAASrD,EAAIsD,EAAMC,EAAOpE,EAAQ,CAC9B,OAAI,OAAOoE,GAAU,SACVrK,EAAMkK,EAAWE,EAAMC,CAAK,EAAGpE,CAAM,EAEzCjG,EAAMkK,EAAWE,EAAM,EAAE,EAAGC,CAAK,CAC5C,CACC,MAAMC,EAAS,CACZ,YAAYC,EAAcC,EAAU,CAChC,KAAK,UAAY,OACjB,KAAK,gBAAkB,kBACvB,KAAK,YAAc,kBACnB,KAAK,MAAQ,OACb,KAAK,SAAW,GAChB,KAAK,iBAAoBC,GAAUA,EAAQ,MAAM,SAAS,sBAC1D,KAAK,SAAW,GAChB,KAAK,OAAS,CACV,YACA,WACA,QACA,aACA,WACZ,EACQ,KAAK,KAAO,CACR,OAAQ,qDACR,KAAM,GACN,MAAO,SACP,WAAY,IACZ,OAAQ,IACpB,EACQ,KAAK,MAAQ,GACb,KAAK,qBAAuB,CAACC,EAAK7K,IAAUwI,EAAcxI,EAAQ,eAAe,EACjF,KAAK,iBAAmB,CAAC6K,EAAK7K,IAAUwI,EAAcxI,EAAQ,WAAW,EACzE,KAAK,WAAa,CAAC6K,EAAK7K,IAAUwI,EAAcxI,EAAQ,KAAK,EAC7D,KAAK,UAAY,IACjB,KAAK,YAAc,CACf,KAAM,UACN,UAAW,GACX,iBAAkB,EAC9B,EACQ,KAAK,oBAAsB,GAC3B,KAAK,QAAU,KACf,KAAK,QAAU,KACf,KAAK,QAAU,GACf,KAAK,QAAU,GACf,KAAK,WAAa,GAClB,KAAK,MAAQ,OACb,KAAK,OAAS,GACd,KAAK,SAAW,GAChB,KAAK,wBAA0B,GAC/B,KAAK,SAAS0K,CAAY,EAC1B,KAAK,MAAMC,CAAS,CACvB,CACJ,IAAIH,EAAOpE,EAAQ,CACZ,OAAOa,EAAI,KAAMuD,EAAOpE,CAAM,CACjC,CACJ,IAAIoE,EAAO,CACJ,OAAOH,EAAW,KAAMG,CAAK,CAChC,CACJ,SAASA,EAAOpE,EAAQ,CACjB,OAAOa,EAAImD,GAAaI,EAAOpE,CAAM,CACxC,CACD,SAASoE,EAAOpE,EAAQ,CACpB,OAAOa,EAAIkD,GAAWK,EAAOpE,CAAM,CACtC,CACJ,MAAMoE,EAAO3B,EAAMiC,EAAaC,EAAY,CACrC,MAAMC,EAAcX,EAAW,KAAMG,CAAK,EACpCS,EAAoBZ,EAAW,KAAMS,CAAW,EAChDI,EAAc,IAAMrC,EAC1B,OAAO,iBAAiBmC,EAAa,CACjC,CAACE,GAAc,CACX,MAAOF,EAAYnC,GACnB,SAAU,EACb,EACD,CAACA,GAAO,CACJ,WAAY,GACZ,KAAO,CACH,MAAMsC,EAAQ,KAAKD,GACbxL,EAASuL,EAAkBF,GACjC,OAAI/M,EAASmN,CAAK,EACP,OAAO,OAAO,CAAE,EAAEzL,EAAQyL,CAAK,EAEnC/M,EAAe+M,EAAOzL,CAAM,CACtC,EACD,IAAK7B,EAAO,CACR,KAAKqN,GAAerN,CACvB,CACJ,CACb,CAAS,CACJ,CACD,MAAMuN,EAAU,CACZA,EAAS,QAASC,GAAQA,EAAM,IAAI,CAAC,CACxC,CACL,CACG,IAACzC,GAA2B,IAAI6B,GAAS,CACxC,YAAc5B,GAAO,CAACA,EAAK,WAAW,IAAI,EAC1C,WAAaA,GAAOA,IAAS,SAC7B,MAAO,CACH,UAAW,aACd,EACD,YAAa,CACT,YAAa,GACb,WAAY,EACf,CACL,EAAG,CACCF,GACAG,GACAmB,EACJ,CAAC,EAED,SAASqB,GAAaC,EAAM,CACxB,MAAI,CAACA,GAAQ3N,EAAc2N,EAAK,IAAI,GAAK3N,EAAc2N,EAAK,MAAM,EACvD,MAEHA,EAAK,MAAQA,EAAK,MAAQ,IAAM,KAAOA,EAAK,OAASA,EAAK,OAAS,IAAM,IAAMA,EAAK,KAAO,MAAQA,EAAK,MACpH,CACC,SAASC,EAAaX,EAAKY,EAAMC,EAAIC,EAASC,EAAQ,CACnD,IAAIC,EAAYJ,EAAKG,GACrB,OAAKC,IACDA,EAAYJ,EAAKG,GAAUf,EAAI,YAAYe,CAAM,EAAE,MACnDF,EAAG,KAAKE,CAAM,GAEdC,EAAYF,IACZA,EAAUE,GAEPF,CACX,CACC,SAASG,GAAajB,EAAKU,EAAMQ,EAAeC,EAAO,CACpDA,EAAQA,GAAS,GACjB,IAAIP,EAAOO,EAAM,KAAOA,EAAM,MAAQ,CAAA,EAClCN,EAAKM,EAAM,eAAiBA,EAAM,gBAAkB,CAAA,EACpDA,EAAM,OAAST,IACfE,EAAOO,EAAM,KAAO,GACpBN,EAAKM,EAAM,eAAiB,GAC5BA,EAAM,KAAOT,GAEjBV,EAAI,KAAI,EACRA,EAAI,KAAOU,EACX,IAAII,EAAU,EACd,MAAMtM,EAAO0M,EAAc,OAC3B,IAAIhN,EAAGkN,EAAGC,EAAMC,EAAOC,EACvB,IAAIrN,EAAI,EAAGA,EAAIM,EAAMN,IAEjB,GADAoN,EAAQJ,EAAchN,GACKoN,GAAU,MAAQrO,EAAQqO,CAAK,IAAM,GAC5DR,EAAUH,EAAaX,EAAKY,EAAMC,EAAIC,EAASQ,CAAK,UAC7CrO,EAAQqO,CAAK,EACpB,IAAIF,EAAI,EAAGC,EAAOC,EAAM,OAAQF,EAAIC,EAAMD,IACtCG,EAAcD,EAAMF,GACaG,GAAgB,MAAQ,CAACtO,EAAQsO,CAAW,IACzET,EAAUH,EAAaX,EAAKY,EAAMC,EAAIC,EAASS,CAAW,GAK1EvB,EAAI,QAAO,EACX,MAAMwB,EAAQX,EAAG,OAAS,EAC1B,GAAIW,EAAQN,EAAc,OAAQ,CAC9B,IAAIhN,EAAI,EAAGA,EAAIsN,EAAOtN,IAClB,OAAO0M,EAAKC,EAAG3M,IAEnB2M,EAAG,OAAO,EAAGW,CAAK,CACrB,CACD,OAAOV,CACX,CACC,SAASW,GAAYC,EAAOC,EAAOC,EAAO,CACvC,MAAMC,EAAmBH,EAAM,wBACzBI,EAAYF,IAAU,EAAI,KAAK,IAAIA,EAAQ,EAAG,EAAG,EAAI,EAC3D,OAAO,KAAK,OAAOD,EAAQG,GAAaD,CAAgB,EAAIA,EAAmBC,CACnF,CACC,SAASC,GAAYC,EAAQhC,EAAK,CAC/BA,EAAMA,GAAOgC,EAAO,WAAW,IAAI,EACnChC,EAAI,KAAI,EACRA,EAAI,eAAc,EAClBA,EAAI,UAAU,EAAG,EAAGgC,EAAO,MAAOA,EAAO,MAAM,EAC/ChC,EAAI,QAAO,CACf,CACA,SAASiC,GAAUjC,EAAK7K,EAASsC,EAAGC,EAAG,CACnCwK,GAAgBlC,EAAK7K,EAASsC,EAAGC,EAAG,IAAI,CAC5C,CACA,SAASwK,GAAgBlC,EAAK7K,EAASsC,EAAGC,EAAGyK,EAAG,CAC5C,IAAIjP,EAAMkP,EAASC,EAASC,EAAMC,EAAcX,EAAOY,EAAUC,EACjE,MAAMC,EAAQvN,EAAQ,WAChBwN,EAAWxN,EAAQ,SACnByN,EAASzN,EAAQ,OACvB,IAAI0N,GAAOF,GAAY,GAAKzL,GAC5B,GAAIwL,GAAS,OAAOA,GAAU,WAC1BxP,EAAOwP,EAAM,WACTxP,IAAS,6BAA+BA,IAAS,8BAA8B,CAC/E8M,EAAI,KAAI,EACRA,EAAI,UAAUvI,EAAGC,CAAC,EAClBsI,EAAI,OAAO6C,CAAG,EACd7C,EAAI,UAAU0C,EAAO,CAACA,EAAM,MAAQ,EAAG,CAACA,EAAM,OAAS,EAAGA,EAAM,MAAOA,EAAM,MAAM,EACnF1C,EAAI,QAAO,EACX,MACH,CAEL,GAAI,QAAM4C,CAAM,GAAKA,GAAU,GAI/B,QADA5C,EAAI,UAAS,EACN0C,EAAK,CACR,QACQP,EACAnC,EAAI,QAAQvI,EAAGC,EAAGyK,EAAI,EAAGS,EAAQ,EAAG,EAAG5L,CAAG,EAE1CgJ,EAAI,IAAIvI,EAAGC,EAAGkL,EAAQ,EAAG5L,CAAG,EAEhCgJ,EAAI,UAAS,EACb,MACJ,IAAK,WACD4B,EAAQO,EAAIA,EAAI,EAAIS,EACpB5C,EAAI,OAAOvI,EAAI,KAAK,IAAIoL,CAAG,EAAIjB,EAAOlK,EAAI,KAAK,IAAImL,CAAG,EAAID,CAAM,EAChEC,GAAOxL,EACP2I,EAAI,OAAOvI,EAAI,KAAK,IAAIoL,CAAG,EAAIjB,EAAOlK,EAAI,KAAK,IAAImL,CAAG,EAAID,CAAM,EAChEC,GAAOxL,EACP2I,EAAI,OAAOvI,EAAI,KAAK,IAAIoL,CAAG,EAAIjB,EAAOlK,EAAI,KAAK,IAAImL,CAAG,EAAID,CAAM,EAChE5C,EAAI,UAAS,EACb,MACJ,IAAK,cACDuC,EAAeK,EAAS,KACxBN,EAAOM,EAASL,EAChBH,EAAU,KAAK,IAAIS,EAAMzL,CAAU,EAAIkL,EACvCE,EAAW,KAAK,IAAIK,EAAMzL,CAAU,GAAK+K,EAAIA,EAAI,EAAII,EAAeD,GACpED,EAAU,KAAK,IAAIQ,EAAMzL,CAAU,EAAIkL,EACvCG,EAAW,KAAK,IAAII,EAAMzL,CAAU,GAAK+K,EAAIA,EAAI,EAAII,EAAeD,GACpEtC,EAAI,IAAIvI,EAAI+K,EAAU9K,EAAI2K,EAASE,EAAcM,EAAM9L,EAAI8L,EAAM1L,CAAO,EACxE6I,EAAI,IAAIvI,EAAIgL,EAAU/K,EAAI0K,EAASG,EAAcM,EAAM1L,EAAS0L,CAAG,EACnE7C,EAAI,IAAIvI,EAAI+K,EAAU9K,EAAI2K,EAASE,EAAcM,EAAKA,EAAM1L,CAAO,EACnE6I,EAAI,IAAIvI,EAAIgL,EAAU/K,EAAI0K,EAASG,EAAcM,EAAM1L,EAAS0L,EAAM9L,CAAE,EACxEiJ,EAAI,UAAS,EACb,MACJ,IAAK,OACD,GAAI,CAAC2C,EAAU,CACXL,EAAO,KAAK,QAAUM,EACtBhB,EAAQO,EAAIA,EAAI,EAAIG,EACpBtC,EAAI,KAAKvI,EAAImK,EAAOlK,EAAI4K,EAAM,EAAIV,EAAO,EAAIU,CAAI,EACjD,KACH,CACDO,GAAOzL,EACV,IAAK,UACFoL,EAAW,KAAK,IAAIK,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxCR,EAAU,KAAK,IAAIS,CAAG,EAAID,EAC1BP,EAAU,KAAK,IAAIQ,CAAG,EAAID,EAC1BH,EAAW,KAAK,IAAII,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxC5C,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCpC,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCpC,EAAI,UAAS,EACb,MACJ,IAAK,WACD6C,GAAOzL,EACV,IAAK,QACFoL,EAAW,KAAK,IAAIK,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxCR,EAAU,KAAK,IAAIS,CAAG,EAAID,EAC1BP,EAAU,KAAK,IAAIQ,CAAG,EAAID,EAC1BH,EAAW,KAAK,IAAII,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxC5C,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCpC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpC,MACJ,IAAK,OACDI,EAAW,KAAK,IAAIK,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxCR,EAAU,KAAK,IAAIS,CAAG,EAAID,EAC1BP,EAAU,KAAK,IAAIQ,CAAG,EAAID,EAC1BH,EAAW,KAAK,IAAII,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxC5C,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCpC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCS,GAAOzL,EACPoL,EAAW,KAAK,IAAIK,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxCR,EAAU,KAAK,IAAIS,CAAG,EAAID,EAC1BP,EAAU,KAAK,IAAIQ,CAAG,EAAID,EAC1BH,EAAW,KAAK,IAAII,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GACxC5C,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAI+K,EAAU9K,EAAI2K,CAAO,EACpCrC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpCpC,EAAI,OAAOvI,EAAIgL,EAAU/K,EAAI0K,CAAO,EACpC,MACJ,IAAK,OACDA,EAAUD,EAAIA,EAAI,EAAI,KAAK,IAAIU,CAAG,EAAID,EACtCP,EAAU,KAAK,IAAIQ,CAAG,EAAID,EAC1B5C,EAAI,OAAOvI,EAAI2K,EAAS1K,EAAI2K,CAAO,EACnCrC,EAAI,OAAOvI,EAAI2K,EAAS1K,EAAI2K,CAAO,EACnC,MACJ,IAAK,OACDrC,EAAI,OAAOvI,EAAGC,CAAC,EACfsI,EAAI,OAAOvI,EAAI,KAAK,IAAIoL,CAAG,GAAKV,EAAIA,EAAI,EAAIS,GAASlL,EAAI,KAAK,IAAImL,CAAG,EAAID,CAAM,EAC/E,MACJ,IAAK,GACD5C,EAAI,UAAS,EACb,KACP,CACDA,EAAI,KAAI,EACJ7K,EAAQ,YAAc,GACtB6K,EAAI,OAAM,EAElB,CACC,SAAS8C,GAAeC,EAAOC,EAAMC,EAAQ,CAC1C,OAAAA,EAASA,GAAU,GACZ,CAACD,GAAQD,GAASA,EAAM,EAAIC,EAAK,KAAOC,GAAUF,EAAM,EAAIC,EAAK,MAAQC,GAAUF,EAAM,EAAIC,EAAK,IAAMC,GAAUF,EAAM,EAAIC,EAAK,OAASC,CACrJ,CACA,SAASC,GAASlD,EAAKgD,EAAM,CACzBhD,EAAI,KAAI,EACRA,EAAI,UAAS,EACbA,EAAI,KAAKgD,EAAK,KAAMA,EAAK,IAAKA,EAAK,MAAQA,EAAK,KAAMA,EAAK,OAASA,EAAK,GAAG,EAC5EhD,EAAI,KAAI,CACZ,CACA,SAASmD,GAAWnD,EAAK,CACrBA,EAAI,QAAO,CACf,CAsBC,SAASoD,GAAWpD,EAAKqD,EAAM5L,EAAGC,EAAGgJ,EAAM4C,EAAO,GAAI,CACnD,MAAMC,EAAQtQ,EAAQoQ,CAAI,EAAIA,EAAO,CACjCA,CACR,EACUG,EAASF,EAAK,YAAc,GAAKA,EAAK,cAAgB,GAC5D,IAAIpP,EAAGuP,EAIP,IAHAzD,EAAI,KAAI,EACRA,EAAI,KAAOU,EAAK,OAChBgD,GAAc1D,EAAKsD,CAAI,EACnBpP,EAAI,EAAGA,EAAIqP,EAAM,OAAQ,EAAErP,EAC3BuP,EAAOF,EAAMrP,GACToP,EAAK,UACLK,GAAa3D,EAAKsD,EAAK,QAAQ,EAE/BE,IACIF,EAAK,cACLtD,EAAI,YAAcsD,EAAK,aAEtBvQ,EAAcuQ,EAAK,WAAW,IAC/BtD,EAAI,UAAYsD,EAAK,aAEzBtD,EAAI,WAAWyD,EAAMhM,EAAGC,EAAG4L,EAAK,QAAQ,GAE5CtD,EAAI,SAASyD,EAAMhM,EAAGC,EAAG4L,EAAK,QAAQ,EACtCM,GAAa5D,EAAKvI,EAAGC,EAAG+L,EAAMH,CAAI,EAClC5L,GAAKgJ,EAAK,WAEdV,EAAI,QAAO,CACf,CACA,SAAS0D,GAAc1D,EAAKsD,EAAM,CAC1BA,EAAK,aACLtD,EAAI,UAAUsD,EAAK,YAAY,GAAIA,EAAK,YAAY,EAAE,EAErDvQ,EAAcuQ,EAAK,QAAQ,GAC5BtD,EAAI,OAAOsD,EAAK,QAAQ,EAExBA,EAAK,QACLtD,EAAI,UAAYsD,EAAK,OAErBA,EAAK,YACLtD,EAAI,UAAYsD,EAAK,WAErBA,EAAK,eACLtD,EAAI,aAAesD,EAAK,aAEhC,CACA,SAASM,GAAa5D,EAAKvI,EAAGC,EAAG+L,EAAMH,EAAM,CACzC,GAAIA,EAAK,eAAiBA,EAAK,UAAW,CAC7C,MAAMO,EAAU7D,EAAI,YAAYyD,CAAI,EACvBzG,EAAOvF,EAAIoM,EAAQ,sBACnB5G,EAAQxF,EAAIoM,EAAQ,uBACpBC,EAAMpM,EAAImM,EAAQ,wBAClBE,EAASrM,EAAImM,EAAQ,yBACrBG,EAAcV,EAAK,eAAiBQ,EAAMC,GAAU,EAAIA,EAC9D/D,EAAI,YAAcA,EAAI,UACtBA,EAAI,UAAS,EACbA,EAAI,UAAYsD,EAAK,iBAAmB,EACxCtD,EAAI,OAAOhD,EAAMgH,CAAW,EAC5BhE,EAAI,OAAO/C,EAAO+G,CAAW,EAC7BhE,EAAI,OAAM,CACb,CACL,CACA,SAAS2D,GAAa3D,EAAKsD,EAAM,CAC7B,MAAMW,EAAWjE,EAAI,UACrBA,EAAI,UAAYsD,EAAK,MACrBtD,EAAI,SAASsD,EAAK,KAAMA,EAAK,IAAKA,EAAK,MAAOA,EAAK,MAAM,EACzDtD,EAAI,UAAYiE,CACpB,CACC,SAASC,GAAmBlE,EAAKmE,EAAM,CACpC,KAAM,CAAE,EAAA1M,EAAI,EAAAC,EAAI,EAAAyK,EAAI,EAAAiC,EAAI,OAAAxB,CAAS,EAAGuB,EACpCnE,EAAI,IAAIvI,EAAImL,EAAO,QAASlL,EAAIkL,EAAO,QAASA,EAAO,QAAS,CAACzL,EAASJ,EAAI,EAAI,EAClFiJ,EAAI,OAAOvI,EAAGC,EAAI0M,EAAIxB,EAAO,UAAU,EACvC5C,EAAI,IAAIvI,EAAImL,EAAO,WAAYlL,EAAI0M,EAAIxB,EAAO,WAAYA,EAAO,WAAY7L,EAAII,EAAS,EAAI,EAC9F6I,EAAI,OAAOvI,EAAI0K,EAAIS,EAAO,YAAalL,EAAI0M,CAAC,EAC5CpE,EAAI,IAAIvI,EAAI0K,EAAIS,EAAO,YAAalL,EAAI0M,EAAIxB,EAAO,YAAaA,EAAO,YAAazL,EAAS,EAAG,EAAI,EACpG6I,EAAI,OAAOvI,EAAI0K,EAAGzK,EAAIkL,EAAO,QAAQ,EACrC5C,EAAI,IAAIvI,EAAI0K,EAAIS,EAAO,SAAUlL,EAAIkL,EAAO,SAAUA,EAAO,SAAU,EAAG,CAACzL,EAAS,EAAI,EACxF6I,EAAI,OAAOvI,EAAImL,EAAO,QAASlL,CAAC,CACpC,CAEA,MAAM2M,GAAc,uCACdC,GAAa,wEAWf,SAASC,GAAavR,EAAOsP,EAAM,CACnC,MAAMkC,GAAW,GAAKxR,GAAO,MAAMqR,EAAW,EAC9C,GAAI,CAACG,GAAWA,EAAQ,KAAO,SAC3B,OAAOlC,EAAO,IAGlB,OADAtP,EAAQ,CAACwR,EAAQ,GACVA,EAAQ,GAAE,CACb,IAAK,KACD,OAAOxR,EACX,IAAK,IACDA,GAAS,IACT,KACP,CACD,OAAOsP,EAAOtP,CAClB,CACA,MAAMyR,GAAgB5O,GAAI,CAACA,GAAK,EAChC,SAAS6O,EAAkB1R,EAAO2R,EAAO,CACrC,MAAMC,EAAM,CAAA,EACNC,EAAW1R,EAASwR,CAAK,EACzBvQ,EAAOyQ,EAAW,OAAO,KAAKF,CAAK,EAAIA,EACvCG,EAAO3R,EAASH,CAAK,EAAI6R,EAAYE,GAAOxR,EAAeP,EAAM+R,GAAO/R,EAAM2R,EAAMI,GAAM,EAAKA,GAAO/R,EAAM+R,GAAQ,IAAI/R,EAC9H,UAAW+R,KAAQ3Q,EACfwQ,EAAIG,GAAQN,GAAaK,EAAKC,CAAI,CAAC,EAEvC,OAAOH,CACX,CAQI,SAASI,GAAOhS,EAAO,CACvB,OAAO0R,EAAkB1R,EAAO,CAC5B,IAAK,IACL,MAAO,IACP,OAAQ,IACR,KAAM,GACd,CAAK,CACL,CAOI,SAASiS,GAAcjS,EAAO,CAC9B,OAAO0R,EAAkB1R,EAAO,CAC5B,UACA,WACA,aACA,aACR,CAAK,CACL,CAQI,SAASkS,GAAUlS,EAAO,CAC1B,MAAMoD,EAAM4O,GAAOhS,CAAK,EACxB,OAAAoD,EAAI,MAAQA,EAAI,KAAOA,EAAI,MAC3BA,EAAI,OAASA,EAAI,IAAMA,EAAI,OACpBA,CACX,CAOI,SAAS+O,GAAOhQ,EAASiQ,EAAU,CACnCjQ,EAAUA,GAAW,GACrBiQ,EAAWA,GAAYrH,GAAS,KAChC,IAAIuE,EAAO/O,EAAe4B,EAAQ,KAAMiQ,EAAS,IAAI,EACjD,OAAO9C,GAAS,WAChBA,EAAO,SAASA,EAAM,EAAE,GAE5B,IAAII,EAAQnP,EAAe4B,EAAQ,MAAOiQ,EAAS,KAAK,EACpD1C,GAAS,EAAE,GAAKA,GAAO,MAAM4B,EAAU,IACvC,QAAQ,KAAK,kCAAoC5B,EAAQ,GAAG,EAC5DA,EAAQ,QAEZ,MAAMhC,EAAO,CACT,OAAQnN,EAAe4B,EAAQ,OAAQiQ,EAAS,MAAM,EACtD,WAAYb,GAAahR,EAAe4B,EAAQ,WAAYiQ,EAAS,UAAU,EAAG9C,CAAI,EACtF,KAAAA,EACA,MAAAI,EACA,OAAQnP,EAAe4B,EAAQ,OAAQiQ,EAAS,MAAM,EACtD,OAAQ,EAChB,EACI,OAAA1E,EAAK,OAASD,GAAaC,CAAI,EACxBA,CACX,CAWI,SAAS2E,GAAQC,EAAQvF,EAASjF,EAAOyK,EAAM,CAC/C,IAAIC,EAAY,GACZ,EAAGhR,EAAMxB,EACb,IAAI,EAAI,EAAGwB,EAAO8Q,EAAO,OAAQ,EAAI9Q,EAAM,EAAE,EAEzC,GADAxB,EAAQsS,EAAO,GACXtS,IAAU,SAGV+M,IAAY,QAAa,OAAO/M,GAAU,aAC1CA,EAAQA,EAAM+M,CAAO,EACrByF,EAAY,IAEZ1K,IAAU,QAAa7H,EAAQD,CAAK,IACpCA,EAAQA,EAAM8H,EAAQ9H,EAAM,QAC5BwS,EAAY,IAEZxS,IAAU,QACV,OAAIuS,GAAQ,CAACC,IACTD,EAAK,UAAY,IAEdvS,CAGnB,CAMI,SAASyS,GAAUC,EAAQC,EAAOC,EAAa,CAC/C,KAAM,CAAE,IAAArL,EAAM,IAAAC,CAAM,EAAGkL,EACjBG,EAASnS,GAAYiS,GAAQnL,EAAMD,GAAO,CAAC,EAC3CuL,EAAW,CAAC9S,EAAO+S,IAAMH,GAAe5S,IAAU,EAAI,EAAIA,EAAQ+S,EACxE,MAAO,CACH,IAAKD,EAASvL,EAAK,CAAC,KAAK,IAAIsL,CAAM,CAAC,EACpC,IAAKC,EAAStL,EAAKqL,CAAM,CACjC,CACA,CACA,SAASG,GAAcC,EAAelG,EAAS,CAC3C,OAAO,OAAO,OAAO,OAAO,OAAOkG,CAAa,EAAGlG,CAAO,CAC9D,CAEA,SAASmG,EAAgBC,EAAQC,EAAW,CACxC,EACJ,EAAGC,EAAaF,EAAQf,EAAUkB,EAAY,IAAIH,EAAO,GAAI,CACpD3P,EAAQ4O,CAAQ,IACjBA,EAAWmB,GAAS,YAAaJ,CAAM,GAE3C,MAAMhF,EAAQ,CACV,CAAC,OAAO,aAAc,SACtB,WAAY,GACZ,QAASgF,EACT,YAAaE,EACb,UAAWjB,EACX,WAAYkB,EACZ,SAAW3G,GAAQuG,EAAgB,CAC3BvG,EACA,GAAGwG,CACnB,EAAeC,EAAUC,EAAYjB,CAAQ,CAC7C,EACI,OAAO,IAAI,MAAMjE,EAAO,CAC3B,eAAgBtM,EAAQkQ,EAAM,CACnB,cAAOlQ,EAAOkQ,GACd,OAAOlQ,EAAO,MACd,OAAOsR,EAAO,GAAGpB,GACV,EACV,EACR,IAAKlQ,EAAQkQ,EAAM,CACR,OAAOyB,GAAQ3R,EAAQkQ,EAAM,IAAI0B,GAAqB1B,EAAMqB,EAAUD,EAAQtR,CAAM,CAAC,CACxF,EACR,yBAA0BA,EAAQkQ,EAAM,CAC7B,OAAO,QAAQ,yBAAyBlQ,EAAO,QAAQ,GAAIkQ,CAAI,CAClE,EACR,gBAAkB,CACP,OAAO,QAAQ,eAAeoB,EAAO,EAAE,CAC1C,EACR,IAAKtR,EAAQkQ,EAAM,CACR,OAAO2B,GAAqB7R,CAAM,EAAE,SAASkQ,CAAI,CACpD,EACR,QAASlQ,EAAQ,CACN,OAAO6R,GAAqB7R,CAAM,CACrC,EACR,IAAKA,EAAQkQ,EAAM/R,EAAO,CACf,MAAM2T,EAAU9R,EAAO,WAAaA,EAAO,SAAWyR,EAAS,GAC/D,OAAAzR,EAAOkQ,GAAQ4B,EAAQ5B,GAAQ/R,EAC/B,OAAO6B,EAAO,MACP,EACV,CACT,CAAK,CACL,CACC,SAAS+R,EAAeC,EAAO9G,EAAS+G,EAAUC,EAAoB,CACnE,MAAM5F,EAAQ,CACV,WAAY,GACZ,OAAQ0F,EACR,SAAU9G,EACV,UAAW+G,EACX,OAAQ,IAAI,IACZ,aAAcjH,GAAagH,EAAOE,CAAkB,EACpD,WAAa/G,GAAM4G,EAAeC,EAAO7G,EAAK8G,EAAUC,CAAkB,EAC1E,SAAWpH,GAAQiH,EAAeC,EAAM,SAASlH,CAAK,EAAGI,EAAS+G,EAAUC,CAAkB,CACtG,EACI,OAAO,IAAI,MAAM5F,EAAO,CAC3B,eAAgBtM,EAAQkQ,EAAM,CACnB,cAAOlQ,EAAOkQ,GACd,OAAO8B,EAAM9B,GACN,EACV,EACR,IAAKlQ,EAAQkQ,EAAMiC,EAAU,CAClB,OAAOR,GAAQ3R,EAAQkQ,EAAM,IAAIkC,GAAoBpS,EAAQkQ,EAAMiC,CAAQ,CAAC,CAC/E,EACR,yBAA0BnS,EAAQkQ,EAAM,CAC7B,OAAOlQ,EAAO,aAAa,QAAU,QAAQ,IAAIgS,EAAO9B,CAAI,EAAI,CAC5D,WAAY,GACZ,aAAc,EACjB,EAAG,OAAY,QAAQ,yBAAyB8B,EAAO9B,CAAI,CAC/D,EACR,gBAAkB,CACP,OAAO,QAAQ,eAAe8B,CAAK,CACtC,EACR,IAAKhS,EAAQkQ,EAAM,CACR,OAAO,QAAQ,IAAI8B,EAAO9B,CAAI,CACjC,EACR,SAAW,CACA,OAAO,QAAQ,QAAQ8B,CAAK,CAC/B,EACR,IAAKhS,EAAQkQ,EAAM/R,EAAO,CACf,OAAA6T,EAAM9B,GAAQ/R,EACd,OAAO6B,EAAOkQ,GACP,EACV,CACT,CAAK,CACL,CACC,SAASlF,GAAagH,EAAO9I,EAAW,CACrC,WAAY,GACZ,UAAW,EACf,EAAG,CACC,KAAM,CAAE,YAAAmJ,EAAanJ,EAAS,WAAa,WAAAoJ,EAAYpJ,EAAS,UAAY,SAAAqJ,EAAUrJ,EAAS,OAAO,EAAM8I,EAC5G,MAAO,CACH,QAASO,EACT,WAAYF,EACZ,UAAWC,EACX,aAAc1Q,EAAWyQ,CAAW,EAAIA,EAAc,IAAIA,EAC1D,YAAazQ,EAAW0Q,CAAU,EAAIA,EAAa,IAAIA,CAC/D,CACA,CACA,MAAME,GAAU,CAACC,EAAQtJ,IAAOsJ,EAASA,EAAShR,EAAY0H,CAAI,EAAIA,EAChEuJ,EAAmB,CAACxC,EAAM/R,IAAQG,EAASH,CAAK,GAAK+R,IAAS,aAAe,OAAO,eAAe/R,CAAK,IAAM,MAAQA,EAAM,cAAgB,QAClJ,SAASwT,GAAQ3R,EAAQkQ,EAAMM,EAAS,CACpC,GAAI,OAAO,UAAU,eAAe,KAAKxQ,EAAQkQ,CAAI,EACjD,OAAOlQ,EAAOkQ,GAElB,MAAM/R,EAAQqS,IACd,OAAAxQ,EAAOkQ,GAAQ/R,EACRA,CACX,CACA,SAASiU,GAAoBpS,EAAQkQ,EAAMiC,EAAU,CACjD,KAAM,CAAE,OAAAQ,EAAS,SAAAC,EAAW,UAAAC,EAAY,aAAcnI,CAAc,EAAG1K,EACvE,IAAI7B,EAAQwU,EAAOzC,GACnB,OAAItO,EAAWzD,CAAK,GAAKuM,EAAY,aAAawF,CAAI,IAClD/R,EAAQ2U,GAAmB5C,EAAM/R,EAAO6B,EAAQmS,CAAQ,GAExD/T,EAAQD,CAAK,GAAKA,EAAM,SACxBA,EAAQ4U,GAAc7C,EAAM/R,EAAO6B,EAAQ0K,EAAY,WAAW,GAElEgI,EAAiBxC,EAAM/R,CAAK,IAC5BA,EAAQ4T,EAAe5T,EAAOyU,EAAUC,GAAaA,EAAU3C,GAAOxF,CAAW,GAE9EvM,CACX,CACA,SAAS2U,GAAmB5C,EAAM/R,EAAO6B,EAAQmS,EAAU,CACvD,KAAM,CAAE,OAAAQ,EAAS,SAAAC,EAAW,UAAAC,EAAY,OAAAG,CAAM,EAAMhT,EACpD,GAAIgT,EAAO,IAAI9C,CAAI,EACf,MAAM,IAAI,MAAM,uBAAyB,MAAM,KAAK8C,CAAM,EAAE,KAAK,IAAI,EAAI,KAAO9C,CAAI,EAExF,OAAA8C,EAAO,IAAI9C,CAAI,EACf/R,EAAQA,EAAMyU,EAAUC,GAAaV,CAAQ,EAC7Ca,EAAO,OAAO9C,CAAI,EACdwC,EAAiBxC,EAAM/R,CAAK,IAC5BA,EAAQ8U,EAAkBN,EAAO,QAASA,EAAQzC,EAAM/R,CAAK,GAE1DA,CACX,CACA,SAAS4U,GAAc7C,EAAM/R,EAAO6B,EAAQkT,EAAa,CACrD,KAAM,CAAE,OAAAP,EAAS,SAAAC,EAAW,UAAAC,EAAY,aAAcnI,CAAc,EAAG1K,EACvE,GAAI2B,EAAQiR,EAAS,KAAK,GAAKM,EAAYhD,CAAI,EAC3C/R,EAAQA,EAAMyU,EAAS,MAAQzU,EAAM,gBAC9BG,EAASH,EAAM,EAAE,EAAG,CAC3B,MAAMgV,EAAMhV,EACNmT,EAASqB,EAAO,QAAQ,OAAQvN,GAAIA,IAAM+N,CAAG,EACnDhV,EAAQ,CAAA,EACR,UAAW6D,KAAQmR,EAAI,CACnB,MAAMC,EAAWH,EAAkB3B,EAAQqB,EAAQzC,EAAMlO,CAAI,EAC7D7D,EAAM,KAAK4T,EAAeqB,EAAUR,EAAUC,GAAaA,EAAU3C,GAAOxF,CAAW,CAAC,CAC3F,CACJ,CACD,OAAOvM,CACX,CACA,SAASkV,GAAgB9C,EAAUL,EAAM/R,EAAO,CAC5C,OAAOyD,EAAW2O,CAAQ,EAAIA,EAASL,EAAM/R,CAAK,EAAIoS,CAC1D,CACA,MAAM+C,GAAW,CAAClT,EAAKmT,IAASnT,IAAQ,GAAOmT,EAAS,OAAOnT,GAAQ,SAAWoB,EAAiB+R,EAAQnT,CAAG,EAAI,OAClH,SAASoT,GAAUjM,EAAKkM,EAAcrT,EAAKsT,EAAgBvV,EAAO,CAC9D,UAAWoV,KAAUE,EAAa,CAC9B,MAAM3I,EAAQwI,GAASlT,EAAKmT,CAAM,EAClC,GAAIzI,EAAO,CACPvD,EAAI,IAAIuD,CAAK,EACb,MAAMyF,EAAW8C,GAAgBvI,EAAM,UAAW1K,EAAKjC,CAAK,EAC5D,GAAIwD,EAAQ4O,CAAQ,GAAKA,IAAanQ,GAAOmQ,IAAamD,EACtD,OAAOnD,CAEvB,SAAmBzF,IAAU,IAASnJ,EAAQ+R,CAAc,GAAKtT,IAAQsT,EAC7D,OAAO,IAEd,CACD,MAAO,EACX,CACA,SAAST,EAAkBQ,EAAcL,EAAUlD,EAAM/R,EAAO,CAC5D,MAAMqT,EAAa4B,EAAS,YACtB7C,EAAW8C,GAAgBD,EAAS,UAAWlD,EAAM/R,CAAK,EAC1DwV,EAAY,CACd,GAAGF,EACH,GAAGjC,CACX,EACUjK,EAAM,IAAI,IAChBA,EAAI,IAAIpJ,CAAK,EACb,IAAIiC,EAAMwT,GAAiBrM,EAAKoM,EAAWzD,EAAMK,GAAYL,EAAM/R,CAAK,EAIxE,OAHIiC,IAAQ,MAGRuB,EAAQ4O,CAAQ,GAAKA,IAAaL,IAClC9P,EAAMwT,GAAiBrM,EAAKoM,EAAWpD,EAAUnQ,EAAKjC,CAAK,EACvDiC,IAAQ,MACD,GAGRiR,EAAgB,MAAM,KAAK9J,CAAG,EAAG,CACpC,EACR,EAAOiK,EAAYjB,EAAU,IAAIsD,GAAaT,EAAUlD,EAAM/R,CAAK,CAAC,CACpE,CACA,SAASyV,GAAiBrM,EAAKoM,EAAWvT,EAAKmQ,EAAUvO,EAAM,CAC3D,KAAM5B,GACFA,EAAMoT,GAAUjM,EAAKoM,EAAWvT,EAAKmQ,EAAUvO,CAAI,EAEvD,OAAO5B,CACX,CACA,SAASyT,GAAaT,EAAUlD,EAAM/R,EAAO,CACzC,MAAMoV,EAASH,EAAS,aAClBlD,KAAQqD,IACVA,EAAOrD,GAAQ,IAEnB,MAAMlQ,EAASuT,EAAOrD,GACtB,OAAI9R,EAAQ4B,CAAM,GAAK1B,EAASH,CAAK,EAC1BA,EAEJ6B,GAAU,CAAA,CACrB,CACA,SAAS4R,GAAqB1B,EAAMqB,EAAUD,EAAQU,EAAO,CACzD,IAAI7T,EACJ,UAAWsU,KAAUlB,EAEjB,GADApT,EAAQuT,GAASc,GAAQC,EAAQvC,CAAI,EAAGoB,CAAM,EAC1C3P,EAAQxD,CAAK,EACb,OAAOuU,EAAiBxC,EAAM/R,CAAK,EAAI8U,EAAkB3B,EAAQU,EAAO9B,EAAM/R,CAAK,EAAIA,CAGnG,CACA,SAASuT,GAAStR,EAAKkR,EAAQ,CAC3B,UAAWxG,KAASwG,EAAO,CACvB,GAAI,CAACxG,EACD,SAEJ,MAAM3M,EAAQ2M,EAAM1K,GACpB,GAAIuB,EAAQxD,CAAK,EACb,OAAOA,CAEd,CACL,CACA,SAAS0T,GAAqB7R,EAAQ,CAClC,IAAIT,EAAOS,EAAO,MAClB,OAAKT,IACDA,EAAOS,EAAO,MAAQ8T,GAAyB9T,EAAO,OAAO,GAE1DT,CACX,CACA,SAASuU,GAAyBxC,EAAQ,CACtC,MAAM/J,EAAM,IAAI,IAChB,UAAWuD,KAASwG,EAChB,UAAWlR,KAAO,OAAO,KAAK0K,CAAK,EAAE,OAAQ5K,GAAI,CAACA,EAAE,WAAW,GAAG,CAAC,EAC/DqH,EAAI,IAAInH,CAAG,EAGnB,OAAO,MAAM,KAAKmH,CAAG,CACzB,CACA,SAASwM,GAA4BC,EAAMjI,EAAM9G,EAAOgP,EAAO,CAC3D,KAAM,CAAE,OAAAC,CAAS,EAAGF,EACd,CAAE,IAAA5T,EAAK,KAAS,KAAK,SACrB+T,EAAS,IAAI,MAAMF,CAAK,EAC9B,IAAI5U,EAAGM,EAAMsG,EAAOjE,EACpB,IAAI3C,EAAI,EAAGM,EAAOsU,EAAO5U,EAAIM,EAAM,EAAEN,EACjC4G,EAAQ5G,EAAI4F,EACZjD,EAAO+J,EAAK9F,GACZkO,EAAO9U,GAAK,CACR,EAAG6U,EAAO,MAAM1S,EAAiBQ,EAAM5B,CAAG,EAAG6F,CAAK,CAC9D,EAEI,OAAOkO,CACX,CA8KI,SAASC,IAAkB,CAC3B,OAAO,OAAO,OAAW,KAAe,OAAO,SAAa,GAChE,CAGI,SAASC,GAAeC,EAAS,CACjC,IAAIf,EAASe,EAAQ,WACrB,OAAIf,GAAUA,EAAO,SAAQ,IAAO,wBAChCA,EAASA,EAAO,MAEbA,CACX,CAII,SAASgB,EAAcC,EAAY5J,EAAM6J,EAAgB,CACzD,IAAIC,EACJ,OAAI,OAAOF,GAAe,UACtBE,EAAgB,SAASF,EAAY,EAAE,EACnCA,EAAW,QAAQ,GAAG,IAAM,KAE5BE,EAAgBA,EAAgB,IAAM9J,EAAK,WAAW6J,KAG1DC,EAAgBF,EAEbE,CACX,CACA,MAAMC,EAAoBC,GAAUA,EAAQ,cAAc,YAAY,iBAAiBA,EAAS,IAAI,EACpG,SAASC,GAASC,EAAIjR,EAAU,CAC5B,OAAO8Q,EAAiBG,CAAE,EAAE,iBAAiBjR,CAAQ,CACzD,CACA,MAAMkR,GAAY,CACd,MACA,QACA,SACA,MACJ,EACA,SAASC,EAAmBC,EAAQpH,EAAOqH,EAAQ,CAC/C,MAAM7R,EAAS,CAAA,EACf6R,EAASA,EAAS,IAAMA,EAAS,GACjC,QAAQ7V,EAAI,EAAGA,EAAI,EAAGA,IAAI,CACtB,MAAM8V,EAAMJ,GAAU1V,GACtBgE,EAAO8R,GAAO,WAAWF,EAAOpH,EAAQ,IAAMsH,EAAMD,EAAO,GAAK,CACnE,CACD,OAAA7R,EAAO,MAAQA,EAAO,KAAOA,EAAO,MACpCA,EAAO,OAASA,EAAO,IAAMA,EAAO,OAC7BA,CACX,CACA,MAAM+R,GAAe,CAACxS,EAAGC,EAAG7C,KAAU4C,EAAI,GAAKC,EAAI,KAAO,CAAC7C,GAAU,CAACA,EAAO,YAKzE,SAASqV,GAAkB,EAAGlI,EAAQ,CACtC,MAAMmI,EAAU,EAAE,QACZvV,EAASuV,GAAWA,EAAQ,OAASA,EAAQ,GAAK,EAClD,CAAE,QAAAC,EAAU,QAAAC,CAAU,EAAGzV,EAC/B,IAAI0V,EAAM,GACN7S,EAAGC,EACP,GAAIuS,GAAaG,EAASC,EAAS,EAAE,MAAM,EACvC5S,EAAI2S,EACJ1S,EAAI2S,MACD,CACH,MAAMlG,EAAOnC,EAAO,wBACpBvK,EAAI7C,EAAO,QAAUuP,EAAK,KAC1BzM,EAAI9C,EAAO,QAAUuP,EAAK,IAC1BmG,EAAM,EACT,CACD,MAAO,CACH,EAAA7S,EACA,EAAAC,EACA,IAAA4S,CACR,CACA,CAMI,SAASC,GAAoBC,EAAO9I,EAAO,CAC3C,GAAI,WAAY8I,EACZ,OAAOA,EAEX,KAAM,CAAE,OAAAxI,EAAS,wBAAAyI,CAA0B,EAAG/I,EACxCgB,EAAQ8G,EAAiBxH,CAAM,EAC/B0I,EAAYhI,EAAM,YAAc,aAChCiI,EAAWd,EAAmBnH,EAAO,SAAS,EAC9CkI,EAAUf,EAAmBnH,EAAO,SAAU,OAAO,EACrD,CAAE,EAAAjL,EAAI,EAAAC,EAAI,IAAA4S,CAAM,EAAGJ,GAAkBM,EAAOxI,CAAM,EAClDI,EAAUuI,EAAS,MAAQL,GAAOM,EAAQ,MAC1CvI,EAAUsI,EAAS,KAAOL,GAAOM,EAAQ,KAC/C,GAAI,CAAE,MAAAhJ,EAAQ,OAAAiJ,CAAS,EAAGnJ,EAC1B,OAAIgJ,IACA9I,GAAS+I,EAAS,MAAQC,EAAQ,MAClCC,GAAUF,EAAS,OAASC,EAAQ,QAEjC,CACH,EAAG,KAAK,OAAOnT,EAAI2K,GAAWR,EAAQI,EAAO,MAAQyI,CAAuB,EAC5E,EAAG,KAAK,OAAO/S,EAAI2K,GAAWwI,EAAS7I,EAAO,OAASyI,CAAuB,CACtF,CACA,CACA,SAASK,GAAiB9I,EAAQJ,EAAOiJ,EAAQ,CAC7C,IAAIE,EAAUC,EACd,GAAIpJ,IAAU,QAAaiJ,IAAW,OAAW,CAC7C,MAAMI,EAAY/B,GAAelH,CAAM,EACvC,GAAI,CAACiJ,EACDrJ,EAAQI,EAAO,YACf6I,EAAS7I,EAAO,iBACb,CACH,MAAMmC,EAAO8G,EAAU,wBACjBC,EAAiB1B,EAAiByB,CAAS,EAC3CE,EAAkBtB,EAAmBqB,EAAgB,SAAU,OAAO,EACtEE,EAAmBvB,EAAmBqB,EAAgB,SAAS,EACrEtJ,EAAQuC,EAAK,MAAQiH,EAAiB,MAAQD,EAAgB,MAC9DN,EAAS1G,EAAK,OAASiH,EAAiB,OAASD,EAAgB,OACjEJ,EAAW3B,EAAc8B,EAAe,SAAUD,EAAW,aAAa,EAC1ED,EAAY5B,EAAc8B,EAAe,UAAWD,EAAW,cAAc,CAChF,CACJ,CACD,MAAO,CACH,MAAArJ,EACA,OAAAiJ,EACA,SAAUE,GAAY9T,EACtB,UAAW+T,GAAa/T,CAChC,CACA,CACA,MAAMoU,EAAUxV,GAAI,KAAK,MAAMA,EAAI,EAAE,EAAI,GAEzC,SAASyV,GAAetJ,EAAQuJ,EAASC,EAAUC,EAAa,CAC5D,MAAM/I,EAAQ8G,EAAiBxH,CAAM,EAC/B0J,EAAU7B,EAAmBnH,EAAO,QAAQ,EAC5CqI,EAAW3B,EAAc1G,EAAM,SAAUV,EAAQ,aAAa,GAAK/K,EACnE+T,EAAY5B,EAAc1G,EAAM,UAAWV,EAAQ,cAAc,GAAK/K,EACtE0U,EAAgBb,GAAiB9I,EAAQuJ,EAASC,CAAQ,EAChE,GAAI,CAAE,MAAA5J,EAAQ,OAAAiJ,CAAS,EAAGc,EAC1B,GAAIjJ,EAAM,YAAc,cAAe,CACnC,MAAMkI,EAAUf,EAAmBnH,EAAO,SAAU,OAAO,EACrDiI,EAAWd,EAAmBnH,EAAO,SAAS,EACpDd,GAAS+I,EAAS,MAAQC,EAAQ,MAClCC,GAAUF,EAAS,OAASC,EAAQ,MACvC,CACD,OAAAhJ,EAAQ,KAAK,IAAI,EAAGA,EAAQ8J,EAAQ,KAAK,EACzCb,EAAS,KAAK,IAAI,EAAGY,EAAc7J,EAAQ6J,EAAcZ,EAASa,EAAQ,MAAM,EAChF9J,EAAQyJ,EAAO,KAAK,IAAIzJ,EAAOmJ,EAAUY,EAAc,QAAQ,CAAC,EAChEd,EAASQ,EAAO,KAAK,IAAIR,EAAQG,EAAWW,EAAc,SAAS,CAAC,EAChE/J,GAAS,CAACiJ,IAGVA,EAASQ,EAAOzJ,EAAQ,CAAC,IAEN2J,IAAY,QAAaC,IAAa,SACvCC,GAAeE,EAAc,QAAUd,EAASc,EAAc,SAChFd,EAASc,EAAc,OACvB/J,EAAQyJ,EAAO,KAAK,MAAMR,EAASY,CAAW,CAAC,GAE5C,CACH,MAAA7J,EACA,OAAAiJ,CACR,CACA,CAMI,SAASe,GAAYlK,EAAOmK,EAAYC,EAAY,CACpD,MAAMC,EAAaF,GAAc,EAC3BG,EAAe,KAAK,MAAMtK,EAAM,OAASqK,CAAU,EACnDE,EAAc,KAAK,MAAMvK,EAAM,MAAQqK,CAAU,EACvDrK,EAAM,OAAS,KAAK,MAAMA,EAAM,MAAM,EACtCA,EAAM,MAAQ,KAAK,MAAMA,EAAM,KAAK,EACpC,MAAMM,EAASN,EAAM,OAQrB,OAJIM,EAAO,QAAU8J,GAAc,CAAC9J,EAAO,MAAM,QAAU,CAACA,EAAO,MAAM,SACrEA,EAAO,MAAM,OAAS,GAAGN,EAAM,WAC/BM,EAAO,MAAM,MAAQ,GAAGN,EAAM,WAE9BA,EAAM,0BAA4BqK,GAAc/J,EAAO,SAAWgK,GAAgBhK,EAAO,QAAUiK,GACnGvK,EAAM,wBAA0BqK,EAChC/J,EAAO,OAASgK,EAChBhK,EAAO,MAAQiK,EACfvK,EAAM,IAAI,aAAaqK,EAAY,EAAG,EAAGA,EAAY,EAAG,CAAC,EAClD,IAEJ,EACX,CAKS,MAACG,GAA+B,UAAW,CAChD,IAAIC,EAAmB,GACvB,GAAI,CACA,MAAMhX,EAAU,CACZ,IAAI,SAAW,CACX,OAAAgX,EAAmB,GACZ,EACV,CACb,EACQ,OAAO,iBAAiB,OAAQ,KAAMhX,CAAO,EAC7C,OAAO,oBAAoB,OAAQ,KAAMA,CAAO,CACnD,MAAC,CAED,CACD,OAAOgX,CACX,EAAI,EASA,SAASC,GAAa3C,EAAS/Q,EAAU,CACzC,MAAM1F,EAAQ0W,GAASD,EAAS/Q,CAAQ,EAClC8L,EAAUxR,GAASA,EAAM,MAAM,mBAAmB,EACxD,OAAOwR,EAAU,CAACA,EAAQ,GAAK,MACnC,CAqCA,MAAM6H,GAAwB,SAASC,EAAO1K,EAAO,CACjD,MAAO,CACH,EAAGnK,EAAG,CACF,OAAO6U,EAAQA,EAAQ1K,EAAQnK,CAClC,EACD,SAAU0K,EAAG,CACTP,EAAQO,CACX,EACD,UAAWtF,EAAO,CACd,OAAIA,IAAU,SACHA,EAEJA,IAAU,QAAU,OAAS,OACvC,EACD,MAAOpF,EAAGzE,EAAO,CACb,OAAOyE,EAAIzE,CACd,EACD,WAAYyE,EAAG8U,EAAW,CACtB,OAAO9U,EAAI8U,CACd,CACT,CACA,EACMC,GAAwB,UAAW,CACrC,MAAO,CACH,EAAG/U,EAAG,CACF,OAAOA,CACV,EACD,SAAU0K,EAAG,CAAE,EACf,UAAWtF,EAAO,CACd,OAAOA,CACV,EACD,MAAOpF,EAAGzE,EAAO,CACb,OAAOyE,EAAIzE,CACd,EACD,WAAYyE,EAAGgV,EAAY,CACvB,OAAOhV,CACV,CACT,CACA,EACA,SAASiV,GAAcxP,EAAKoP,EAAO1K,EAAO,CACtC,OAAO1E,EAAMmP,GAAsBC,EAAO1K,CAAK,EAAI4K,GAAqB,CAC5E,CACA,SAASG,GAAsB3M,EAAK4M,EAAW,CAC3C,IAAIlK,EAAOmK,GACPD,IAAc,OAASA,IAAc,SACrClK,EAAQ1C,EAAI,OAAO,MACnB6M,EAAW,CACPnK,EAAM,iBAAiB,WAAW,EAClCA,EAAM,oBAAoB,WAAW,CACjD,EACQA,EAAM,YAAY,YAAakK,EAAW,WAAW,EACrD5M,EAAI,kBAAoB6M,EAEhC,CACA,SAASC,GAAqB9M,EAAK6M,EAAU,CACrCA,IAAa,SACb,OAAO7M,EAAI,kBACXA,EAAI,OAAO,MAAM,YAAY,YAAa6M,EAAS,GAAIA,EAAS,EAAE,EAE1E"}